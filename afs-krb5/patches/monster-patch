Index: README
diff -u /dev/null krb5/README:1.6
@@ -0,0 +1,122 @@
+Notes on the NRL Kerberos CVS tree:
+
+This is a working copy of the sources I use for Kerberos development.
+Changes I (and others) make to Kerberos are made available via this
+CVS tree.
+
+If you're not familiar with CVS, the documentation that comes with
+the distribution is a good starting point.  The important things you
+need to know are:
+
+	cvs checkout - Gets the initial copy of the source tree
+	cvs update   - Brings external changes into your local working
+		       directory.
+	cvs commit   - Puts changes you made in your working directory
+		       into the revision control directory.
+
+This distribution is set up as a "development" distribution, which means
+it differs slightly from the normal distribution from MIT.  For example,
+there are no configure scripts included in the CVS tree.  This is because
+they are automatically generated, and it makes no sense to put automatically
+generated files under revision control.
+
+To build the distribution from the CVS tree, you will need:
+
+- The latest copy of GNU m4.
+- The latest copy of GNU make.
+
+Steps for building the distribution:
+
+1) First, you will need to build Autoconf.  Note that you _must_ use the
+   copy of Autoconf that comes with Kerberos - not the standard GNU
+   Autoconf.  This requires GNU m4.  To build Autoconf, do (from the top
+   of the Kerberos source tree):
+
+   cd util/autoconf
+   ./configure
+   make
+
+2) Generate all of the configure scripts and automatically generated
+   header files.
+
+   cd <top of source tree>
+   ./util/reconf
+
+3) Run configure.  I _highly_ recommend that you build Kerberos in an
+   object directory.  This makes CVS management a lot easier and gives
+   you the ability to build for multiple architectures from the same
+   source code tree.  To do this:
+
+   mkdir <object-directory>
+   cd <object-directory>
+   <source-directory>/configure <... your configure options ...>
+
+4) Build the distribution.  This requires GNU make.
+
+   cd <object-directory>
+   gmake (or whatever you call GNU make)
+
+
+In addition to the standard configure options, this distribution has
+a number of extra ones:
+
+--with-afs=AFSDIR
+
+	Enable AFS compatibility.  This will make the application daemons
+	create PAGs and run aklog at the appropriate places.  AFSDIR
+	is the location of the AFS client libraries.
+
+--enable-irix-project-init
+
+	Have login.krb5 call the right functions to set up the array
+	session and project id for Irix 6.4 and newer systems.
+
+--without-session-encrypt
+
+	Disable session encryption in the client programs.  Should only
+	be enabled to create exportable binaries.
+
+--with-pty-wtmp
+
+	Use the logwtmp() function in the pty library for the ftp daemon.
+	This will stop logging from working for anonymous ftp, but it
+	makes ftpd log correctly on System V-based systems (Irix, Solaris,
+	HP/UX).
+
+--with-afs-name-change
+
+	Enable extra code to support an AFS cell with a different name
+	than your Kerberos realm.
+
+--with-securid-preauth=DIR
+
+	Enable code to support SecurID cards as a hardware preauthentication
+	mechanism.  DIR is the directory containing sdiclient.a and
+	the SecurID client include files.  Note: this is very buggy,
+	mostly due to the _extremely_ poor interface to the SecurID
+	cards.  Not recommended.
+
+--without-strptime
+
+	Never use the native strptime() library function, but always
+	use the one included in the Kerberos library.  Only useful
+	for Irix 6.x systems, which have a buggy strptime().
+
+--enable-app-proxy
+
+	Enable code to support application proxy gateways by allowing
+	the addition of extra IP addresses into the ticket.  Experimental.
+
+--enable-btree-db
+
+	Use a btree database for the KDC instead of a hash database.
+	Highly recommended.
+
+--with-cracklib=<full path to libcrack.a>
+
+	Use cracklib instead of a flat dictionary file for password checking.
+	libcrack.a must be installed where it can be found. You need to set
+	dict_file in kdc.conf so that it is the path and prefix of the
+	cracklib dictionary files (e.g. if your dictionary files are in
+	/usr/local/lib/pw_dict.{hwm,pwi,pwd} then you should have
+	dict_file = /usr/local/lib/pw_dict in kdc.conf).
Index: aclocal.m4
diff -u krb5/aclocal.m4:1.1.1.1 krb5/aclocal.m4:1.4
@@ -862,11 +862,7 @@
 AC_SUBST(LD_SHLIBDIR_PREFIX)
 SHLIB_RPATH_DIRS=
 if test $krb5_cv_shlibs_use_dirs = yes ; then
-	if test $krb5_cv_shlibs_use_colon_dirs = yes ; then
-		SHLIB_RPATH_DIRS="${krb5_cv_shlibs_dirhead}$(KRB5_SHLIBDIR)"
-	else
 		SHLIB_RPATH_DIRS="${krb5_cv_shlibs_dirhead}\$(KRB5_SHLIBDIR)"
-	fi
 fi
 AC_SUBST(SHLIB_RPATH_DIRS)
 SHLIB_LIBDIRS="-L\$(TOPLIBD)"
Index: configure.in
diff -u krb5/configure.in:1.1.1.1 krb5/configure.in:1.2
@@ -223,6 +223,28 @@
 	krb5_cv_shlibs_run_libpath=no
 	krb5_cv_shlibs_run_rldroot=no
   	;;
+mips-*-irix*)
+	echo "Enabling shared libraries for Irix ..."
+	krb5_cv_shlibs_cflags=
+	krb5_cv_shlibs_ext=so
+	krb5_cv_noshlibs_ext=a
+	krb5_cv_shlibs_versioned_filenames=yes
+	krb5_cv_shlibs_need_nover=yes
+	krb5_cv_shlibs_dir=
+	krb5_cv_shlibs_ldflag=
+	krb5_cv_noshlibs_ldflag="-Bstatic"
+	krb5_cv_shlibs_sym_ufo="-U "
+	krb5_cv_shlibs_dirhead="-rpath "
+	krb5_cv_exe_need_dirs=yes
+	krb5_cv_shlibs_use_dirs=yes
+	krb5_cv_shlibs_use_colon_dirs=no
+	krb5_cv_shlibs_tail_comp=
+	krb5_cv_staticlibs_enabled=yes
+	krb5_cv_shlibs_enabled=yes
+	krb5_cv_shlibs_run_ldpath=default
+	krb5_cv_shlibs_run_libpath=no
+	krb5_cv_shlibs_run_rldroot=no
+	;;
 *) 
 	echo " "
 	echo "Shared libraries not supported on $krb5_cv_host"
Index: appl/bsd/Makefile.in
diff -u krb5/appl/bsd/Makefile.in:1.1.1.1 krb5/appl/bsd/Makefile.in:1.2
@@ -60,7 +60,7 @@
 	fi
 
 kshd: krshd.o kcmd.o  forward.o $(SETENVOBJ) $(LIBOBJS) $(DEPLIBS)
-	$(LD) $(LDFLAGS) $(LDARGS) -o kshd krshd.o kcmd.o  forward.o $(SETENVOBJ) $(LIBOBJS) $(LIBS)
+	$(LD) $(LDFLAGS) $(LDARGS) -o kshd krshd.o kcmd.o  forward.o $(SETENVOBJ) $(LIBOBJS) $(LOGINLIBS) $(LIBS)
 
 klogind: krlogind.o  kcmd.o forward.o $(SETENVOBJ) $(LIBOBJS) $(DEPLIBS)
 	$(LD) $(LDFLAGS) $(LDARGS) -o klogind krlogind.o  kcmd.o forward.o $(SETENVOBJ) $(LIBOBJS) $(LIBS)
Index: appl/bsd/configure.in
diff -u krb5/appl/bsd/configure.in:1.1.1.1 krb5/appl/bsd/configure.in:1.6
@@ -2,13 +2,30 @@
 CONFIG_RULES
 LOGINLIBS=
 AC_ARG_WITH([afs],
-[  --without-afs        don't have afs libraries to build against (default)
-  --with-afs=AFSDIR    use preinstalled AFS library tree],
+[  --without-afs           don't have afs libraries to build against (default)
+  --with-afs=AFSDIR       use preinstalled AFS library tree],
 ,with_afs=no)dnl
 if test $with_afs != no; then
 	AC_DEFINE(SETPAG)
-	LOGINLIBS="$LOGINLIBS -L$with_afs/lib -L$with_afs/lib/afs -lauth -lsys -lrx -llwp"
-fi
+	LOGINLIBS="$LOGINLIBS -L$with_afs/lib -L$with_afs/lib/afs -lauth -lsys -lrx -llwp -lsys"
+	case $krb5_cv_host in
+	*-*-solaris*)
+		LOGINLIBS="$LOGINLIBS -lc -L/usr/ucblib -lucb -R/usr/ucblib"
+		;;
+	*-*-hpux*)
+		LOGINLIBS="$LOGINLIBS -lBSD -lm"
+		;;
+	*-*-netbsd*)
+		LOGINLIBS="$LOGINLIBS -lcompat"
+		;;
+	esac
+fi
+AC_ARG_ENABLE([irix-project-init],
+[  --enable-irix-project-init   Initialize the IRIX project id at login
+  --disable-irix-project-init  Don't do IRIX project setup (default)],[
+AC_MSG_RESULT(Enabling IRIX project initialization support)
+AC_DEFINE(IRIX_PROJECT_INIT)
+])
 AC_PROG_INSTALL
 dnl dbm libs for use of an_to_ln
 AC_CHECK_LIB(util,main)
@@ -83,6 +100,7 @@
 AC_CHECK_HEADERS(unistd.h stdlib.h string.h sys/filio.h sys/sockio.h )
 AC_CHECK_HEADERS(sys/label.h sys/tty.h ttyent.h lastlog.h sys/select.h )
 AC_CHECK_HEADERS(sys/ptyvar.h utmp.h sys/time.h)
+AC_CHECK_HEADERS(paths.h)
 AC_HEADER_STDARG
 AC_REPLACE_FUNCS(getdtablesize)
 KRB5_SIGTYPE
@@ -232,5 +250,13 @@
 	LIBS=$oldlibs
 fi
 
+dnl Do we want to exclude session encryption?
+do_encrypt=yes
+AC_ARG_WITH([session-encrypt],
+[  --with-session-encrypt     Support session encryption (default)
+  --without-session-encrypt  Disable session encryption],do_encrypt=$withval)
+if test $do_encrypt = no; then
+	AC_DEFINE(NOENCRYPTION)
+fi
 AC_CHECK_HEADERS(krb4-proto.h)
 V5_AC_OUTPUT_MAKEFILE
Index: appl/bsd/kcmd.c
diff -u krb5/appl/bsd/kcmd.c:1.1.1.1 krb5/appl/bsd/kcmd.c:1.6
@@ -37,7 +37,11 @@
 #define _TYPES_
 #endif
 #include <fcntl.h>
-     
+
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+
 #ifndef MAXPATHLEN
 #define MAXPATHLEN 1024
 #endif
@@ -46,6 +50,10 @@
 #include <sys/socket.h>
 #include <sys/stat.h>
 
+#ifdef HAVE_SYS_SELECT_H
+#include <sys/select.h>
+#endif
+
 #ifndef POSIX_SIGNALS
 #ifndef sigmask
 #define sigmask(m)    (1 << ((m)-1))
@@ -60,6 +68,9 @@
 
 #include "defines.h"
 
+#ifndef max
+#define max(a, b)	((a > b) ? a : b)
+#endif
 
 #define START_PORT      5120     /* arbitrary */
 char *default_service = "host";
@@ -83,7 +94,7 @@
      krb5_flags authopts;
      int anyport;
 {
-    int i, s, timo = 1, pid;
+    int i, s, timo = 1, pid, numaddrs;
 #ifdef POSIX_SIGNALS
     sigset_t oldmask, urgmask;
 #else
@@ -107,6 +118,8 @@
     krb5_auth_context auth_context = NULL;
     char *cksumbuf;
     krb5_data cksumdat;
+    char **save_addr_list;
+    char **addr;
 
     if ((cksumbuf = malloc(strlen(cmd)+strlen(remuser)+64)) == 0 ) {
 	fprintf(stderr, "Unable to allocate memory for checksum buffer.\n");
@@ -132,6 +145,28 @@
 
     strcpy(host_save, hp->h_name);
 
+    /*
+     * Save the list of IP address too, for later
+     */
+
+    for (addr = hp->h_addr_list, numaddrs = 0; *addr; addr++)
+	numaddrs++;
+
+    if ((save_addr_list = (char **) malloc(sizeof(char *) * (numaddrs + 1))) ==
+									NULL) {
+	fprintf(stderr, "kcmd: no memory\n");
+	return(-1);
+    }
+
+    for (i = 0; i < numaddrs; i++) {
+	if ((save_addr_list[i] = (char *) malloc(hp->h_length)) == NULL) {
+	    fprintf(stderr, "kcmd: no memory\n");
+	    return(-1);
+	}
+	memcpy(save_addr_list[i], hp->h_addr_list[i], hp->h_length);
+    }
+    save_addr_list[numaddrs] = NULL;
+
     /* If no service is given set to the default service */
     if (!service) service = default_service;
     
@@ -163,7 +198,9 @@
 #else
     oldmask = sigblock(sigmask(SIGURG));
 #endif /* POSIX_SIGNALS */
-    
+
+    addr = save_addr_list;
+
     for (;;) {
         s = getport(&lport);
     	if (s < 0) {
@@ -177,10 +214,13 @@
 	    sigsetmask(oldmask);
 #endif /* POSIX_SIGNALS */
 	    krb5_free_creds(bsd_context, get_cred);
+	    for (addr = save_addr_list; *addr; addr++)
+		free(*addr);
+	    free(save_addr_list);
 	    return (-1);
     	}
     	sin.sin_family = hp->h_addrtype;
-    	memcpy((caddr_t)&sin.sin_addr,hp->h_addr, sizeof(sin.sin_addr));
+    	memcpy((caddr_t)&sin.sin_addr,addr[0], sizeof(sin.sin_addr));
     	sin.sin_port = rport;
     	if (connect(s, (struct sockaddr *)&sin, sizeof (sin)) >= 0)
 	  break;
@@ -190,22 +230,20 @@
 	    continue;
     	}
 
-#if !(defined(tek) || defined(ultrix) || defined(sun) || defined(SYSV))
-    	if (hp->h_addr_list[1] != NULL) {
+    	if (addr[1] != NULL) {
 	    int oerrno = errno;
 	    
 	    fprintf(stderr,
     		    "connect to address %s: ", inet_ntoa(sin.sin_addr));
 	    errno = oerrno;
 	    perror(0);
-	    hp->h_addr_list++;
-	    memcpy((caddr_t)&sin.sin_addr,hp->h_addr_list[0],
+	    addr++;
+	    memcpy((caddr_t)&sin.sin_addr,addr[0],
 		   sizeof(sin.sin_addr));
 	    fprintf(stderr, "Trying %s...\n",
 		    inet_ntoa(sin.sin_addr));
 	    continue;
     	}
-#endif /* !(defined(ultrix) || defined(sun)) */
     	perror(host_save);
 #ifdef POSIX_SIGNALS
 	sigprocmask(SIG_SETMASK, &oldmask, (sigset_t*)0);
@@ -213,8 +251,14 @@
     	sigsetmask(oldmask);
 #endif /* POSIX_SIGNALS */
 	krb5_free_creds(bsd_context, get_cred);
+	for (addr = save_addr_list; *addr; addr++)
+	    free(*addr);
+	free(save_addr_list);
     	return (-1);
     }
+    for (addr = save_addr_list; *addr; addr++)
+	free(*addr);
+    free(save_addr_list);
     lport--;
     if (fd2p == 0) {
     	write(s, "", 1);
@@ -223,6 +267,8 @@
     	char num[8];
     	int s2 = getport(&lport), s3;
     	int len = sizeof (from);
+	int nfds;
+	fd_set reads;
 	
     	if (s2 < 0) {
 	    status = -1;
@@ -236,6 +282,30 @@
 	    status = -1;
 	    goto bad;
     	}
+	nfds = max(s, s2)+1;
+	if(nfds > FD_SETSIZE) {
+	    fprintf(stderr, "rcmd: too many files\n");
+	    (void)close(s2);
+	    status = -1;
+	    goto bad;
+	}
+    again:
+	FD_ZERO(&reads);
+	FD_SET(s, &reads);
+	FD_SET(s2, &reads);
+	errno = 0;
+	if (select(nfds, &reads, 0, 0, 0) < 1 || !FD_ISSET(s2, &reads)){
+	    if (errno != 0)
+		(void)fprintf(stderr,
+			      "rcmd: select (setting up stderr): %s\n",
+			      strerror(errno));
+	    else
+		(void)fprintf(stderr,
+			      "select: protocol failure in circuit setup\n");
+	    (void)close(s2);
+	    status = -1;
+	    goto bad;
+	}
     	s3 = accept(s2, (struct sockaddr *)&from, &len);
     	(void) close(s2);
     	if (s3 < 0) {
@@ -333,7 +403,8 @@
 					ret_cred->client, ret_cred->server,
 					0, options & OPTS_FORWARDABLE_CREDS,
 					&outbuf)) {
-	    fprintf(stderr, "kcmd: Error getting forwarded creds\n");
+	    fprintf(stderr, "kcmd: Error getting forwarded creds (%s)\n",
+		error_message(status));
 	    goto bad2;
 	}
 
Index: appl/bsd/krcp.c
diff -u krb5/appl/bsd/krcp.c:1.1.1.1 krb5/appl/bsd/krcp.c:1.4
@@ -79,6 +79,7 @@
 #ifdef KERBEROS
 #include "krb5.h"
 #include "com_err.h"
+#include "defines.h"
      
 #define RCP_BUFSIZ 4096
      
@@ -103,6 +104,8 @@
 void 	usage(), sink(), source(), rsource(), verifydir(), answer_auth();
 int	response(), hosteq(), okname(), susystem();
 int	encryptflag = 0;
+int	encrypt_option_flag = -1;
+int	forward_flag = -1;
 
 #ifndef UCB_RCP
 #define	UCB_RCP	"/bin/rcp"
@@ -113,6 +116,11 @@
 #define	des_write	write
 #endif /* KERBEROS */
 
+#ifdef NOENCRYPTION
+#define	des_read	read
+#define	des_write	write
+#endif /* NOENCRYPTION */
+
 int	rem;
 char	*colon();
 int	errs;
@@ -152,6 +160,7 @@
     char buf[RCP_BUFSIZ], cmdbuf[30];
     char *cmd = cmdbuf;
     struct servent *sp;
+    struct servent defaultservent;
     static char curhost[256];
 #ifdef POSIX_SIGNALS
     struct sigaction sa;
@@ -196,13 +205,21 @@
 	    port = htons(atoi(*argv));
 	    goto next_arg;
 
-	  case 'N':
+	  case 'n':
 	    forcenet++;
 	    break;
 
 #ifdef KERBEROS
 	  case 'x':
-	    encryptflag++;
+#ifdef NOENCRYPTION
+			fprintf(stderr, "rcp: encryption not supported\n");
+	     usage(); /* Does not return */
+#else /* NOENCRYPTION */
+	    encrypt_option_flag = 1;
+	    break;
+#endif /* NOENCRYPTION */
+	  case 'X':
+	    encrypt_option_flag = 0;
 	    break;
 	  case 'k':		/* Change kerberos realm */
 	    argc--, argv++;
@@ -234,6 +251,20 @@
 	    }
 	    strcpy(krb_config, *argv);	
 	    goto next_arg;
+	  case 'F':		/* Forward credentials */
+	    if (forward_flag != -1) {
+		fprintf(stderr, "Cannot use both -F and -n.\n");
+		exit(1);
+	    }
+	    forward_flag = 1;
+	    break;
+	  case 'N':		/* Don't forward credentials */
+	    if (forward_flag != -1) {
+		fprintf(stderr, "Cannot use both -F and -n.\n");
+		exit(1);
+	    }
+	    forward_flag = 0;
+	    break;
 #endif /* KERBEROS */
 	    /* The rest of these are not for users. */
 	  case 'd':
@@ -242,10 +273,10 @@
 	    
 	  case 'f':		/* "from" */
 	    iamremote = 1;
-#if defined(KERBEROS)
-	    if (encryptflag)
+#if defined(KERBEROS) && !defined(NOENCRYPTION)
+	    if (encryptflag || encrypt_option_flag == 1)
 	      answer_auth(krb_config, krb_cache);
-#endif /* KERBEROS */
+#endif /* KERBEROS && !NOENCRYPTION */
 
 	    (void) response();
 	    source(--argc, ++argv);
@@ -253,10 +284,10 @@
 	    
 	  case 't':		/* "to" */
 	    iamremote = 1;
-#if defined(KERBEROS)
-	    if (encryptflag)
+#if defined(KERBEROS) && !defined(NOENCRYPTION)
+	    if (encryptflag || encrypt_option_flag == 1)
 	      answer_auth(krb_config, krb_cache);
-#endif /* KERBEROS */
+#endif /* KERBEROS && !NOENCRYPTION */
 
 	    sink(--argc, ++argv);
 	    exit(errs);
@@ -283,8 +314,8 @@
     
       if (sp == NULL) {
 #ifdef KERBEROS
-	fprintf(stderr, "rcp: kshell/tcp: unknown service\n");
-	try_normal(orig_argv);
+	sp = &defaultservent;
+	sp->s_port = htons(544);
 #else
 	fprintf(stderr, "rcp: shell/tcp: unknown service\n");
 	exit(1);
@@ -294,6 +325,32 @@
     }
 
 #ifdef KERBEROS
+
+    {
+	krb5_data realm;
+
+	if (krb_realm) {
+		realm.data = krb_realm;
+	} else {
+		krb5_get_default_realm(bsd_context, &realm.data);
+	}
+
+	if (encrypt_option_flag == -1) {
+		krb5_appdefault_boolean(bsd_context, "rcp", &realm, "encrypt",
+					0, &encryptflag);
+	} else {
+		encryptflag = encrypt_option_flag;
+	}
+
+	if (forward_flag == -1) {
+		krb5_appdefault_boolean(bsd_context, "rcp", &realm, "forward",
+					0, &forward_flag);
+	}
+
+	if (! krb_realm)
+		free(realm.data);
+    }
+
     if (krb_realm != NULL)
 	cmdsiz += strlen(krb_realm);
     if (krb_cache != NULL)
@@ -411,7 +468,8 @@
 				   cmd, targ);
 		    host = thost;
 #ifdef KERBEROS
-		    authopts = AP_OPTS_MUTUAL_REQUIRED;
+		    authopts = AP_OPTS_MUTUAL_REQUIRED |
+			       (forward_flag ? OPTS_FORWARD_CREDS : 0);
 		    status = kcmd(&sock, &host,
 				  port,
 				  pwd->pw_name,
@@ -510,7 +568,8 @@
 		}
 		(void) sprintf(buf, "%s -f %s", cmd, src);
 #ifdef KERBEROS
-		authopts = AP_OPTS_MUTUAL_REQUIRED;
+		authopts = AP_OPTS_MUTUAL_REQUIRED |
+			   (forward_flag ? OPTS_FORWARD_CREDS : 0);
 		status = kcmd(&sock, &host,
 			      port,
 			      pwd->pw_name,  suser,
@@ -1180,8 +1239,13 @@
 void usage()
 {
 #ifdef KERBEROS
+#ifdef NOENCRYPTION
+    fprintf(stderr,
+	    "Usage: \trcp [-p] [-k realm] f1 f2; or:\n\trcp [-r] [-p] [-k realm] f1 ... fn d2\n");
+#else /* NOENCRYPTION */
     fprintf(stderr,
 	    "Usage: \trcp [-p] [-x] [-k realm] f1 f2; or:\n\trcp [-r] [-p] [-x] [-k realm] f1 ... fn d2\n");
+#endif /* NOENCRYPTION */
 #else
     fputs("usage: rcp [-p] f1 f2; or: rcp [-rp] f1 ... fn d2\n", stderr);
 #endif
@@ -1261,6 +1325,7 @@
 
 
 
+#ifndef NOENCRYPTION
 
 void
   answer_auth(config_file, ccache_file)
@@ -1467,4 +1532,5 @@
     return(len);
 }
 
+#endif /* NOENCRYPTION */
 #endif /* KERBEROS */
Index: appl/bsd/krlogin.c
diff -u krb5/appl/bsd/krlogin.c:1.1.1.1 krb5/appl/bsd/krlogin.c:1.4
@@ -156,6 +156,8 @@
 void try_normal();
 char *krb_realm = (char *)0;
 int encrypt_flag = 0;
+int encrypt_option_flag = -1;
+int no_forward = 0;
 int fflag = 0, Fflag = 0;
 krb5_creds *cred;
 struct sockaddr_in local, foreign;
@@ -171,6 +173,11 @@
 #define des_write write
 #endif /* KERBEROS */
 
+#ifdef NOENCRYPTION
+#define des_read read
+#define des_write write
+#endif /* NOENCRYPTION */
+
 # ifndef TIOCPKT_WINDOW
 # define TIOCPKT_WINDOW 0x80
 # endif /* TIOCPKT_WINDOW */
@@ -439,7 +446,17 @@
 	goto another;
     }
     if (argc > 0 && !strcmp(*argv, "-x")) {
-	encrypt_flag++;
+#ifdef NOENCRYPTION
+	fprintf(stderr, "rlogin: encryption not supported\n");
+	goto usage;
+#else /* NOENCRYPTION */
+	encrypt_option_flag = 1;
+	argv++, argc--;
+	goto another;
+#endif /* NOENCRYPTION */
+    }
+    if (argc > 0 && !strcmp(*argv, "-X")) {
+	encrypt_option_flag = 0;
 	argv++, argc--;
 	goto another;
     }
@@ -461,6 +478,11 @@
 	argv++, argc--;
 	goto another;
     }
+    if (argc > 0 && !strcmp(*argv, "-N")) {
+	no_forward++;
+	argv++, argc--;
+	goto another;
+    }
 #endif /* KERBEROS */
     if (host == 0)
       goto usage;
@@ -479,6 +501,25 @@
     }
     desinbuf.data = des_inbuf;
     desoutbuf.data = des_outpkt+4;	/* Set up des buffers */
+
+    {
+	krb5_data realm;
+	int eflag;
+
+	if (krb_realm) {
+		realm.data = krb_realm;
+	} else {
+		krb5_get_default_realm(bsd_context, &realm.data);
+	}
+
+	krb5_appdefault_boolean(bsd_context, "rlogin", &realm, "encrypt", 0,
+				&eflag);
+	
+	encrypt_flag = encrypt_option_flag == -1 ? eflag : encrypt_option_flag;
+
+	if (! krb_realm)
+		krb5_xfree(realm.data);
+    }
 #endif
 
 
@@ -577,6 +618,24 @@
 #ifdef KERBEROS
     authopts = AP_OPTS_MUTUAL_REQUIRED;
 
+    if (! (fflag || Fflag) && ! no_forward) {
+	krb5_data realm;
+
+	if (krb_realm) {
+		realm.data = krb_realm;
+	} else {
+		krb5_get_default_realm(bsd_context, &realm.data);
+	}
+
+	krb5_appdefault_boolean(bsd_context, "rlogin", &realm, "forward", 0,
+				&fflag);
+	krb5_appdefault_boolean(bsd_context, "rlogin", &realm, "forwardable", 0,
+				&Fflag);
+	
+	if (! krb_realm)
+		krb5_xfree(realm.data);
+    }
+
     /* Piggy-back forwarding flags on top of authopts; */
     /* they will be reset in kcmd */
     if (fflag || Fflag)
@@ -636,7 +695,11 @@
 #ifdef KERBEROS
     fprintf (stderr,
 	     "usage: rlogin host [-option] [-option...] [-k realm ] [-t ttytype] [-l username]\n");
+#ifdef NOENCRYPTION
+    fprintf (stderr, "     where option is e, 7, 8, noflow, n, a, f, F, or c\n");
+#else /* NOENCRYPTION */
     fprintf (stderr, "     where option is e, 7, 8, noflow, n, a, x, f, F, or c\n");
+#endif /* NOENCRYPTION */
 #else /* !KERBEROS */
     fprintf (stderr,
 	     "usage: rlogin host [-option] [-option...] [-t ttytype] [-l username]\n");
@@ -1570,6 +1633,10 @@
      char **argv;
 {
     register char *host;
+#ifdef POSIX_SIGNALS
+    struct sigaction sa;
+    sigset_t mask;
+#endif
     
 #ifndef KRB5_ATHENA_COMPAT
     if (encrypt_flag)
@@ -1579,14 +1646,13 @@
 	    UCB_RLOGIN);
     fflush(stderr);
     
-    host = strrchr(argv[0], '/');
-    if (host)
-      host++;
-    else
-      host = argv[0];
-    if (!strcmp(host, "rlogin"))
-      argv++;
+    argv[0] = "rlogin";
     
+#ifdef POSIX_SIGNALS
+    sigemptyset(&mask);
+    sigprocmask(SIG_SETMASK, &mask, NULL);
+#endif
+
     execv(UCB_RLOGIN, argv);
     perror("exec");
     exit(1);
@@ -1598,6 +1664,7 @@
 int nstored = 0;
 char *store_ptr = storage;
 
+#ifndef NOENCRYPTION
 #ifndef OLD_VERSION
 
 int des_read(fd, buf, len)
@@ -1891,6 +1958,7 @@
 }
 
 #endif /* OLD_VERSION */
+#endif /* NOENCRYPTION */
 #endif /* KERBEROS */
 
 
Index: appl/bsd/krlogind.c
diff -u krb5/appl/bsd/krlogind.c:1.1.1.4 krb5/appl/bsd/krlogind.c:1.9
@@ -213,6 +213,7 @@
 
 int non_privileged = 0; /* set when connection is seen to be from */
 			/* a non-privileged port */
+int retain_ccache = 0;
 
 AUTH_DAT	*v4_kdata;
 Key_schedule v4_schedule;
@@ -350,6 +351,9 @@
 		   error_message(status));
 	    exit(1);
     }
+
+    /* Blow away any KRB5CCNAME passed from inetd */
+    unsetenv("KRB5CCNAME");
 #endif
     
     /* Analyse parameters. */
@@ -862,7 +866,7 @@
     int on = 1;
 #endif
     
-#if defined(TIOCPKT) && !defined(__svr4__) || defined(solaris20)
+#if defined(TIOCPKT) && (!defined(__svr4__) && !defined(__sgi)) || defined(solaris20)
     /* if system has TIOCPKT, try to turn it on. Some drivers
      * may not support it. Save flag for later. 
      */
@@ -1001,7 +1005,7 @@
 {
     pty_cleanup (line, pid, 1);
     shutdown(netf, 2);
-    if (ccache)
+    if (ccache && ! retain_ccache)
 	krb5_cc_destroy(bsd_context, ccache);
     exit(1);
 }
@@ -1564,6 +1568,11 @@
 					  ticket, &ccache))) {
          fatal(netf, "Can't get forwarded credentials");
     }
+
+    krb5_appdefault_boolean(bsd_context, "rlogind",
+			   krb5_princ_realm(bsd_context, client),
+			   "retain_ccache", retain_ccache, &retain_ccache);
+
     return 0;
 }
 
Index: appl/bsd/krsh.c
diff -u krb5/appl/bsd/krsh.c:1.1.1.1 krb5/appl/bsd/krsh.c:1.4
@@ -95,6 +95,7 @@
 krb5_creds *cred;
 
 int	encrypt_flag = 0;
+int	encrypt_option_flag = -1;
 char	*krb_realm = (char *)0;
 void	try_normal();
 
@@ -105,6 +106,11 @@
 
 #endif /* KERBEROS */
 
+#ifdef NOENCRYPTION
+#define des_read read
+#define des_write write
+#endif /* NOENCRYPTION */
+
 #ifndef RLOGIN_PROGRAM
 #ifdef KERBEROS
 #define RLOGIN_PROGRAM KRB5_PATH_RLOGIN
@@ -143,6 +149,7 @@
     krb5_flags authopts;
     krb5_error_code status;
     int fflag = 0, Fflag = 0;
+    int no_forward = 0;
 #endif  /* KERBEROS */
     int debug_port = 0;
 
@@ -203,8 +210,18 @@
      * Ignore -x from kerberos rlogin
      */
     if (argc > 0 && !strncmp(*argv, "-x", 2)) {
+#ifdef NOENCRYPTION
+	fprintf(stderr, "rsh: encryption not supported\n");
+	goto usage;
+#else /* NOENCRYPTION */
+	argv++, argc--;
+	encrypt_option_flag = 1;
+	goto another;
+#endif /* NOENCRYPTION */
+    }
+    if (argc > 0 && !strncmp(*argv, "-X", 2)) {
 	argv++, argc--;
-	encrypt_flag++;
+	encrypt_option_flag = 0;
 	goto another;
     }
     if (argc > 0 && !strncmp(*argv, "-f", 2)) {
@@ -225,6 +242,11 @@
 	argv++, argc--;
 	goto another;
     }
+    if (argc > 0 && !strncmp(*argv, "-N", 2)) {
+	no_forward++;
+	argv++, argc--;
+	goto another;
+    }
     if (argc > 0 && !strncmp(*argv, "-A", 2)) {
 	argv++, argc--;
 	goto another;
@@ -295,6 +317,33 @@
 	fprintf(stderr, "who are you?\n");
 	exit(1);
     }
+#ifdef KERBEROS
+    status = krb5_init_context(&bsd_context);
+    if (status) {
+	    com_err(argv[0], status, "while initializing krb5");
+	    exit(1);
+    }
+
+    {
+	krb5_data realm;
+	int eflag;
+
+	if (krb_realm) {
+		realm.data = krb_realm;
+	} else {
+		krb5_get_default_realm(bsd_context, &realm.data);
+	}
+
+	krb5_appdefault_boolean(bsd_context, "rsh", &realm, "encrypt", 0,
+				&eflag);
+
+	encrypt_flag = encrypt_option_flag == -1 ? eflag : encrypt_option_flag;
+
+	if (! krb_realm)
+		krb5_xfree(realm.data);
+    }
+#endif
+
     cc = 0;
     for (ap = argv; *ap; ap++)
       cc += strlen(*ap) + 1;
@@ -333,13 +382,25 @@
     }
 
 #ifdef KERBEROS
-    status = krb5_init_context(&bsd_context);
-    if (status) {
-	    com_err(argv[0], status, "while initializing krb5");
-	    exit(1);
-    }
     authopts = AP_OPTS_MUTUAL_REQUIRED;
 
+    if (! (fflag || Fflag) && !no_forward) {
+	krb5_data realm;
+
+	if (krb_realm) {
+		realm.data = krb_realm;
+	} else {
+		krb5_get_default_realm(bsd_context, &realm.data);
+	}
+
+	krb5_appdefault_boolean(bsd_context, "rsh", &realm, "forward", 0,
+				&fflag);
+	krb5_appdefault_boolean(bsd_context, "rsh", &realm, "forwardable", 0,
+				&Fflag);
+	if (!krb_realm)
+		krb5_xfree(realm.data);
+    }
+
     /* Piggy-back forwarding flags on top of authopts; */
     /* they will be reset in kcmd */
     if (fflag || Fflag)
@@ -527,10 +588,17 @@
       (void) kill(pid, SIGKILL);
     exit(0);
   usage:
+#ifndef NOENCRYPTION
     fprintf(stderr,
 	    "usage: \trsh host [ -l login ] [ -n ] [ -x ] [ -f / -F] command\n");
     fprintf(stderr,
 	    "OR \trsh [ -l login ] [-n ] [ -x ] [ -f / -F ] host command\n");
+#else /* NOENCRYPTION */
+    fprintf(stderr,
+	    "usage: \trsh host [ -l login ] [ -n ] [ -f / -F] command\n");
+    fprintf(stderr,
+	    "OR \trsh [ -l login ] [-n ] [ -f / -F ] host command\n");
+#endif /* NOENCRYPTION */
     exit(1);
 }
 
@@ -559,15 +627,11 @@
      * from arglist.
      *
      * We always want to call the Berkeley rsh as 'host mumble'
+     *
+     * This is broken!  Always invoke it as "rsh ..."
      */
-    host = strrchr(argv[0], '/');
-    if (host)
-      host++;
-    else
-      host = argv[0];
-    
-    if (!strcmp(host, "rsh"))
-      argv++;
+
+    argv[0] = "rsh";
     
     fprintf(stderr,"trying normal rsh (%s)\n",
 	    UCB_RSH);
@@ -582,6 +646,7 @@
 int nstored = 0;
 char *store_ptr = storage;
 
+#ifndef NOENCRYPTION
 int des_read(fd, buf, len)
      int fd;
      register char *buf;
@@ -686,4 +751,5 @@
     }
     else return(len); 
 }
+#endif /* NOENCRYPTION */
 #endif /* KERBEROS */
Index: appl/bsd/krshd.c
diff -u krb5/appl/bsd/krshd.c:1.1.1.3 krb5/appl/bsd/krshd.c:1.6
@@ -106,6 +106,7 @@
 #include <pwd.h>
 #include <ctype.h>
 #include <string.h>
+#include <setjmp.h>
      
 #ifdef HAVE_SYS_LABEL_H
 /* only SunOS 4? */
@@ -174,6 +175,9 @@
 int require_encrypt = 0;
 int do_encrypt = 0;
 int anyport = 0;
+int retain_ccache = 0;
+int afs_retain_token = 0;
+int run_aklog = 0;
 char *kprogdir = KPROGDIR;
 int netf;
 
@@ -233,6 +237,72 @@
 }
 #endif
 
+typedef krb5_sigtype sigtype;
+
+#ifndef POSIX_SETJMP
+#undef sigjmp_buf
+#undef sigsetjmp
+#undef siglongjmp
+#define sigjmp_buf      jmp_buf
+#define sigsetjmp(j,s)  setjmp(j)
+#define siglongjmp      longjmp
+#endif
+
+#ifdef POSIX_SIGNALS
+typedef struct sigaction handler;
+#define handler_init(H,F)		(sigemptyset(&(H).sa_mask), \
+					 (H).sa_flags=0, \
+					 (H).sa_handler=(F))
+#define handler_swap(S,NEW,OLD)		sigaction(S, &NEW, &OLD)
+#define handler_set(S,OLD)		sigaction(S, &OLD, NULL)
+#else
+typedef sigtype (*handler)();
+#define handler_init(H,F)		((H) = (F))
+#define handler_swap(S,NEW,OLD)		((OLD) = signal ((S), (NEW)))
+#define handler_set(S,OLD)		(signal ((S), (OLD)))
+#endif
+
+#ifdef SETPAG
+extern setpag(), ktc_ForgetAllTokens();
+
+static int pagflag = 0;
+
+static sigjmp_buf setpag_buf;
+
+static sigtype sigsys()
+{
+	siglongjmp(setpag_buf, 1);
+}
+
+static int try_afscall(scall)
+	int (*scall)();
+{
+	handler sa, osa;
+	volatile int retval = 0;
+
+	(void) &retval;
+	handler_init(sa, sigsys);
+	handler_swap(SIGSYS, sa, osa);
+	if (sigsetjmp(setpag_buf, 1) == 0) {
+	    (*scall)();
+	    retval = 1;
+	}
+	handler_set(SIGSYS, osa);
+	return retval;
+}
+
+#define try_setpag()	try_afscall(setpag)
+#define try_unlog()	try_afscall(ktc_ForgetAllTokens)
+#endif /* SETPAG */
+
+static void
+afs_cleanup()
+{
+#ifdef SETPAG
+    if (pagflag)
+	try_unlog();
+#endif /* SETPAG */
+}
 
 int main(argc, argv)
      int argc;
@@ -277,6 +347,9 @@
 		   error_message(status));
 	    exit(1);
     }
+
+    /* Blow away any KRB5CCNAME passed from inetd */
+    unsetenv("KRB5CCNAME");
 #endif
     
     /* Analyze parameters. */
@@ -533,6 +606,7 @@
     syslog(LOG_INFO ,"Daemon terminated via signal %d.", signumber);
     if (ccache)
 	krb5_cc_destroy(bsd_context, ccache);
+    afs_cleanup();
     exit(0);
 }
 
@@ -1116,7 +1190,17 @@
 #endif
       }
 #endif
-    
+
+#ifdef IRIX_PROJECT_INIT
+    /*
+     * Initialize the magical IRIX array session, and the
+     * default project id.
+     */
+	
+    newarraysess();
+    setprid(getdfltprojuser(username));
+#endif /* IRIX_PROJECT_INIT */
+  
     (void) write(2, "", 1);
     
     if (port||do_encrypt) {
@@ -1261,8 +1345,10 @@
 #endif
 	    /* Finish session in wmtp */
 	    pty_logwtmp(ttyn,"","");
-	    if (ccache)
+	    if (ccache && ! retain_ccache)
 		krb5_cc_destroy(bsd_context, ccache);
+	    if (! afs_retain_token)
+		afs_cleanup();
 	    exit(0);
 	}
 #if defined(HAVE_SETSID)&&(!defined(ULTRIX))
@@ -1304,15 +1390,20 @@
       pwd->pw_shell = "/bin/sh";
     (void) close(f);
     (void) setgid((gid_t)pwd->pw_gid);
-#ifndef sgi
+/* #ifndef sgi */
     if (getuid() == 0 || getuid() != pwd->pw_uid) {
         /* For testing purposes, we don't call initgroups if we
            already have the right uid, and it is not root.  This is
            because on some systems initgroups outputs an error message
            if not called by root.  */
         initgroups(pwd->pw_name, pwd->pw_gid);
-    }
+#ifdef KERBEROS
+#ifdef SETPAG
+	    pagflag = try_setpag();
+#endif
 #endif
+    }
+/* #endif */
     (void) setuid((uid_t)pwd->pw_uid);
     /* if TZ is set in the parent, drag it in */
     {
@@ -1387,6 +1478,32 @@
     environ = envinit;
     
 #ifdef KERBEROS
+
+    /*
+     * Since we have to run aklog as the user, _not_ root, we need to run
+     * it now (if we're supposed to.  Do The Right Thing if run_aklog is
+     * set
+     */
+    if (run_aklog) {
+	char *aklog_path;
+	struct stat st;
+
+	krb5_appdefault_string(bsd_context, "rshd",
+			       krb5_princ_realm(bsd_context, client),
+			       "krb5_aklog_path", KPROGDIR "/aklog",
+			       &aklog_path);
+		
+	/*
+	 * Make sure it exists before we try to run it
+	 */
+		
+	if (stat (aklog_path, &st) == 0) {
+	    system(aklog_path);
+	}
+
+	free(aklog_path);
+    }
+
     /* To make Kerberos rcp work correctly, we must ensure that we
        invoke Kerberos rcp on this end, not normal rcp, even if the
        shell startup files change PATH.  */
@@ -1441,6 +1558,7 @@
   signout_please:
     if (ccache)
 	krb5_cc_destroy(bsd_context, ccache);
+    afs_cleanup();
     ccache = NULL;
     pty_logwtmp(ttyn,"","");
     exit(1);
@@ -1895,6 +2013,25 @@
 		  error_message(errno));
 	    exit(1);
 	}
+	/*
+	 * Check our appdefaults profile entry to see if we're supposed to
+	 * run aklog.  If so, then just set "run_aklog" for later; we
+	 * need to run aklog as the user, not as root
+	 */
+	
+	krb5_appdefault_boolean(bsd_context, "rshd",
+				krb5_princ_realm(bsd_context, client),
+				"krb5_run_aklog", 0, &run_aklog);
+	
+	krb5_appdefault_boolean(bsd_context, "rshd",
+				krb5_princ_realm(bsd_context, client),
+				"retain_ccache", retain_ccache,
+				&retain_ccache);
+	
+	krb5_appdefault_boolean(bsd_context, "rshd",
+				krb5_princ_realm(bsd_context, client),
+				"afs_retain_token", afs_retain_token,
+				&afs_retain_token);
     }
     krb5_free_ticket(bsd_context, ticket);
     return 0;
Index: appl/bsd/login.c
diff -u krb5/appl/bsd/login.c:1.1.1.2 krb5/appl/bsd/login.c:1.8
@@ -39,15 +39,35 @@
    # use password to get v4 tickets
    krb4_convert = 1
    # use kerberos conversion daemon to get v4 tickets
-   krb_run_aklog = 1
+   krb4_run_aklog = 1
    # attempt to run aklog
    aklog_path = $(prefix)/bin/aklog
-   # where to find it [not yet implemented]
+   # where to find it
    accept_passwd = 0
    # don't accept plaintext passwords [not yet implemented]
+   forwardable = 0
+   # The initial TGT is forwardable
+   krb5_run_aklog = 0
+   # Run a Kerberos 5 aklog (doesn't need Kerberos 4 credentials)
+   krb5_aklog_path = $(prefix)/bin/aklog
+   # Path to Kerberos 5 aklog
+   default_lifetime = (null)
+   # Default ticket lifetime (10 hours)
+   retain_ccache = 0
+   # Don't destroy the credential cache upon logout
+   afs_retain_token = 0
+   # Don't destroy AFS tokens upon logout
+   check_quota = 1
+   # Run "quota" to check the user's disk quota
 */
 #define KRB5_GET_TICKETS
 int login_krb5_get_tickets = 1;
+int login_krb5_forwardable_tgt = 0;
+int login_krb5_run_aklog = 0;
+int login_krb5_retain_ccache = 0;
+char *login_krb5_aklog_path = 0;
+char *login_krb5_default_lifetime = 0;
+int login_afs_retain_token = 0;
 #ifdef KRB5_KRB4_COMPAT
 #define KRB4_GET_TICKETS
 int login_krb4_get_tickets = 0;
@@ -57,6 +77,7 @@
 int login_krb_run_aklog = 0;
 #endif /* KRB5_KRB4_COMPAT */
 int login_accept_passwd = 0;
+int login_check_quota = 1;
 
 /*
  * login [ name ]
@@ -113,6 +134,13 @@
 #define NO_INIT_CC
 #endif
 
+#ifdef sun
+/* Under solaris: gcc defines __svr4__, cc doesn't define bsd */
+#if defined(__svr4__) || !defined(bsd)
+#define solaris
+#endif /* __svr4 || !bsd */
+#endif /* sun */
+
 #include <errno.h>
 #ifdef HAVE_TTYENT_H
 #include <ttyent.h>
@@ -230,6 +258,10 @@
 #define TAB3 0
 #endif
 
+#ifdef solaris
+#include <dirent.h>
+#endif /* solaris */
+
 #define	TTYGRPNAME	"tty"		/* name of group to own ttys */
 
 #define	MOTDFILE	"/etc/motd"
@@ -281,7 +313,7 @@
 					   passsword */
 #endif
 
-#ifdef __SVR4
+#if defined(__SVR4) || defined(sgi) || defined(__svr4__) || defined(__hpux)
 #define NO_MOTD
 #define NO_MAILCHECK
 #endif
@@ -322,6 +354,11 @@
 	"krb4_convert", &login_krb4_convert,
 	"krb4_run_aklog", &login_krb_run_aklog,
 #endif /* KRB5_KRB4_COMPAT */
+	"forwardable", &login_krb5_forwardable_tgt,
+	"krb5_run_aklog", &login_krb5_run_aklog,
+	"retain_ccache", &login_krb5_retain_ccache,
+	"afs_retain_token", &login_afs_retain_token,
+	"check_quota", &login_check_quota,
 };
 static char *conf_yes[] = {
 	"y", "yes", "true", "t", "1", "on",
@@ -331,6 +368,14 @@
 	"n", "no", "false", "nil", "0", "off",
 	0
 };
+
+static struct login_conf_strings {
+	char *confname;
+	char **varname;
+} login_string_set[] = {
+	"krb5_aklog_path",	&login_krb5_aklog_path,
+	"default_lifetime",	&login_krb5_default_lifetime,
+};
 /* 1 = true, 0 = false, -1 = ambiguous */
 static int conf_affirmative(s)
 	char *s;
@@ -363,36 +408,31 @@
 	krb5_context k;
 {
 	int i, max_i;
-	const char* kconf_names[3];
-	char **kconf_val;
 	int retval;
+	krb5_data realm;
+
+	krb5_get_default_realm(k, &realm.data);
 
 	max_i = sizeof(login_conf_set)/sizeof(struct login_confs);
 	for (i = 0; i<max_i; i++) {
-		kconf_names[0] = "login";
-		kconf_names[1] = login_conf_set[i].flagname;
-		kconf_names[2] = 0;
-		retval = profile_get_values(k->profile, 
-					    kconf_names, &kconf_val);
-		if (retval) {
-		  /* ignore most (all?) errors */
-		} else if (kconf_val) {
-			switch(conf_affirmative(*kconf_val)) {
-			case 1:
-				*login_conf_set[i].flag = 1;
-				break;
-			case 0:
-				*login_conf_set[i].flag = 0;
-				break;
-			default:
-			case -1:
-				com_err("login/kconf", 0,
-					"invalid flag value %s for flag %s",
-					*kconf_val, kconf_names[1]);
-				break;
-			}
+		krb5_appdefault_boolean(k, "login", &realm,
+					login_conf_set[i].flagname,
+					*login_conf_set[i].flag,
+					login_conf_set[i].flag);
+	}
+
+	max_i = sizeof(login_string_set) / sizeof(struct login_conf_strings);
+	for (i = 0; i < max_i; i++) {
+		krb5_appdefault_string(k, "login", &realm,
+				       login_string_set[i].confname,
+				       "", login_string_set[i].varname);
+		if (!login_string_set[i].varname[0]) {
+			free(login_string_set[i].varname);
+			login_string_set[i].varname = NULL;
 		}
 	}
+
+	free(realm.data);
 }
 #endif /* KRB5_GET_TICKETS */
 
@@ -520,6 +560,13 @@
     sprintf(prompt,"Password for %s: ", username);
 
     /* reduce opportunities to be swapped out */
+#ifdef sgi
+    /*
+     * A bug on IRIX will occasionally eat the first character.  Write
+     * a NUl to fix this
+     */
+    putchar('\0');
+#endif
     code = krb5_read_password(kcontext, prompt, 0, user_pwstring, &pwsize);
     if (code || pwsize == 0) {
 	fprintf(stderr, "Error while reading password for '%s'\n", username);
@@ -592,11 +639,25 @@
 		"while getting time of day");
 	goto nuke_ccache;
     }
+
+    /*
+     * Use the lifetime from the profile if we were given one
+     */
+
+    if (login_krb5_default_lifetime && *login_krb5_default_lifetime) {
+       krb5_deltat tmplife;
+       if (! krb5_string_to_deltat(login_krb5_default_lifetime, &tmplife))
+	   lifetime = tmplife;
+    }
+
     my_creds.times.starttime = 0; /* start timer when 
 				     request gets to KDC */
     my_creds.times.endtime = now + lifetime;
     my_creds.times.renew_till = 0;
 
+    if (login_krb5_forwardable_tgt)
+	krb5_options |= KDC_OPT_FORWARDABLE;
+
     code = krb5_get_in_tkt_with_password(kcontext, krb5_options,
 					 0, NULL, 0 /*preauth*/,
 					 pass,
@@ -887,7 +948,9 @@
        says it is something about the starttime of the ticket and
        "now" being equal.  He thinks it is fixed, but isn't sure.
        */
+#if 0
     sleep(2);
+#endif
 
     /* get the server principal for the local host */
     /* (use defaults of "host" and canonicalized local name) */
@@ -1047,18 +1110,40 @@
 #define try_unlog()	try_afscall(ktc_ForgetAllTokens)
 #endif /* SETPAG */
 
+/*
+ * Since we have to allocate a PAG _before_ we fork, we need to move
+ * this into a separate function.
+ */
+
 void
-afs_login ()
+krb_afs_setpag()
 {
-#ifdef KRB4_GET_TICKETS
+	/* Allocating a PAG isn't that harmful ... */
 #ifdef SETPAG
-    if (login_krb4_get_tickets && pwd->pw_uid) {
+    if ( (
+#ifdef KRB4_GET_TICKETS
+	login_krb4_get_tickets
+#else /* KRB4_GET_TICKETS */
+	1
+#endif
+	||
+#ifdef KRB5_GET_TICKETS
+	login_krb5_get_tickets
+#else
+	1
+#endif /* KRB5_GET_TICKETS */
+	) && pwd->pw_uid) {
 	/* Only reset the pag for non-root users. */
 	/* This allows root to become anything. */
 	pagflag = try_setpag ();
     }
-#endif
-#endif /* KRB4_GET_TICKETS */
+#endif /* SETPAG */
+}
+
+void
+krb_afs_login (me)
+	krb5_principal me;
+{
 #ifdef KRB_RUN_AKLOG
     if (got_v4_tickets && login_krb_run_aklog) {
 	/* KPROGDIR is $(prefix)/bin */
@@ -1072,12 +1157,41 @@
 	if (stat (aklog_path, &st) == 0) {
 	    system(aklog_path);
 	}
-    }
+    } else
 #endif /* KRB_RUN_AKLOG */
+#ifdef KRB5_GET_TICKETS
+    /*
+     * Note that we check to see if we have valid credentials already
+     * in place here (because we might have forwarded them)
+     */
+    if (login_krb5_run_aklog && (got_v5_tickets || have_v5_tickets(me))) {
+	/*
+	 * Check the profile for a path to aklog, otherwise use the
+	 * default of KPROGDIR
+	 */
+	char aklog_path[MAXPATHLEN];
+	struct stat st;
+
+	if (login_krb5_aklog_path && *login_krb5_aklog_path) {
+		strcpy(aklog_path, login_krb5_aklog_path);
+	} else {
+		strcpy(aklog_path, KPROGDIR);
+		strcat(aklog_path, "/aklog");
+	}
+	/*
+	 * Make sure it's there
+	 */
+	if (stat (aklog_path, &st) == 0) {
+	    system(aklog_path);
+	}
+    }
+#else
+	{ }
+#endif /* KRB5_GET_TICKETS */
 }
 
 void
-afs_cleanup ()
+krb_afs_cleanup ()
 {
 #ifdef SETPAG
     if (pagflag)
@@ -1203,13 +1317,14 @@
 	 * -k is used by klogind to cause the Kerberos V4 autologin protocol;
 	 * -K is used by klogind to cause the Kerberos V4 autologin
 	 *    protocol with restricted access.
+	 * -d is used by Solaris to signal the device used; we ignore it.
 	 */
 	(void)gethostname(tbuf, sizeof(tbuf));
 	domain = strchr(tbuf, '.');
 
 	 fflag = hflag = pflag = rflag = kflag = Kflag = eflag = 0;
 	passwd_req = 1;
-	while ((ch = getopt(argc, argv, "Ffeh:pr:k:K:")) != EOF)
+	while ((ch = getopt(argc, argv, "Ffeh:pr:k:K:d:")) != EOF)
 		switch (ch) {
 		case 'f':
 			EXCL_AUTH_TEST;
@@ -1292,6 +1407,8 @@
 			eflag = 1;
 			passwd_req = 0;
 			break;
+		case 'd':
+			break;
 		case '?':
 		default:
 			fprintf(stderr, "usage: login [-fp] [username]\n");
@@ -1362,7 +1479,6 @@
 	   try and get v4, v5 tickets with it
 	   try and use the tickets against the local srvtab
 	   if the password matches, always let them in
-	   if the ticket decrypts, let them in.
 	   v5 needs to work, does v4?
 	   */
 
@@ -1491,7 +1607,7 @@
 		    break;
 #endif /* OLD_PASSWD */
 		printf("Login incorrect\n");
-		if (++cnt >= 5) {
+		if (++cnt >= 2) {
 			log_repeated_failures (tty, hostname);
 /* irix has no tichpcl */
 #ifdef TIOCHPCL
@@ -1542,14 +1658,6 @@
 		sleepexit(0);
 	}
 #endif
-	if (chdir(pwd->pw_dir) < 0) {
-		printf("No directory %s!\n", pwd->pw_dir);
-		if (chdir("/"))
-			exit(0);
-		pwd->pw_dir = "/";
-		printf("Logging in with home = \"/\".\n");
-	}
-
 	/* nothing else left to fail -- really log in */
 	{
 		struct utmp utmp;
@@ -1568,6 +1676,11 @@
 		(void)ioctl(0, TIOCSWINSZ, (char *)&win);
 	}
 
+#if defined(sun)
+	/* Set owner/group/permissions of framebuffer devices */
+	(void) set_fb_attrs(ttyn, pwd->pw_uid, pwd->pw_gid);
+#endif
+
 	(void)chown(ttyn, pwd->pw_uid,
 	    (gr = getgrnam(TTYGRPNAME)) ? gr->gr_gid : pwd->pw_gid);
 
@@ -1590,11 +1703,13 @@
 
 #if defined(KRB5_GET_TICKETS) || defined(KRB4_GET_TICKETS)
 #if defined(KRB5_GET_TICKETS) && defined(KRB4_GET_TICKETS)
-	if (login_krb4_get_tickets || login_krb5_get_tickets) {
+	if ((login_krb4_get_tickets || login_krb5_get_tickets) &&
+	    (login_krb5_retain_ccache == 0 || login_afs_retain_token == 0)) {
 #elif defined(KRB4_GET_TICKETS)
 	if (login_krb4_get_tickets) {
 #else
-	if (login_krb5_get_tickets) {
+	if (login_krb5_get_tickets &&
+	    (login_krb5_retain_ccache == 0 || login_afs_retain_token == 0)) {
 #endif
 	    /* Fork so that we can call kdestroy */
 	    dofork();
@@ -1613,12 +1728,39 @@
 
 	   /* this will set the PGID to the PID. */
 #ifdef HAVE_SETPGID
-	   if (setpgid(p,p) < 0) perror("login.krb5: setpgid");
+	   if (setpgid(p,p) < 0) {
+		/*
+		 * Ignore errors if we didn't fork, since we're probably
+		 * already a session leader
+		 */
+
+		if ((login_krb5_retain_ccache == 0) ||
+		    (login_afs_retain_token == 0))
+			perror("login.krb5: setpgid");
+	    }
 #else
 #ifdef SETPGRP_TWOARG
-	   if (setpgrp(p,p) < 0) perror("login.krb5: setpgrp");
+	   if (setpgrp(p,p) < 0) {
+		/*
+		 * Ignore errors if we didn't fork, since we're probably
+		 * already a session leader
+		 */
+		
+		if ((login_krb5_retain_ccache == 0) ||
+		    (login_afs_retain_token == 0))
+			perror("login.krb5: setpgrp");
+	   }
 #else
-	   if (setpgrp() < 0) perror("login.krb5: setpgrp");
+	   if (setpgrp() < 0) {
+		/*
+		 * Ignore errors if we didn't fork, since we're probably
+		 * already a session leader
+		 */
+		 
+		if ((login_krb5_retain_ccache == 0) ||
+		    (login_afs_retain_token == 0))
+			perror("login.krb5: setpgrp");
+	   }
 #endif
 #endif
 
@@ -1652,6 +1794,18 @@
 	(void)setgid((gid_t) pwd->pw_gid);
 	(void) initgroups(username, pwd->pw_gid);
 
+#ifdef IRIX_PROJECT_INIT
+	/*
+	 * Initialize the magical IRIX array session, and the
+	 * default project id.
+	 */
+	
+	newarraysess();
+	setprid(getdfltprojuser(username));
+#endif /* IRIX_PROJECT_INIT */
+
+	krb_afs_setpag();
+
 	/*
 	 * The V5 ccache and V4 ticket file are both created as root.
 	 * They need to be owned by the user, and chown (a) assumes
@@ -1841,7 +1995,24 @@
 	if (ccname)
 		setenv("KRB5CCNAME", ccname, 1);
 
+	krb_afs_login (me);
+
+	if (chdir(pwd->pw_dir) < 0) {
+		printf("No directory %s!\n", pwd->pw_dir);
+		if (chdir("/")) {
+			printf("cannot chdir to /!\n");
+			sleepexit(1);
+		}
+		pwd->pw_dir = "/";
+		printf("Logging in with home = \"/\".\n");
+	}
+
 	setenv("HOME", pwd->pw_dir, 1);
+#ifdef LPATH_root
+	if (pwd->pw_uid == (uid_t) 0)
+	    setenv("PATH", LPATH_root, 1);
+	else
+#endif
 	setenv("PATH", LPATH, 1);
 	setenv("USER", pwd->pw_name, 1);
 	setenv("SHELL", pwd->pw_shell, 1);
@@ -1906,8 +2077,12 @@
 #endif /* KRB4_KLOGIN */
 		else
 			syslog(LOG_NOTICE, "ROOT LOGIN %s", tty);
-
-	afs_login ();
+	else
+		if (hostname)
+			syslog(LOG_INFO, "%s login on %s from %s",
+			       pwd->pw_name, tty, hostname);
+		else
+			syslog(LOG_INFO, "%s login on %s", pwd->pw_name, tty);
 
 	if (!quietlog) {
 #ifdef KRB4_KLOGIN
@@ -1919,7 +2094,8 @@
 	}
 
 #ifndef OQUOTA
-	if (! access( QUOTAWARN, X_OK)) (void) system(QUOTAWARN);
+	if (login_check_quota && ! access( QUOTAWARN, X_OK))
+	    (void) system(QUOTAWARN);
 #endif
 	handler_init (sa, SIG_DFL);
 	handler_set (SIGALRM, sa);
@@ -2086,8 +2262,37 @@
 	register int ch;
 	register char *p;
 	static char nbuf[UT_NAMESIZE + 1];
+#ifdef solaris
+	char *ttyprompt = NULL;
+	static int firsttime = 1;
+#endif
 
+#ifdef sgi
+	/*
+	 * Seems to be a race condition in Irix that sometimes eats the
+	 * first character.  Write a null byte to fix this.
+	 */
+
+	putchar('\0');
+#endif
 	for (;;) {
+#ifdef solaris
+		/*
+		 * getty prints 'login:' for us, so we want to avoid printing
+		 * it again. getty also sets the environment variable TTYPROMPT
+		 * so if it is present, don't print the login prompt.
+		 *
+		 * However, we only want to do this the first time through.
+		 */
+		ttyprompt = getenv("TTYPROMPT");
+		
+		if ((ttyprompt) && (*ttyprompt != '\0')) {
+			if (! firsttime)
+				printf("%s", ttyprompt);
+			else
+				firsttime = 0;
+		} else
+#endif /* solaris */
 		printf("login: ");
 		for (p = nbuf; (ch = getchar()) != '\n'; ) {
 			if (ch == EOF)
@@ -2445,8 +2650,11 @@
     
     /* Cleanup stuff */
     /* Run destroy_tickets to destroy tickets */
-    (void) destroy_tickets();		/* If this fails, we lose quietly */
-    afs_cleanup ();
+    if (! login_krb5_retain_ccache)
+        (void) destroy_tickets();	/* If this fails, we lose quietly */
+
+    if (! login_afs_retain_token)
+	krb_afs_cleanup();
 #ifdef _IBMR2
     update_ref_count(-1);
 #endif
@@ -2507,3 +2715,135 @@
     enduserdb();
 }
 #endif
+
+#if defined(sun)
+/*
+ * set_fb_attrs -- change owner/group/permissions of framebuffers
+ *		   listed in /etc/fbtab.
+ *
+ * Note:
+ * Exiting from set_fb_attrs upon error is not advisable
+ * since it would disable logins on console devices.
+ *
+ * File format:
+ * console mode device_name[:device_name ...]
+ * # begins a comment and may appear anywhere on a line.
+ *
+ * Example:
+ * /dev/console 0660 /dev/fb:/dev/cgtwo0:/dev/bwtwo0
+ * /dev/console 0660 /dev/gpone0a:/dev/gpone0b
+ *
+ * Description:
+ * The example above sets the owner/group/permissions of the listed
+ * devices to uid/gid/0660 if ttyn is /dev/console
+ */
+
+#define	FIELD_DELIMS 	" \t\n"
+#define	COLON 		":"
+#define COLON_C         ':'
+#define WILDCARD        "/*"
+#define WILDCARD_LEN    2
+#define MAX_LINELEN     256
+#ifdef solaris
+#define FBTAB           "/etc/logindevperm"
+#else /* solaris */
+#define FBTAB           "/etc/fbtab"
+#endif /* solaris */
+
+
+set_fb_attrs(ttyn, uid, gid)
+	char *ttyn;
+	int uid;
+	int gid;
+{
+	char line[MAX_LINELEN];
+	char *console;
+	char *mode_str;
+	char *dev_list;
+	char *device;
+	char *ptr;
+	int  mode;
+	long strtol();
+	FILE *fp;
+
+	if ((fp = fopen(FBTAB, "r")) == NULL)
+		return;
+	while (fgets(line, MAX_LINELEN, fp)) {
+		if (ptr = strchr(line, '#'))
+			*ptr = '\0';	/* handle comments */
+		if ((console = strtok(line, FIELD_DELIMS)) == NULL)
+			continue;	/* ignore blank lines */
+		if (strcmp(console, ttyn) != 0)
+			continue;	/* ignore non-consoles */
+		mode_str = strtok((char *)NULL, FIELD_DELIMS);
+		if (mode_str == NULL) {
+			(void) fprintf(stderr, "%s: invalid entry -- %s\n",
+				FBTAB, line);
+			continue;
+		}
+		/* convert string to octal value */
+		mode = (int) strtol(mode_str, (char **)NULL, 8);
+		if (mode < 0 || mode > 0777) {
+			(void) fprintf(stderr, "%s: invalid mode -- %s\n",
+				FBTAB, mode_str);
+			continue;
+		}
+		dev_list = strtok((char *)NULL, FIELD_DELIMS);
+		if (dev_list == NULL) {
+			(void) fprintf(stderr, "%s: %s -- empty device list\n",
+				FBTAB, console);
+			continue;
+		}
+#ifdef solaris
+		device = strtok(dev_list, COLON);
+		while (device) {
+		    ptr = strstr(device, WILDCARD);
+		    if (ptr && 
+			(strlen(device) - (ptr - &device[0])) == WILDCARD_LEN){
+			/* The device was a (legally-specified) directory. */
+			DIR           *dev_dir;
+			struct dirent *dir_e;
+			char dev_file[MAXPATHLEN];
+			
+			*ptr = '\0'; /* Remove the wildcard from the dir name. */
+
+			if ((dev_dir = opendir(device)) == (DIR *) NULL) {
+			    syslog(LOG_ERR, "bad device %s%s in %s, ignored",
+				   device, WILDCARD, FBTAB);
+			    continue;
+			}
+			
+			/* Directory is open; alter its files. */
+			/* Must link with /usr/lib/libc.a before 
+			   /usr/ucblib/libucb.a or the d_name structs
+			   miss the first two characters of the filename */
+			while (dir_e = readdir(dev_dir)) {
+			    if (strcmp(dir_e->d_name, "..") &&
+				strcmp(dir_e->d_name, ".")) {
+				strcpy(dev_file, device);
+				strcat(dev_file, "/");
+				strcat(dev_file, dir_e->d_name);
+
+				(void) chown(dev_file, uid, gid);
+				(void) chmod(dev_file, mode);
+			    }
+			}
+			(void) closedir(dev_dir);
+		    } else {
+			/* 'device' was not a directory, so we can just do it. */
+			(void) chown(device, uid, gid);
+			(void) chmod(device, mode);
+		    }
+		    device = strtok((char *)NULL, COLON); /* Move thru list. */
+#else /* solaris */
+		device = strtok(dev_list, COLON);
+		while (device) {
+			(void) chown(device, uid, gid);
+			(void) chmod(device, mode);
+			device = strtok((char *)NULL, COLON);
+#endif /* solaris */
+		}
+	}
+	(void) fclose(fp);
+}
+#endif /* sun */
Index: appl/bsd/loginpaths.h
diff -u krb5/appl/bsd/loginpaths.h:1.1.1.1 krb5/appl/bsd/loginpaths.h:1.2
@@ -45,8 +45,15 @@
 #endif
 
 #ifdef sgi
+#ifdef HAVE_PATHS_H
+#include <paths.h>
+#define LPATH _PATH_USERPATH
+#define RPATH _PATH_USERPATH
+#define LPATH_root _PATH_ROOTPATH
+#else
 #define LPATH "/usr/sbin:/usr/bsd:/usr/bin:/bin:/usr/bin/X11"
 #define RPATH "/usr/sbin:/usr/bsd:/usr/bin:/bin:/usr/bin/X11"
+#endif
 #endif
 
 #ifdef linux
Index: appl/bsd/rcp.M
diff -u krb5/appl/bsd/rcp.M:1.1.1.1 krb5/appl/bsd/rcp.M:1.2
@@ -23,12 +23,12 @@
 .SH SYNOPSIS
 .B rcp
 [\fB\-p\fP] [\fB\-x\fP] [\fB\-k\fP \fIrealm\fP ] [\fB\-D\fP \fIport\fP]
-[\fB\-N\fP]
+[\fB\-n\fP]
 .I file1 file2
 .sp
 .B rcp
 [\fB\-p\fB] [\fB\-x\fP] [\fP\-k\fP \fIrealm\fP] [\fB\-r\fP] [\fB\-D\fP
-\fIport\fP] [\fB\-N\fP]
+\fIport\fP] [\fB\-n\fP]
 .I file ... directory
 .SH DESCRIPTION
 .B Rcp
@@ -98,7 +98,7 @@
 .I port
 on the remote machine.  
 .TP
-.B \-N
+.B \-n
 use a network connection, even when copying files on the local machine
 (used for testing purposes).
 .PP
Index: appl/gssftp/ftp/Makefile.in
diff -u krb5/appl/gssftp/ftp/Makefile.in:1.1.1.1 krb5/appl/gssftp/ftp/Makefile.in:1.2
@@ -1,7 +1,7 @@
 #
 # appl/gssftp/ftp/Makefile.in
 #
-CFLAGS = -DGSSAPI -DFTP_BUFSIZ=10240 $(CCOPTS) $(DEFS) $(LOCALINCLUDE)
+CFLAGS = -DGSSAPI -DKERBEROS5 -DFTP_BUFSIZ=10240 $(CCOPTS) $(DEFS) $(LOCALINCLUDE)
 
 COMERRLIB=$(BUILDTOP)/util/et/libcom_err.a
 
Index: appl/gssftp/ftp/cmds.c
diff -u krb5/appl/gssftp/ftp/cmds.c:1.1.1.1 krb5/appl/gssftp/ftp/cmds.c:1.2
@@ -39,6 +39,7 @@
  * FTP User Program -- Command Routines.
  */
 #include <sys/param.h>
+#include <sys/types.h>
 #include <sys/wait.h>
 #include <sys/stat.h>
 #include <sys/socket.h>
Index: appl/gssftp/ftp/configure.in
diff -u krb5/appl/gssftp/ftp/configure.in:1.1.1.1 krb5/appl/gssftp/ftp/configure.in:1.2
@@ -16,6 +16,14 @@
 AC_CHECK_HEADERS(sys/select.h)
 AC_HEADER_CHECK(termios.h,AC_FUNC_CHECK(cfsetispeed,AC_DEFINE(POSIX_TERMIOS)))
 AC_CHECK_HEADERS(stdlib.h)
+dnl
+dnl Do we want to exclude session encryption?
+do_encrypt=yes
+AC_ARG_WITH([session-encrypt],[],do_encrypt=$withval)
+if test $do_encrypt = no; then
+	AC_DEFINE(NOENCRYPTION)
+fi
+dnl
 KRB5_LIBRARIES
 V5_USE_SHARED_LIB
 V5_AC_OUTPUT_MAKEFILE
Index: appl/gssftp/ftp/ftp.c
diff -u krb5/appl/gssftp/ftp/ftp.c:1.1.1.1 krb5/appl/gssftp/ftp/ftp.c:1.3
@@ -1913,6 +1913,7 @@
 	  char stbuf[FTP_BUFSIZ];
 	  char **service_name, **end_service_name;
 	  int comcode;
+	  int noisyflag = 0;
 	  struct gss_channel_bindings_struct chan;
 	  chan.initiator_addrtype = GSS_C_AF_INET; /* OM_uint32  */ 
 	  chan.initiator_address.length = 4;
@@ -1934,6 +1935,7 @@
 	    
 	  
 	  for (service_name = gss_services; *service_name; service_name++) {
+	    noisyflag = debug || (service_name == end_service_name);
 	    
 	    /* ftp@hostname first, the host@hostname */
 	    /* the V5 GSSAPI binding canonicalizes this for us... */
@@ -1964,7 +1966,8 @@
 				     &gcontext,
 				     target_name,
 				     GSS_C_NULL_OID,
-				     GSS_C_MUTUAL_FLAG | GSS_C_REPLAY_FLAG,
+				     GSS_C_MUTUAL_FLAG | GSS_C_REPLAY_FLAG |
+				     (forward ? GSS_C_DELEG_FLAG : 0),
 				     0,
 				     &chan,	/* channel bindings */
 				     token_ptr,
@@ -1975,7 +1978,8 @@
 	      
 
 	      if (maj_stat!=GSS_S_COMPLETE && maj_stat!=GSS_S_CONTINUE_NEEDED){
-		user_gss_error(maj_stat, min_stat, "initializing context");
+		if (!(maj_stat == GSS_S_FAILURE) || noisyflag)
+		  user_gss_error(maj_stat, min_stat, "initializing context");
 		(void) gss_release_name(&min_stat, &target_name);
 		/* could just be that we missed on the service name */
 		goto outer_loop;
Index: appl/gssftp/ftp/ftp_var.h
diff -u krb5/appl/gssftp/ftp/ftp_var.h:1.1.1.1 krb5/appl/gssftp/ftp/ftp_var.h:1.2
@@ -103,6 +103,10 @@
 
 extern int	options;	/* used during socket creation */
 
+#ifdef KERBEROS5
+extern int	forward;	/* Should we forward credentials? */
+#endif
+
 /*
  * Format of command table.
  */
Index: appl/gssftp/ftp/main.c
diff -u krb5/appl/gssftp/ftp/main.c:1.1.1.1 krb5/appl/gssftp/ftp/main.c:1.3
@@ -46,9 +46,9 @@
  */
 #include <stdio.h>
 #include "ftp_var.h"
+#include <sys/types.h>
 #include <sys/socket.h>
 #include <sys/ioctl.h>
-#include <sys/types.h>
 
 #include <arpa/ftp.h>
 
@@ -73,6 +73,11 @@
 extern char realm[];
 #endif /* KERBEROS */
 
+#ifdef KERBEROS5
+#include <krb5.h>
+#include <com_err.h>
+#endif
+
 main(argc, argv)
 	char *argv[];
 {
@@ -80,6 +85,12 @@
 	int top;
 	struct passwd *pw = NULL;
 	char homedir[MAXPATHLEN];
+#ifdef KERBEROS5
+	krb5_context context;
+	krb5_ccache ccache;
+	krb5_error_code code = 0;
+	krb5_principal princ = NULL;
+#endif
 
 	sp = getservbyname("ftp", "tcp");
 	if (sp == 0) {
@@ -92,6 +103,33 @@
 	memcpy(&staticsp,sp,sizeof(struct servent));
 	sp = &staticsp;
 #endif /* KERBEROS */
+
+#ifdef KERBEROS5
+	krb5_init_context(&context);
+	krb5_init_ets(context);
+
+	/*
+	 * Forward credentials if we get a command-line flag or if we
+	 * have the right stuff set in the profile, _AND_ if our TGT
+	 * is forwardable
+	 */
+
+	if ((code = krb5_cc_default(context, &ccache)) != 0) {
+		com_err(argv[0], code, "while reading credential cache");
+	}
+
+	if ((code == 0) && 
+	    (code = krb5_cc_get_principal(context, ccache, &princ)) != 0) {
+		com_err(argv[0], code, "while getting primary principal");
+	}
+
+	if (code == 0) {
+		krb5_appdefault_boolean(context, "ftp",
+					krb5_princ_realm(context, princ),
+					"forward", 0, &forward);
+	}
+#endif /* KERBEROS5 */
+
 	doglob = 1;
 	interactive = 1;
 	autologin = 1;
@@ -137,6 +175,15 @@
 			case 'g':
 				doglob = 0;
 				break;
+#ifdef KERBEROS5
+			case 'f':
+				forward = 1;
+				break;
+			
+			case 'F':
+				forward = 0;
+				break;
+#endif /* KERBEROS5 */
 
 			default:
 				fprintf(stdout,
@@ -146,6 +193,52 @@
 	nextopt:
 		argc--, argv++;
 	}
+
+#ifdef KERBEROS5
+
+	if (code != 0)
+		forward = 0;
+
+	if (forward) {
+		krb5_creds creds, mcreds;
+
+		creds.client = princ;
+		code = krb5_build_principal(context, &creds.server,
+					    krb5_princ_realm(context, princ)->length,
+					    krb5_princ_realm(context, princ)->data,
+					    "krbtgt",
+					    krb5_princ_realm(context, princ)->data, 0);
+		
+		if (code != 0) {
+			com_err(argv[0], code, "while building TGT principal");
+			forward = 0;
+		}
+
+		if (code == 0)
+			code = krb5_cc_retrieve_cred(context, ccache, 0,
+						     &creds, &mcreds);
+		
+		if (code == 0) {
+			krb5_free_principal(context, creds.server);
+
+			if ((mcreds.ticket_flags & TKT_FLG_FORWARDABLE) == 0)
+				forward = 0;
+			
+			krb5_free_cred_contents(context, &mcreds);
+		}
+
+		if (code != 0)
+			forward = 0;
+	}
+
+	krb5_cc_close(context, ccache);
+
+	if (princ)
+		krb5_free_principal(context, princ);
+	krb5_free_context(context);
+
+#endif /* KERBEROS5 */
+
 	fromatty = isatty(fileno(stdin));
 	if (fromatty)
 		verbose++;
Index: appl/gssftp/ftpd/Makefile.in
diff -u krb5/appl/gssftp/ftpd/Makefile.in:1.1.1.1 krb5/appl/gssftp/ftpd/Makefile.in:1.3
@@ -1,12 +1,15 @@
 #
 # appl/gssftp/ftpd/Makefile.in
 #
-CFLAGS = -DGSSAPI -DFTP_BUFSIZ=10240 $(CCOPTS) $(DEFS) $(LOCALINCLUDE)
+CFLAGS = -DGSSAPI -DFTP_BUFSIZ=10240 $(CCOPTS) $(DEFS) $(LOCALINCLUDE) -DKPROGDIR=\"$(CLIENT_BINDIR)\"
 
 SETENVSRC=@SETENVSRC@
 SETENVOBJ=@SETENVOBJ@
 LIBOBJS=@LIBOBJS@
 COMERRLIB=$(BUILDTOP)/util/et/libcom_err.a
+AFSLIBS=@AFSLIBS@
+LOCAL_LIBRARIES=-lpty
+DEPLOCAL_LIBRARIES=$(TOPLIBD)/../util/pty/libpty.a
 
 SRCS	= ftpd.c ftpcmd.y logwtmp.c popen.c vers.c \
 	  $(srcdir)../ftp/glob.c \
@@ -27,7 +30,7 @@
 all::	ftpd
 
 ftpd:	$(OBJS) $(DEPKLIB)
-	$(LD) $(LDFLAGS) $(LDARGS) -o $@ $(OBJS) $(KLIB) $(LIBS)
+	$(LD) $(LDFLAGS) $(LDARGS) -o $@ $(OBJS) $(KLIB) $(LIBS) $(AFSLIBS)
 
 clean::
 	$(RM) ftpd ftpcmd.c
Index: appl/gssftp/ftpd/configure.in
diff -u krb5/appl/gssftp/ftpd/configure.in:1.1.1.1 krb5/appl/gssftp/ftpd/configure.in:1.5
@@ -7,6 +7,8 @@
 CHECK_UTMP
 CHECK_SIGPROCMASK
 CHECK_WAIT_TYPE
+CHECK_SIGNALS
+CHECK_SETJMP
 AC_CHECK_SIZEOF(short)
 AC_CHECK_SIZEOF(int)
 AC_CHECK_SIZEOF(long)
@@ -17,6 +19,33 @@
 AC_REPLACE_FUNCS(getdtablesize)
 AC_HAVE_FUNCS(getcwd getusershell seteuid setreuid setresuid)
 AC_CHECK_LIB(crypt,crypt) dnl 
+dnl copied (mostly) from appl/bsd/configure.in
+AFSLIBS=
+AC_ARG_WITH([afs],
+[  --without-afs	don't have afs libraries to build against (default)
+  --with-afs=AFSDIR	use preinstalled AFS library tree],
+,with_afs=no)dnl
+if test $with_afs != no; then
+	AC_DEFINE(SETPAG)
+	AFSLIBS="$AFSLIBS -L$with_afs/lib -L$with_afs/lib/afs -lauth -lsys -lrx -llwp -lsys"
+	case $krb5_cv_host in
+	*-*-solaris*)
+		AFSLIBS="$AFSLIBS -lc -L/usr/ucblib -lucb -R/usr/ucblib"
+		;;
+	*-*-hpux*)
+		AFSLIBS="$AFSLIBS -lBSD -lm"
+		;;
+	*-*-netbsd*)
+		AFSLIBS="$AFSLIBS -lcompat"
+		;;
+	esac
+fi
+AC_SUBST(AFSLIBS)
+AC_ARG_WITH([pty-wtmp],
+[  --without-pty-wtmp   Use supplied logwtmp (default)
+  --with-pty-wtmp	Use logwtmp function included in pty library],
+[echo "Using logwtmp included in pty library"
+AC_DEFINE(USE_PTY_LOGWTMP_FTPD)])dnl
 dnl 
 dnl copied from appl/bsd/configure.in
 AC_MSG_CHECKING([setenv])
Index: appl/gssftp/ftpd/ftpcmd.y
diff -u krb5/appl/gssftp/ftpd/ftpcmd.y:1.1.1.1 krb5/appl/gssftp/ftpd/ftpcmd.y:1.2
@@ -62,6 +62,9 @@
 #include <ctype.h>
 #include <stdlib.h>
 #include <string.h>
+#ifdef __hpux
+#include <alloca.h>
+#endif
 
 extern	char *auth_type;
 
Index: appl/gssftp/ftpd/ftpd.c
diff -u krb5/appl/gssftp/ftpd/ftpd.c:1.1.1.2 krb5/appl/gssftp/ftpd/ftpd.c:1.6
@@ -206,6 +206,69 @@
 char	proctitle[FTP_BUFSIZ];	/* initial part of title */
 #endif /* SETPROCTITLE */
 
+/*
+ * AFS PAG and ticket destruction code
+ */
+
+#ifdef SETPAG
+
+typedef krb5_sigtype sigtype;
+
+#ifndef POSIX_SETJMP
+#undef sigjmp_buf
+#undef sigsetjmp
+#undef siglongjmp
+#define sigjmp_buf	jmp_buf
+#define sigsetjmp(j,s)	setjmp(j)
+#define siglongjmp	longjmp
+#endif
+
+#ifdef POSIX_SIGNALS
+typedef struct sigaction handler;
+#define handler_init(H,F)		(sigemptyset(&(H).sa_mask), \
+					 (H).sa_flags=0, \
+					 (H).sa_handler=(F))
+#define handler_swap(S,NEW,OLD)		sigaction(S, &NEW, &OLD)
+#define handler_set(S,OLD)		sigaction(S, &OLD, NULL)
+#else
+typedef sigtype (*handler)();
+#define handler_init(H,F)		((H) = (F))
+#define handler_swap(S,NEW,OLD)		((OLD) = signal ((S), (NEW)))
+#define handler_set(S,OLD)		(signal ((S), (OLD)))
+#endif
+
+extern setpag(), ktc_ForgetAllTokens();
+
+static int pagflag = 0;
+
+static sigjmp_buf setpag_buf;
+
+static sigtype sigsys ()
+{
+    siglongjmp(setpag_buf, 1);
+}
+
+static int try_afscall(scall)
+	int (*scall)();
+{
+	handler sa, osa;
+	volatile int retval = 0;
+
+	(void) &retval;
+	handler_init(sa, sigsys);
+	handler_swap(SIGSYS, sa, osa);
+	if (sigsetjmp(setpag_buf, 1) == 0) {
+	    (*scall)();
+	    retval = 1;
+	}
+	handler_set(SIGSYS, osa);
+	return retval;
+}
+
+#define try_setpag()	try_afscall(setpag);
+#define try_unlog()	try_afscall(ktc_ForgetAllTokens)
+#endif /* SETPAG */
+
 #ifdef __SCO__
 /* sco has getgroups and setgroups but no initgroups */
 int initgroups(char* name, gid_t basegid) {
@@ -225,6 +288,7 @@
 {
 	int addrlen, on = 1, tos, port = -1;
 	char *cp;
+	char ccname[35];
 
 	debug = 0;
 #ifdef SETPROCTITLE
@@ -375,6 +439,17 @@
 #define LOG_DAEMON 0
 #endif
 	openlog("ftpd", LOG_PID | LOG_NDELAY, LOG_DAEMON);
+
+#ifdef GSSAPI
+	/*
+	 * Just in case we're using Kerberos, setup a private
+	 * credential cache
+	 */
+
+	sprintf(ccname, "FILE:/tmp/krb5cc_p%d", getpid());
+	setenv("KRB5CCNAME", ccname, 0);
+#endif
+
 	addrlen = sizeof (his_addr);
 	if (getpeername(0, (struct sockaddr *)&his_addr, &addrlen) < 0) {
 		syslog(LOG_ERR, "getpeername (%s): %m",argv[0]);
@@ -579,7 +654,7 @@
 		while ((cp = getusershell()) != NULL)
 			if (strcmp(cp, shell) == 0)
 				break;
-		/* endusershell(); */ /* this breaks on solaris 2.4 */
+		endusershell();
 #else
 		cp = shell;
 #endif
@@ -688,10 +763,17 @@
  */
 end_login()
 {
+#ifdef GSSAPI
+	afs_logout();
+#endif
 
 	(void) seteuid((uid_t)0);
 	if (logged_in)
+#ifdef USE_PTY_LOGWTMP_FTPD
+		pty_logwtmp(ttyline, "", "");
+#else /* USE_PTY_LOGWTMP_FTPD */
 		ftp_logwtmp(ttyline, "", "");
+#endif /* USE_PTY_LOGWTMP_FTPD */
 	pw = NULL;
 	logged_in = 0;
 	guest = 0;
@@ -783,6 +865,12 @@
 		    (*pw->pw_passwd && strcmp(xpasswd, pw->pw_passwd) &&
 			!kpass(pw->pw_name, passwd)) ||
 		    (!*pw->pw_passwd && !kpass(pw->pw_name, passwd))) {
+#elif defined(GSSAPI)
+		/* null pw_passwd ok if Kerberos 5 password ok */
+		if (pw == NULL ||
+		    (*pw->pw_passwd && strcmp(xpasswd, pw->pw_passwd) &&
+			!k5pass(pw->pw_name, passwd)) ||
+		    (!*pw->pw_passwd && !k5pass(pw->pw_name, passwd))) {
 #else
 		/* The strcmp does not catch null passwords! */
 		if (pw == NULL || *pw->pw_passwd == '\0' ||
@@ -805,7 +893,11 @@
 
 	/* open wtmp before chroot */
 	(void)sprintf(ttyline, "ftp%d", getpid());
+#ifdef USE_PTY_LOGWTMP_FTPD
+	pty_logwtmp(ttyline, pw->pw_name, remotehost);
+#else /* USE_PTY_LOGWTMP_FTPD */
 	ftp_logwtmp(ttyline, pw->pw_name, remotehost);
+#endif /* USE_PTY_LOGWTMP_FTPD */
 	logged_in = 1;
 
 	if (guest) {
@@ -818,18 +910,47 @@
 			reply(550, "Can't set guest privileges.");
 			goto bad;
 		}
-	} else if (chdir(pw->pw_dir) < 0) {
-		if (chdir("/") < 0) {
-			reply(530, "User %s: can't change directory to %s.",
-			    pw->pw_name, pw->pw_dir);
+		if (seteuid((uid_t)pw->pw_uid) < 0) {
+			reply(550, "Can't set uid.");
 			goto bad;
-		} else
-			lreply(230, "No directory! Logging in with home=/");
-	}
-	if (seteuid((uid_t)pw->pw_uid) < 0) {
-		reply(550, "Can't set uid.");
-		goto bad;
+		}
+	} else {
+		/*
+		 * Call afs_login to hide the extra magic we need to do
+		 *
+		 * Note that much of this stuff needs to happen as the user,
+		 * so we're setting the effective uid now.  But note that
+		 * we call setpag _before_ we give up root.
+		 */
+
+#ifdef SETPAG
+		pagflag = try_setpag();
+#endif /* SETPAG */
+
+#ifdef GSSAPI
+		save_credentials();
+#endif
+
+		if (seteuid((uid_t)pw->pw_uid) < 0) {
+			reply(550, "Can't set uid.");
+			goto bad;
+		}
+
+
+#ifdef GSSAPI
+		afs_login(pw->pw_uid);
+#endif
+
+		if (chdir(pw->pw_dir) < 0) {
+			if (chdir("/") < 0) {
+				reply(530, "User %s: can't change directory to %s.",
+				    pw->pw_name, pw->pw_dir);
+				goto bad;
+			} else
+				lreply(230, "No directory! Logging in with home=/");
+		}
 	}
+
 	if (guest) {
 		reply(230, "Guest login ok, access restrictions apply.");
 #ifdef SETPROCTITLE
@@ -1669,9 +1790,22 @@
 dologout(status)
 	int status;
 {
+	/*
+	 * Prevent reception of SIGURG from resulting in a resumption
+	 * back to the main program loop.
+	 */
+	transflag = 0;
+
+#ifdef GSSAPI
+	afs_logout();
+#endif
 	if (logged_in) {
 		(void) seteuid((uid_t)0);
+#ifdef USE_PTY_LOGWTMP_FTPD
+		pty_logwtmp(ttyline, "", "");
+#else /* USE_PTY_LOGWTMP_FTPD */
 		ftp_logwtmp(ttyline, "", "");
+#endif /* USE_PTY_LOGWTMP_FTPD */
 	}
 	/* beware of flushing buffers after a SIGPIPE */
 	_exit(status);
@@ -2348,4 +2482,357 @@
 	krb5_free_context(kc);
 	return retval;
 }
+
+/*
+ * Save our credentials and destroy a credential cache before we call setuid
+ */
+
+static krb5_creds *saved_creds;
+
+save_credentials()
+{
+	krb5_context context;
+	krb5_ccache cc;
+	krb5_principal me, server;
+	krb5_creds mcred;
+
+	krb5_init_context(&context);
+
+	saved_creds = NULL;
+
+	if (krb5_cc_default(context, &cc))
+		goto leave;
+	
+	if (krb5_cc_get_principal(context, cc, &me)) {
+		krb5_cc_destroy(context, cc);
+		goto leave;
+	}
+	
+	if (krb5_build_principal_ext(context, &server,
+				     krb5_princ_realm(context, me)->length,
+				     krb5_princ_realm(context, me)->data,
+				     KRB5_TGS_NAME_SIZE, KRB5_TGS_NAME,
+				     krb5_princ_realm(context, me)->length,
+				     krb5_princ_realm(context, me)->data,
+				     0)) {
+		krb5_cc_destroy(context, cc);
+		krb5_free_principal(context, me);
+		goto leave;
+	}
+
+	saved_creds = (krb5_creds *) malloc(sizeof(krb5_creds));
+	mcred.server = server;
+	mcred.client = me;
+
+	if (krb5_cc_retrieve_cred(context, cc, KRB5_TC_MATCH_SRV_NAMEONLY,
+				  &mcred, saved_creds)) {
+		free(saved_creds);
+		saved_creds = NULL;
+		krb5_cc_destroy(context, cc);
+		krb5_free_principal(context, me);
+		krb5_free_principal(context, server);
+		goto leave;
+	}
+
+	krb5_cc_destroy(context, cc);
+	krb5_free_principal(context, me);
+	krb5_free_principal(context, server);
+
+leave:
+	krb5_free_context(context);
+
+	return;
+}
+
+/*
+ * Handle the magic we need for AFS.  Get a PAG and try to run aklog.
+ *
+ * Most of this was taken from login.
+ */
+
+afs_login(uid)
+	int uid;
+{
+	krb5_context context;
+	krb5_ccache cc;
+	int try_aklog = 0;
+	char *aklog_path;
+	struct stat st;
+
+	if (saved_creds == NULL)
+		return;
+
+	krb5_init_context(&context);
+
+	krb5_appdefault_boolean(context, "ftpd",
+				krb5_princ_realm(context, saved_creds->client),
+				"krb5_run_aklog", try_aklog, &try_aklog);
+	
+	if (try_aklog) {
+
+		if (krb5_cc_default(context, &cc))
+			goto leave;
+
+		if (krb5_cc_initialize(context, cc, saved_creds->client))
+			goto leave;
+
+		if (krb5_cc_store_cred(context, cc, saved_creds))
+			goto leave;
+
+		krb5_appdefault_string(context, "ftpd",
+				       krb5_princ_realm(context, saved_creds->client),
+				       "krb5_aklog_path", KPROGDIR "/aklog",
+				       &aklog_path);
+		
+		if (stat(aklog_path, &st) == 0) {
+			int pid, testpid;
+
+			/*
+			 * Aklog _really_ wants to run as "real user",
+			 * and in some cases, aklog breaks when using it
+			 * with an NFS translator.  Make sure that we run
+			 * aklog as the real user.
+			 */
+
+			if ((pid = fork()) == 0) {
+				seteuid(0);
+				setuid((uid_t) uid);
+				system(aklog_path);
+				exit(0);
+			} else {
+				while ((testpid = wait(NULL)) != pid &&
+					testpid != -1);
+			}
+		}
+
+		free(aklog_path);
+	}
+
+leave:
+
+	if (saved_creds)
+		krb5_free_creds(context, saved_creds);
+
+	krb5_free_context(context);
+
+}
+
+afs_logout()
+{
+	krb5_context context;
+	krb5_ccache cc;
+	int afs_retain_token = 0;
+	char *realm = NULL;
+	krb5_data realmdata;
+
+	krb5_init_context(&context);
+
+	krb5_cc_default(context, &cc);
+
+	krb5_cc_destroy(context, cc);
+
+	krb5_get_default_realm(context, &realm);
+
+	realmdata.data = realm;
+
+	krb5_appdefault_boolean(context, "ftpd", &realmdata, "afs_retain_token",
+				afs_retain_token, &afs_retain_token);
+	
+	krb5_xfree(realm);
+
+	if (!afs_retain_token) {
+#ifdef SETPAG
+		if (pagflag)
+			try_unlog();
+#endif /* SETPAG */
+	}
+
+	krb5_free_context(context);
+}
+
+static char *k5services[] = { "ftp", "host", NULL };
+
+#define KRB5_DEFAULT_LIFETIME "5h 0m 0s"
+
+/*
+ * Check our Kerberos 5 password
+ */
+
+k5pass(name, passwd)
+	char *name, *passwd;
+{
+	krb5_context context;
+	krb5_principal me = NULL, server = NULL, ver_princ = NULL;
+	krb5_keyblock *kb = NULL;
+	krb5_creds my_creds;
+	krb5_ccache cc;
+	krb5_timestamp now;
+	krb5_data packet;
+	krb5_auth_context auth_context = NULL;
+	char *lifetimestring, **service;
+	krb5_deltat lifetime;
+	int valid = 0;
+
+	packet.data = NULL;
+
+	/*
+	 * Setup Kerberos for getting the initial TGT
+	 */
+
+	krb5_init_context(&context);
+
+	if (krb5_cc_default(context, &cc))
+		goto leave;
+
+	memset((char *) &my_creds, 0, sizeof(my_creds));
+
+	if (krb5_parse_name(context, name, &me)) {
+		krb5_cc_destroy(context, cc);
+		goto leave;
+	}
+
+	my_creds.client = me;
+
+	if (krb5_cc_initialize(context, cc, me)) {
+		krb5_cc_destroy(context, cc);
+		goto leave;
+	}
+
+	if (krb5_build_principal_ext(context, &server,
+				     krb5_princ_realm(context, me)->length,
+				     krb5_princ_realm(context, me)->data,
+				     KRB5_TGS_NAME_SIZE, KRB5_TGS_NAME,
+				     krb5_princ_realm(context, me)->length,
+				     krb5_princ_realm(context, me)->data,
+				     0)) {
+		krb5_cc_destroy(context, cc);
+		goto leave;
+	}
+
+	my_creds.server = server;
+
+	if (krb5_timeofday(context, &now)) {
+		krb5_cc_destroy(context, cc);
+		goto leave;
+	}
+
+	my_creds.times.starttime = 0;
+
+	krb5_appdefault_string(context, "ftpd", krb5_princ_realm(context, me),
+				   "default_lifetime", KRB5_DEFAULT_LIFETIME,
+				   &lifetimestring);
+
+	if (krb5_string_to_deltat(lifetimestring, &lifetime)) {
+		krb5_cc_destroy(context, cc);
+		free(lifetimestring);
+		goto leave;
+	}
+
+	free(lifetimestring);
+
+	my_creds.times.endtime = now + lifetime;
+	my_creds.times.renew_till = 0;
+
+	if (krb5_get_in_tkt_with_password(context, 0, 0, NULL, 0,
+						 passwd, cc, &my_creds, 0)) {
+		krb5_cc_destroy(context, cc);
+		goto leave;
+	}
+
+	/*
+	 * Ok, if we've reached this part successfully, then that means that
+	 * we've gotten a valid ticket from the KDC.  Now we try to get a
+	 * service ticket from the KDC using a known key.  In this case,
+	 * we try "ftp" and "host".  If neither of these principals are in
+	 * the keytab, then let this user in anyway.
+	 */
+
+	for (service = k5services; *service; service++) {
+		if (krb5_sname_to_principal(context, NULL, *service,
+					    KRB5_NT_SRV_HST, &ver_princ)) {
+			krb5_cc_destroy(context, cc);
+			goto leave;
+		}
+
+		if (krb5_kt_read_service_key(context, NULL, ver_princ, 0,
+					     ENCTYPE_DES_CBC_CRC, &kb) == 0)
+			break;
+		else {
+			krb5_free_principal(context, ver_princ);
+			ver_princ = NULL;
+		}
+	}
+
+	
+	if (ver_princ == NULL) {
+		valid = 1;
+		goto leave;
+	}
+
+	/*
+	 * The reason we're doing all of this is probably not very
+	 * obvious.  Here's the theory:
+	 *
+	 * Just getting a valid ticket from the KDC for that user isn't
+	 * 100% secure, because if someone else is faking replies from the
+	 * KDC, then they could forge a reponse that appeared to be valid,
+	 * but actually wasn't.  So what we do here is use a service
+	 * ticket for the principal {ftp|host}/<host>} and generate an
+	 * AP_REQ message (using krb5_mk_req()), and then use krb5_rd_req()
+	 * to validate that message.  Since the request generated by mk_req()
+	 * was encrypted with the host or ftp principal's secret key, and
+	 * that service ticket was generated by using the user's TGT,
+	 * then if we can decode the mk_req() message, that means that
+	 * the user's credentials are legitmate.
+	 */
+
+	if (krb5_mk_req(context, &auth_context, 0, *service,
+			krb5_princ_component(context, ver_princ, 1)->data,
+			NULL, cc, &packet)) {
+		krb5_cc_destroy(context, cc);
+		goto leave;
+	}
+
+	if (auth_context) {
+		krb5_auth_con_free(context, auth_context);
+		auth_context = NULL;
+	}
+
+	if (krb5_rd_req(context, &auth_context, &packet, ver_princ, NULL,
+			NULL, NULL)) {
+		krb5_cc_destroy(context, cc);
+		goto leave;
+	}
+
+	/*
+	 * _Whew_!  Everything is cool!
+	 */
+
+	valid = 1;
+
+leave:
+
+	if (packet.data)
+		krb5_xfree(packet.data);
+	if (auth_context)
+		krb5_auth_con_free(context, auth_context);
+	if (kb)
+		krb5_free_keyblock(context, kb);
+	if (my_creds.keyblock.contents) {
+		krb5_free_cred_contents(context, &my_creds);
+		me = NULL;
+		server = NULL;
+	}
+	if (me)
+		krb5_free_principal(context, me);
+	if (server)
+		krb5_free_principal(context, server);
+	if (ver_princ)
+		krb5_free_principal(context, ver_princ);
+
+	krb5_free_context(context);
+
+	return(valid);
+}
+
 #endif /* GSSAPI */
Index: appl/gssftp/ftpd/logwtmp.c
diff -u krb5/appl/gssftp/ftpd/logwtmp.c:1.1.1.2 krb5/appl/gssftp/ftpd/logwtmp.c:1.3
@@ -1,3 +1,4 @@
+#ifndef USE_PTY_LOGWTMP_FTPD
 /*
  * Copyright (c) 1988 The Regents of the University of California.
  * All rights reserved.
@@ -80,3 +81,4 @@
 			(void)ftruncate(fd, buf.st_size);
 	}
 }
+#endif /* USE_PTY_LOGWTMP_FTPD */
Index: appl/telnet/libtelnet/auth.h
diff -u krb5/appl/telnet/libtelnet/auth.h:1.1.1.1 krb5/appl/telnet/libtelnet/auth.h:1.2
@@ -87,4 +87,12 @@
 #define OPTS_FORWARDABLE_CREDS       0x00000001
 
 extern auth_debug_mode;
+
+struct config_opts {
+	char	*optname;
+	int	*optvar;
+};
+
+void kerberos5_defaults P((struct config_opts *));
+
 #endif
Index: appl/telnet/libtelnet/kerberos.c
diff -u krb5/appl/telnet/libtelnet/kerberos.c:1.1.1.1 krb5/appl/telnet/libtelnet/kerberos.c:1.3
@@ -136,13 +136,8 @@
 	Authenticator *ap;
 	int server;
 {
-	FILE *fp;
-
 	if (server) {
 		str_data[3] = TELQUAL_REPLY;
-		if ((fp = fopen(KEYFILE, "r")) == NULL)
-			return(0);
-		fclose(fp);
 	} else {
 		str_data[3] = TELQUAL_IS;
 	}
@@ -435,8 +430,15 @@
 	if (UserNameRequested && !kuserok(&adat, UserNameRequested)) {
 		strcpy(name, UserNameRequested);
 		return(AUTH_VALID);
-	} else
+	} else {
+		/*
+		 * Always copy in UserNameRequested if the authentication
+		 * is valid, because the higher level routines need it.
+		 */
+		if (UserNameRequested)
+			strcpy(name, UserNameRequested);
 		return(AUTH_USER);
+	}
 }
 
 #define	BUMP(buf, len)		while (*(buf)) {++(buf), --(len);}
Index: appl/telnet/libtelnet/kerberos5.c
diff -u krb5/appl/telnet/libtelnet/kerberos5.c:1.1.1.2 krb5/appl/telnet/libtelnet/kerberos5.c:1.4
@@ -184,13 +184,21 @@
 {
     krb5_error_code retval;
     krb5_ccache ccache;
+    krb5_data realm;
     char *ccname;
+    int retain_ccache = 0;
     
     if (telnet_context == 0)
 	return;
 
+    krb5_get_default_realm(telnet_context, &realm.data);
+
+    krb5_appdefault_boolean(telnet_context, "telnetd", &realm,
+			    "retain_ccache", retain_ccache, &retain_ccache);
+    krb5_xfree(realm.data);
+
     ccname = getenv(KRB5_ENV_CCNAME);
-    if (ccname) {
+    if (ccname && ! retain_ccache) {
 	retval = krb5_cc_resolve(telnet_context, ccname, &ccache);
 	if (!retval)
 	    retval = krb5_cc_destroy(telnet_context, ccache);
@@ -682,8 +690,16 @@
 	{
 		strcpy(name, UserNameRequested);
 		return(AUTH_VALID);
-	} else
+	} else {
+		/*
+		 * Always copy in UserNameRequested if the authentication
+		 * is valid, because the higher level routines need it.
+		 */
+		if (UserNameRequested)
+			strcpy(name, UserNameRequested);
+
 		return(AUTH_USER);
+	}
 }
 
 #define	BUMP(buf, len)		while (*(buf)) {++(buf), --(len);}
@@ -830,4 +846,29 @@
 }
 #endif	/* FORWARD */
 
+void
+kerberos5_defaults(opts)
+	struct config_opts *opts;
+{
+	struct config_opts *opt;
+	krb5_data realm;
+
+	if (!telnet_context) {
+		krb5_init_context(&telnet_context);
+		krb5_init_ets(telnet_context);
+	}
+
+	if (! telnet_krb5_realm) {
+		krb5_get_default_realm(telnet_context, &realm.data);
+	} else {
+		realm.data = strdup(telnet_krb5_realm);
+	}
+
+	for (opt = opts; opt->optname != 0; opt++)
+		krb5_appdefault_boolean(telnet_context, "telnet", &realm,
+					opt->optname, *(opt->optvar),
+					opt->optvar);
+
+	free(realm.data);
+}
 #endif /* KRB5 */
Index: appl/telnet/telnet/Makefile.in
diff -u krb5/appl/telnet/telnet/Makefile.in:1.1.1.1 krb5/appl/telnet/telnet/Makefile.in:1.2
@@ -20,7 +20,7 @@
 #	@(#)Makefile.generic	5.5 (Berkeley) 3/1/91
 #
 
-AUTH_DEF=-DAUTHENTICATION -DENCRYPTION -DKRB5 -DFORWARD -UNO_LOGIN_F -DLOGIN_CAP_F -DLOGIN_PROGRAM=KRB5_PATH_LOGIN
+AUTH_DEF=-DAUTHENTICATION -DKRB5 -DFORWARD -UNO_LOGIN_F -DLOGIN_CAP_F -DLOGIN_PROGRAM=KRB5_PATH_LOGIN
 OTHERDEFS=-DLINEMODE -DKLUDGELINEMODE -DDIAGNOSTICS -DENV_HACK -DOLD_ENVIRON
 LOCALINCLUDES=-I.. -I$(srcdir)/..
 CFLAGS = $(CCOPTS) $(AUTH_DEF) $(OTHERDEFS) $(DEFS) $(LOCALINCLUDES)
Index: appl/telnet/telnet/commands.c
diff -u krb5/appl/telnet/telnet/commands.c:1.1.1.1 krb5/appl/telnet/telnet/commands.c:1.3
@@ -1719,18 +1719,21 @@
 	/*
 	 * Special case for DISPLAY variable.  If it is ":0.0" or
 	 * "unix:0.0", we have to get rid of "unix" and insert our
-	 * hostname.
+	 * hostname.  Make it a FQDN if possible.
 	 */
 	if ((ep = env_find("DISPLAY"))
 	    && ((*ep->value == ':')
 	        || (strncmp((char *)ep->value, "unix:", 5) == 0))) {
 		char hbuf[256+1];
+		struct hostent *hp;
 		char *cp2 = strchr((char *)ep->value, ':');
 
 		gethostname(hbuf, 256);
 		hbuf[256] = '\0';
-		cp = (char *)malloc(strlen(hbuf) + strlen(cp2) + 1);
-		sprintf((char *)cp, "%s%s", hbuf, cp2);
+		hp = gethostbyname(hbuf);
+		cp = (char *)malloc(strlen(hp ? hp->h_name : hbuf) +
+				    strlen(cp2) + 1);
+		sprintf((char *)cp, "%s%s", hp ? hp->h_name : hbuf, cp2);
 		free(ep->value);
 		ep->value = (unsigned char *)cp;
 	}
@@ -2507,8 +2510,8 @@
 	}
 	telnetport = 1;
     }
-    printf("Trying %s...\r\n", inet_ntoa(sin.sin_addr));
     do {
+	printf("Trying %s...\r\n", inet_ntoa(sin.sin_addr));
 	net = socket(AF_INET, SOCK_STREAM, 0);
 	setuid(getuid());
 	if (net < 0) {
Index: appl/telnet/telnet/configure.in
diff -u krb5/appl/telnet/telnet/configure.in:1.1.1.1 krb5/appl/telnet/telnet/configure.in:1.2
@@ -46,6 +46,13 @@
 	DEPKRB4_CRYPTO_LIB='$(TOPLIBD)/libdes425.a'
 fi
 dnl
+dnl Do we want to exclude session encryption?
+do_encrypt=yes
+AC_ARG_WITH([session-encrypt],[],do_encrypt=$withval)
+if test $do_encrypt = yes; then
+	AC_DEFINE(ENCRYPTION)
+fi
+dnl
 USE_KRB4_LIBRARY
 USE_ANAME
 KRB5_LIBRARIES
Index: appl/telnet/telnet/externs.h
diff -u krb5/appl/telnet/telnet/externs.h:1.1.1.1 krb5/appl/telnet/telnet/externs.h:1.2
@@ -77,7 +77,7 @@
 #if defined(USE_TERMIO) && !defined(SYSV_TERMIO)
 # define termio termios
 #endif
-#if defined(NO_CC_T) || !defined(USE_TERMIO)
+#if defined(NO_CC_T)
 # if !defined(USE_TERMIO)
 typedef char cc_t;
 # else
Index: appl/telnet/telnet/main.c
diff -u krb5/appl/telnet/telnet/main.c:1.1.1.1 krb5/appl/telnet/telnet/main.c:1.5
@@ -48,6 +48,7 @@
 #include "ring.h"
 #include "externs.h"
 #include "defines.h"
+#include <libtelnet/auth.h>
 
 
 #if 0
@@ -103,6 +104,20 @@
 	exit(1);
 }
 
+#ifdef KRB5
+static int forward = 0, forwardable = 0;
+static int encrypt = 0, forceencrypt = 0;
+
+static struct config_opts c_opts[] = {
+	"forward", &forward,
+	"forwardable", &forwardable,
+	"encrypt", &encrypt,
+	"autologin", &autologin,
+	"forceencrypt", &forceencrypt,
+	NULL, NULL,
+};
+#endif
+
 /*
  * main.  Parse arguments, invoke the protocol or command parser.
  */
@@ -110,6 +125,7 @@
 /* see forward.c -- indicate that we're in telnet, not telnetd. */
 char *line = 0;
 
+
 main(argc, argv)
 	int argc;
 	char *argv[];
@@ -120,6 +136,7 @@
 	char *user;
 #ifdef	FORWARD
 	extern int forward_flags;
+	int opt_forward = 0, opt_forwardable = 0;
 #endif	/* FORWARD */
 #ifdef ENCRYPTION
 	extern int auth_enable_encrypt;
@@ -142,7 +159,15 @@
 	rlogin = (strncmp(prompt, "rlog", 4) == 0) ? '~' : _POSIX_VDISABLE;
 	autologin = -1;
 
-	while ((ch = getopt(argc, argv, "8EKLS:X:acde:fFk:l:n:rt:x")) != EOF) {
+#ifdef KRB5
+	/*
+	 * Get the defaults from the Kerberos 5 profile, if we have one
+	 */
+	
+	kerberos5_defaults(c_opts);
+#endif /* KRB5 */
+
+	while ((ch = getopt(argc, argv, "8EKLNS:X:acde:fFk:l:n:rt:x")) != EOF) {
 		switch(ch) {
 		case '8':
 			eight = 3;	/* binary output and input */
@@ -158,6 +183,16 @@
 		case 'L':
 			eight |= 2;	/* binary output only */
 			break;
+		case 'N':
+#if defined(AUTHENTICATION) && defined(KRB5) && defined(FORWARD)
+			opt_forward = forward = 0;
+			opt_forwardable = forwardable = 0;
+#else
+			fprintf(stderr,
+			 "%s: Warning: -N ignored, no Kerberos V5 support.\n", 
+				prompt);
+#endif
+		break;
 		case 'S':
 		    {
 #if defined(HAS_GETTOS) || (defined(IPPROTO_IP) && defined(IP_TOS))
@@ -196,13 +231,13 @@
 			break;
 		case 'f':
 #if defined(AUTHENTICATION) && defined(KRB5) && defined(FORWARD)
-			if (forward_flags & OPTS_FORWARD_CREDS) {
+			if (opt_forwardable) {
 			    fprintf(stderr, 
 				    "%s: Only one of -f and -F allowed.\n",
 				    prompt);
 			    usage();
 			}
-			forward_flags |= OPTS_FORWARD_CREDS;
+			opt_forward = 1;
 #else
 			fprintf(stderr,
 			 "%s: Warning: -f ignored, no Kerberos V5 support.\n", 
@@ -211,14 +246,13 @@
 			break;
 		case 'F':
 #if defined(AUTHENTICATION) && defined(KRB5) && defined(FORWARD)
-			if (forward_flags & OPTS_FORWARD_CREDS) {
+			if (opt_forward) {
 			    fprintf(stderr, 
 				    "%s: Only one of -f and -F allowed.\n",
 				    prompt);
 			    usage();
 			}
-			forward_flags |= OPTS_FORWARD_CREDS;
-			forward_flags |= OPTS_FORWARDABLE_CREDS;
+			opt_forwardable = 1;
 #else
 			fprintf(stderr,
 			 "%s: Warning: -F ignored, no Kerberos V5 support.\n", 
@@ -282,15 +316,13 @@
 			break;
 		case 'x':
 #ifdef	ENCRYPTION
-			encrypt_auto(1);
-			decrypt_auto(1);
-			wantencryption = 1;
-			autologin = 1;
-			auth_enable_encrypt = 1;
+			encrypt = 1;
+			forceencrypt = 1;
 #else
 			fprintf(stderr,
-			    "%s: Warning: -x ignored, no ENCRYPT support.\n",
+			    "%s: encryption not supported.\n",
 								prompt);
+			exit(1);
 #endif
 			break;
 		case '?':
@@ -299,6 +331,28 @@
 			/* NOTREACHED */
 		}
 	}
+
+#if defined(AUTHENTICATION) && defined(KRB5) && defined(FORWARD)
+	if (opt_forward || forward) {
+		forward_flags |= OPTS_FORWARD_CREDS;
+	}
+	if (opt_forwardable || forwardable) {
+		forward_flags |= OPTS_FORWARD_CREDS;
+		forward_flags |= OPTS_FORWARDABLE_CREDS;
+	}
+#endif /* AUTH and KRB5 and FORWARD */
+
+#ifdef  ENCRYPTION
+	if (encrypt) {
+		encrypt_auto(1);
+		decrypt_auto(1);
+		if (forceencrypt)
+			wantencryption = 1;
+		autologin = 1;
+		auth_enable_encrypt = 1;
+	}
+#endif
+
 	if (autologin == -1)
 		autologin = (rlogin == _POSIX_VDISABLE) ? 0 : 1;
 
Index: appl/telnet/telnet/telnet.c
diff -u krb5/appl/telnet/telnet/telnet.c:1.1.1.1 krb5/appl/telnet/telnet/telnet.c:1.2
@@ -2271,17 +2271,15 @@
     }
 #endif	/* defined(AUTHENTICATION) || defined(ENCRYPTION)  */
 #   if !defined(TN3270)
+    if (telnetport) {
 #if	defined(AUTHENTICATION)
-    if (autologin)
-	send_will(TELOPT_AUTHENTICATION, 1);
+	if (autologin)
+	    send_will(TELOPT_AUTHENTICATION, 1);
 #endif
 #ifdef	ENCRYPTION
-    if (telnetport || wantencryption) {
 	send_do(TELOPT_ENCRYPT, 1);
 	send_will(TELOPT_ENCRYPT, 1);
-    }
 #endif	/* ENCRYPTION */
-    if (telnetport) {
 	send_do(TELOPT_SGA, 1);
 	send_will(TELOPT_TTYPE, 1);
 	send_will(TELOPT_NAWS, 1);
@@ -2308,6 +2306,8 @@
 	extern int auth_has_failed;
 	time_t timeout = time(0) + 60;
 
+	if (my_want_state_is_wont(TELOPT_AUTHENTICATION))
+		send_will(TELOPT_AUTHENTICATION, 1);
 	send_do(TELOPT_ENCRYPT, 1);
 	send_will(TELOPT_ENCRYPT, 1);
 	while (1) {
@@ -2335,6 +2335,7 @@
 	    if (printed_encrypt == 0) {
 		    printed_encrypt = 1;
 		    printf("Waiting for encryption to be negotiated...");
+		    fflush(stdout);
 		    /*
 		     * Turn on MODE_TRAPSIG and then turn off localchars 
 		     * so that ^C will cause telnet to exit.
Index: appl/telnet/telnetd/configure.in
diff -u krb5/appl/telnet/telnetd/configure.in:1.1.1.1 krb5/appl/telnet/telnetd/configure.in:1.2
@@ -24,6 +24,7 @@
 AC_HEADER_TIME
 AC_CHECK_HEADERS(string.h arpa/nameser.h)
 AC_CHECK_HEADERS(sys/time.h sys/tty.h)
+AC_CHECK_HEADERS(sys/utsname.h)
 AC_HAVE_FUNCS(vhangup)
 dnl Make our operating system-specific security checks and definitions for
 dnl login.
Index: appl/telnet/telnetd/ext.h
diff -u krb5/appl/telnet/telnetd/ext.h:1.1.1.2 krb5/appl/telnet/telnetd/ext.h:1.3
@@ -234,7 +234,15 @@
 #   ifdef ultrix
 #    define DEFAULT_IM	"\r\n\r\nULTRIX (%h) (%t)\r\n\r\r\n\r"
 #   else
-#    define DEFAULT_IM	"\r\n\r\n4.4 BSD UNIX (%h) (%t)\r\n\r\r\n\r"
+#    ifdef sgi
+#     define DEFAULT_IM "\r\n\r\nIRIX (%h) (%t)\r\n\r\r\n\r"
+#    else
+#     if defined(hpux) || defined(__hpux)
+#      define DEFAULT_IM "\r\n\r\nHP/UX (%h) (%t)\r\n\r\r\n\r"
+#     else
+#      define DEFAULT_IM	"\r\n\r\n4.4 BSD UNIX (%h) (%t)\r\n\r\r\n\r"
+#     endif
+#    endif
 #   endif
 #  endif
 # endif
Index: appl/telnet/telnetd/utility.c
diff -u krb5/appl/telnet/telnetd/utility.c:1.1.1.1 krb5/appl/telnet/telnetd/utility.c:1.3
@@ -35,6 +35,9 @@
 
 #define PRINTOPTIONS
 #include "telnetd.h"
+#ifdef HAVE_SYS_UTSNAME_H
+#include <sys/utsname.h>
+#endif /* HAVE_SYS_UTSNAME_H */
 
 /*
  * utility functions performing io related tasks
@@ -367,7 +370,11 @@
 	int f;
 	const char *msg;
 {
-	char buf[BUFSIZ], *strerror();
+	char buf[BUFSIZ];
+#ifndef __convex__
+	/* strerror() is a macro under ConvexOS */
+	char *strerror();
+#endif /* __convex__*/
 
 	(void) sprintf(buf, "%s: %s\r\n", msg, strerror(errno));
 	fatal(f, buf);
@@ -448,6 +455,11 @@
 	char *slash;
 	time_t t;
 	char db[100];
+#ifdef HAVE_SYS_UTSNAME_H
+	struct utsname utsinfo;
+
+	uname(&utsinfo);
+#endif /* HAVE_SYS_UTSNAME_H */
 
 	putlocation = where;
 
@@ -480,6 +492,24 @@
 			(void)strftime(db, sizeof(db), fmtstr, localtime(&t));
 			putstr(db);
 			break;
+
+#ifdef HAVE_SYS_UTSNAME_H
+		case 's':
+			putstr(utsinfo.sysname);
+			break;
+
+		case 'm':
+			putstr(utsinfo.machine);
+			break;
+
+		case 'r':
+			putstr(utsinfo.release);
+			break;
+
+		case 'v':
+			putstr(utsinfo.version);
+			break;
+#endif /* HAVE_SYS_UTSNAME_H */
 
 		case '%':
 			putchr('%');
Index: clients/kinit/Makefile.in
diff -u krb5/clients/kinit/Makefile.in:1.1.1.1 krb5/clients/kinit/Makefile.in:1.2
@@ -1,4 +1,4 @@
-CFLAGS = $(CCOPTS) $(DEFS) $(LOCALINCLUDE)
+CFLAGS = $(CCOPTS) $(DEFS) $(LOCALINCLUDE) -DKPROGDIR=\"$(CLIENT_BINDIR)\"
 
 all::
 
Index: clients/kinit/kinit.c
diff -u krb5/clients/kinit/kinit.c:1.1.1.1 krb5/clients/kinit/kinit.c:1.6
@@ -61,7 +61,7 @@
     char *cache_name = NULL;		/* -f option */
     char *keytab_name = NULL;		/* -t option */
     char *service_name = NULL;		/* -s option */
-    krb5_deltat lifetime = KRB5_DEFAULT_LIFE;	/* -l option */
+    krb5_deltat lifetime = 0;	/* -l option */
     krb5_timestamp starttime = 0;
     krb5_deltat rlife = 0;
     int options = KRB5_DEFAULT_OPTIONS;
@@ -78,7 +78,12 @@
     krb5_keytab keytab = NULL;
     struct passwd *pw = 0;
     int pwsize;
+    int not_forward = 0;
+    int run_aklog = 0;
+    int not_run_aklog = 0;
     char password[255], *client_name, prompt[255];
+    krb5_kdc_rep *kdc_rep = 0;
+    krb5_last_req_entry **last_req;
 
     code = krb5_init_context(&kcontext);
     if (code) {
@@ -94,8 +99,14 @@
     if (strrchr(argv[0], '/'))
 	argv[0] = strrchr(argv[0], '/')+1;
 
-    while ((option = getopt(argc, argv, "r:Rfpl:s:c:kt:vS:")) != EOF) {
+    while ((option = getopt(argc, argv, "aAr:RfFpl:s:c:kt:vS:")) != EOF) {
 	switch (option) {
+	case 'a':
+	    run_aklog = 1;
+	    break;
+	case 'A':
+	    not_run_aklog = 1;
+	    break;
 	case 'r':
 	    options |= KDC_OPT_RENEWABLE;
 	    code = krb5_string_to_deltat(optarg, &rlife);
@@ -119,7 +130,20 @@
 	    options |= KDC_OPT_PROXIABLE;
 	    break;
 	case 'f':
-	    options |= KDC_OPT_FORWARDABLE;
+	    if (not_forward) {
+		fprintf(stderr, "Cannot use both -f and -F.\n");
+		errflg++;
+	    } else {
+		options |= KDC_OPT_FORWARDABLE;
+	    }
+	    break;
+	case 'F':
+	    if (options & KDC_OPT_FORWARDABLE) {
+		fprintf(stderr, "Cannot use both -f and -F.\n");
+		errflg++;
+	    } else {
+		not_forward = 1;
+	    }
 	    break;
 #ifndef NO_KEYTAB
        case 'k':
@@ -186,6 +210,16 @@
 	}
     }
 
+    if (run_aklog && not_run_aklog) {
+	fprintf(stderr, "Cannot use both -a and -A.\n");
+	errflg++;
+    }
+
+    if (run_aklog && starttime) {
+	fprintf(stderr, "Cannout use both -a and -s.\n");
+	errflg++;
+    }
+
     if (argc - optind > 1) {
 	fprintf(stderr, "Extra arguments (starting with \"%s\").\n",
 		argv[optind+1]);
@@ -193,7 +227,7 @@
     }
 
     if (errflg) {
-	fprintf(stderr, "Usage: %s [-r time] [-R] [-s time] [-v] [-puf] [-l lifetime] [-c cachename] [-k] [-t keytab] [-S target_service] [principal]\n", argv[0]);
+	fprintf(stderr, "Usage: %s [-a|-A] [-r time] [-R] [-s time] [-v] [-puf] [-l lifetime] [-c cachename] [-k] [-t keytab] [-S target_service] [principal]\n", argv[0]);
 	exit(2);
     }
 
@@ -278,9 +312,41 @@
 	
     my_creds.server = server;
 
+    {
+      int forward;
+		krb5_appdefault_boolean(kcontext, "kinit", krb5_princ_realm(kcontext,me),
+					"forwardable", 0, &forward);
+	if (forward && ! not_forward)
+		options |= KDC_OPT_FORWARDABLE;
+
+	if (!lifetime) {
+		char *lifetimestring;
+		krb5_appdefault_string(kcontext, "kinit", krb5_princ_realm(kcontext,me),
+					   "default_lifetime", "",
+					   &lifetimestring);
+		if (lifetimestring[0]) {
+		  code = krb5_string_to_deltat(lifetimestring, &lifetime);
+		  if (code != 0 || lifetime == 0) {
+		    fprintf(stderr, "Bad lifetime value: %s\n",
+			    lifetimestring);
+		    exit(1);
+		  }
+		}
+		else lifetime = KRB5_DEFAULT_LIFE;
+		free(lifetimestring);
+	}
+    }
+
+    if (!run_aklog && !not_run_aklog) {
+	krb5_appdefault_boolean(kcontext, "kinit",
+				krb5_princ_realm(kcontext,me),
+				"krb5_run_aklog", 0, &run_aklog);
+    }
+
     if (options & KDC_OPT_POSTDATED) {
       my_creds.times.starttime = starttime;
       my_creds.times.endtime = starttime + lifetime;
+      not_run_aklog = 1;
     } else {
       my_creds.times.starttime = 0;	/* start timer when request
 					   gets to KDC */
@@ -334,7 +400,7 @@
 
 	 code = krb5_get_in_tkt_with_password(kcontext, options, addrs,
 					      NULL, preauth, password, 0,
-					      &my_creds, 0);
+					      &my_creds, &kdc_rep);
 	 memset(password, 0, sizeof(password));
 #ifndef NO_KEYTAB
     } else {
@@ -351,6 +417,44 @@
 	    com_err (argv[0], code, "while getting initial credentials");
 	exit(1);
     }
+    /*
+     * Check for upcoming password expiration
+     */
+
+    if (kdc_rep) {
+	if (kdc_rep->enc_part2 && kdc_rep->enc_part2->last_req) {
+	    for (last_req = kdc_rep->enc_part2->last_req; *last_req;
+		 last_req++) {
+		if ((*last_req)->lr_type == KRB5_LRQ_PW_EXPTIME) {
+		    krb5_deltat delta;
+		    char tempbuf[256];
+		    float fdelta;
+
+		    delta = (*last_req)->value - now;
+
+		    /*
+		     * Different messages for hours and days
+		     */
+
+		    if (delta >= 60*60*24) {
+			fdelta = ((float) delta) / ((float) 60*60*24);
+		    } else {
+			fdelta = ((float) delta) / ((float) 60*60);
+		    }
+
+		    if (krb5_timestamp_to_string((*last_req)->value,
+						 tempbuf, 256))
+			goto fail_warn;
+
+		    printf("WARNING: Your password will expire in %.1f %s "
+			   "on %s.\n", fdelta,
+			   delta >= 60*60*24 ? "days" : "hours", tempbuf);
+		}
+	    }
+	}
+fail_warn:
+	krb5_free_kdc_rep(kcontext, kdc_rep);
+    }
 
     code = krb5_cc_initialize (kcontext, ccache, me);
     if (code != 0) {
@@ -368,8 +472,30 @@
     /* my_creds is pointing at server */
     krb5_free_principal(kcontext, server);
 
+    /* Run aklog if requested */
+    if (run_aklog && !not_run_aklog) {
+	char *aklog_path;
+	struct stat st;
+
+
+	krb5_appdefault_string(kcontext, "kinit",
+			       krb5_princ_realm(kcontext,me),
+			       "krb5_aklog_path", KPROGDIR "/aklog",
+			       &aklog_path);
+
+	/*
+	 * Make sure it exists before we try to run it
+	 */
+	if (stat(aklog_path, &st) == 0) {
+	    system(aklog_path);
+	}
+
+	free(aklog_path);
+	
+    }
+
     krb5_free_context(kcontext);
-    
+
     exit(0);
 }
 
Index: clients/ksu/configure.in
diff -u krb5/clients/ksu/configure.in:1.1.1.1 krb5/clients/ksu/configure.in:1.3
@@ -3,8 +3,14 @@
 AC_PROG_INSTALL
 USE_ANAME
 AC_HEADER_STDARG
-AC_CHECK_FUNCS(getusershell lstat )
+AC_CHECK_FUNCS(getusershell lstat putenv)
 AC_CHECK_HEADERS(unistd.h)
+AC_ARG_ENABLE([irix-project-init],
+[  --enable-irix-project-init   Initialize the IRIX project id at login
+  --disable-irix-project-init  Don't do IRIX project setup (default)],[
+AC_MSG_RESULT(Enabling IRIX project initialization support)
+AC_DEFINE(IRIX_PROJECT_INIT)
+])
 USE_KRB5UTIL_LIBRARY
 KRB5_LIBRARIES
 V5_USE_SHARED_LIB
Index: clients/ksu/krb_auth_su.c
diff -u krb5/clients/ksu/krb_auth_su.c:1.1.1.2 krb5/clients/ksu/krb_auth_su.c:1.2
@@ -343,14 +343,14 @@
 
 	/* Check to make sure ticket hasn't expired */
 	if (retval = krb5_check_exp(context, tkt->enc_part2->times)) {
-		if (auth_debug && (retval == KRB5KRB_AP_ERR_TKT_EXPIRED)) {
-			fprintf(stderr,
-				"krb5_verify_tkt_def: ticket has expired");
-		}
-		krb5_free_ticket(context, tkt);	
-		krb5_kt_free_entry(context, &ktentry);
-		krb5_free_keyblock(context, tkt_key);
-		return KRB5KRB_AP_ERR_TKT_EXPIRED;
+	    if (auth_debug && (retval == KRB5KRB_AP_ERR_TKT_EXPIRED)) {
+		fprintf(stderr,
+			"krb5_verify_tkt_def: ticket has expired");
+	    }
+	    krb5_free_ticket(context, tkt);	
+	    krb5_kt_free_entry(context, &ktentry);
+	    krb5_free_keyblock(context, tkt_key);
+	    return KRB5KRB_AP_ERR_TKT_EXPIRED;
 	}
 
 	if (!krb5_principal_compare(context, client, tkt->enc_part2->client)) {
Index: clients/ksu/main.c
diff -u krb5/clients/ksu/main.c:1.1.1.1 krb5/clients/ksu/main.c:1.3
@@ -793,6 +793,16 @@
 	        exit(1);
 	}
 
+#ifdef IRIX_PROJECT_INIT
+       /*
+	* Initialize the magical IRIX array session, and the
+	* default project id.
+	*/
+	
+       newarraysess();
+       setprid(getdfltprojuser(target_user));
+#endif /* IRIX_PROJECT_INIT */
+
        if ( ! strcmp(target_user, source_user)){ 			
        		print_status("Leaving uid as %s (%d)\n",
 				 target_user, target_pwd->pw_uid); 
@@ -915,6 +925,7 @@
     char *name;
     char *value;
 {
+#ifdef HAVE_PUTENV
 char * env_var_buf;
 
 	/* allocate extra two spaces, one for the = and one for the \0 */  
@@ -922,7 +933,12 @@
 					sizeof(char)); 
 
         sprintf(env_var_buf,"%s=%s",name, value);  
+
         return putenv(env_var_buf);
+#else
+	/* Assume we have setenv() */
+	return setenv(name, value, 1);
+#endif
 
 }
 
Index: config/config.guess
diff -u krb5/config/config.guess:1.1.1.1 krb5/config/config.guess:1.2
@@ -67,21 +67,28 @@
     amiga:NetBSD:*:*)
       echo m68k-cbm-netbsd${UNAME_RELEASE}
       exit 0 ;;
+    amiga:OpenBSD:*:*)
+      echo m68k-cbm-openbsd${UNAME_RELEASE}
+      exit 0 ;;
     arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
 	echo arm-acorn-riscix${UNAME_RELEASE}
 	exit 0;;
-    Pyramid*:OSx*:*:*)
+    Pyramid*:OSx*:*:*|MIS*:OSx*:*:*)
+	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
 	if test "`(/bin/universe) 2>/dev/null`" = att ; then
 		echo pyramid-pyramid-sysv3
 	else
 		echo pyramid-pyramid-bsd
 	fi
 	exit 0 ;;
-    sun4*:SunOS:5.*:*)
+    NILE:*:*:dcosx)
+	echo pyramid-pyramid-svr4
+	exit 0 ;;
+    sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
 	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
 	exit 0 ;;
     i86pc:SunOS:5.*:*)
-	echo i386-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	echo i386-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
 	exit 0 ;;
     sun4*:SunOS:6*:*)
 	# According to config.sub, this is the proper way to canonicalize
@@ -101,25 +108,60 @@
     sun3*:SunOS:*:*)
 	echo m68k-sun-sunos${UNAME_RELEASE}
 	exit 0 ;;
+    aushp:SunOS:*:*)
+	echo sparc-auspex-sunos${UNAME_RELEASE}
+	exit 0 ;;
     atari*:NetBSD:*:*)
 	echo m68k-atari-netbsd${UNAME_RELEASE}
 	exit 0 ;;
+    atari*:OpenBSD:*:*)
+	echo m68k-atari-openbsd${UNAME_RELEASE}
+	exit 0 ;;
     sun3*:NetBSD:*:*)
 	echo m68k-sun-netbsd${UNAME_RELEASE}
 	exit 0 ;;
+    sun3*:OpenBSD:*:*)
+	echo m68k-sun-openbsd${UNAME_RELEASE}
+	exit 0 ;;
     mac68k:NetBSD:*:*)
 	echo m68k-apple-netbsd${UNAME_RELEASE}
 	exit 0 ;;
+    mac68k:OpenBSD:*:*)
+	echo m68k-apple-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    powerpc:machten:*:*)
+	echo powerpc-apple-machten${UNAME_RELEASE}
+	exit 0 ;;
+    RISC*:Mach:*:*)
+	echo mips-dec-mach_bsd4.3
+	exit 0 ;;
     RISC*:ULTRIX:*:*)
 	echo mips-dec-ultrix${UNAME_RELEASE}
 	exit 0 ;;
     VAX*:ULTRIX*:*:*)
 	echo vax-dec-ultrix${UNAME_RELEASE}
 	exit 0 ;;
-    mips:*:4*:UMIPS)
-	echo mips-mips-riscos4sysv
-	exit 0 ;;
-    mips:*:5*:RISCos)
+    mips:*:*:UMIPS | mips:*:*:RISCos)
+	sed 's/^	//' << EOF >dummy.c
+	int main (argc, argv) int argc; char **argv; {
+	#if defined (host_mips) && defined (MIPSEB)
+	#if defined (SYSTYPE_SYSV)
+	  printf ("mips-mips-riscos%ssysv\n", argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_SVR4)
+	  printf ("mips-mips-riscos%ssvr4\n", argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
+	  printf ("mips-mips-riscos%sbsd\n", argv[1]); exit (0);
+	#endif
+	#endif
+	  exit (-1);
+	}
+EOF
+	${CC-cc} dummy.c -o dummy \
+	  && ./dummy `echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` \
+	  && rm dummy.c dummy && exit 0
+	rm -f dummy.c dummy
 	echo mips-mips-riscos${UNAME_RELEASE}
 	exit 0 ;;
     Night_Hawk:Power_UNIX:*:*)
@@ -137,7 +179,7 @@
     AViiON:dgux:*:*)
         # DG/UX returns AViiON for all architectures
         UNAME_PROCESSOR=`/usr/bin/uname -p`
-        if [ $UNAME_PROCESSOR = mc88100 -o $UNAME_PROCESSOR = mc88100 ] ; then
+        if [ $UNAME_PROCESSOR = mc88100 -o $UNAME_PROCESSOR = mc88110 ] ; then
 	if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx \
 	     -o ${TARGET_BINARY_INTERFACE}x = x ] ; then
 		echo m88k-dg-dgux${UNAME_RELEASE}
@@ -163,10 +205,10 @@
     *:IRIX*:*:*)
 	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
 	exit 0 ;;
-   ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
+    ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
 	echo romp-ibm-aix      # uname -m gives an 8 hex-code CPU id
 	exit 0 ;;              # Note that: echo "'`uname -s`'" gives 'AIX '
-    i[34]86:AIX:*:*)
+    i?86:AIX:*:*)
 	echo i386-ibm-aix
 	exit 0 ;;
     *:AIX:2:3)
@@ -211,7 +253,7 @@
 	echo romp-ibm-bsd4.4
 	exit 0 ;;
     ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC NetBSD and
-	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to 
+	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
 	exit 0 ;;                           # report: romp-ibm BSD 4.3
     *:BOSX:*:*)
 	echo rs6000-bull-bosx
@@ -229,7 +271,7 @@
 	case "${UNAME_MACHINE}" in
 	    9000/31? )            HP_ARCH=m68000 ;;
 	    9000/[34]?? )         HP_ARCH=m68k ;;
-	    9000/7?? | 9000/8?[679] ) HP_ARCH=hppa1.1 ;;
+	    9000/7?? | 9000/8?[1679] ) HP_ARCH=hppa1.1 ;;
 	    9000/8?? )            HP_ARCH=hppa1.0 ;;
 	esac
 	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
@@ -277,6 +319,13 @@
     hp8??:OSF1:*:*)
 	echo hppa1.0-hp-osf
 	exit 0 ;;
+    i?86:OSF1:*:*)
+	if [ -x /usr/sbin/sysversion ] ; then
+	    echo ${UNAME_MACHINE}-unknown-osf1mk
+	else
+	    echo ${UNAME_MACHINE}-unknown-osf1
+	fi
+	exit 0 ;;
     parisc*:Lites*:*:*)
 	echo hppa1.1-hp-lites
 	exit 0 ;;
@@ -304,17 +353,33 @@
     CRAY*Y-MP:*:*:*)
 	echo ymp-cray-unicos${UNAME_RELEASE}
 	exit 0 ;;
-    CRAY*C90:*:*:*)
-	echo c90-cray-unicos${UNAME_RELEASE}
+    CRAY*[A-Z]90:*:*:*)
+	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
+	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
+	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/
+	exit 0 ;;
+    CRAY*TS:*:*:*)
+	echo t90-cray-unicos${UNAME_RELEASE}
 	exit 0 ;;
     CRAY-2:*:*:*)
 	echo cray2-cray-unicos
         exit 0 ;;
+    F300:UNIX_System_V:*:*)
+        FUJITSU_SYS=`uname -p | tr [A-Z] [a-z] | sed -e 's/\///'`
+        FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
+        echo "f300-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+        exit 0 ;;
+    F301:UNIX_System_V:*:*)
+       echo f301-fujitsu-uxpv`echo $UNAME_RELEASE | sed 's/ .*//'`
+       exit 0 ;;
     hp3[0-9][05]:NetBSD:*:*)
 	echo m68k-hp-netbsd${UNAME_RELEASE}
 	exit 0 ;;
-    i[34]86:BSD/386:*:* | *:BSD/OS:*:*)
-	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
+    hp3[0-9][05]:OpenBSD:*:*)
+	echo m68k-hp-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    i?86:BSD/386:*:* | *:BSD/OS:*:*)
+	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
 	exit 0 ;;
     *:FreeBSD:*:*)
 	echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
@@ -322,8 +387,11 @@
     *:NetBSD:*:*)
 	echo ${UNAME_MACHINE}-unknown-netbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
 	exit 0 ;;
+    *:OpenBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-openbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+	exit 0 ;;
     i*:CYGWIN*:*)
-	echo i386-unknown-cygwin32
+	echo i386-pc-cygwin32
 	exit 0 ;;
     p*:CYGWIN*:*)
 	echo powerpcle-unknown-cygwin32
@@ -338,23 +406,27 @@
 	# The BFD linker knows what the default object file format is, so
 	# first see if it will tell us.
 	ld_help_string=`ld --help 2>&1`
-	if echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations: elf_i[345]86"; then
-	  echo "${UNAME_MACHINE}-unknown-linux" ; exit 0
-	elif echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations: i[345]86linux"; then
-	  echo "${UNAME_MACHINE}-unknown-linuxaout" ; exit 0
-	elif echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations: i[345]86coff"; then
-	  echo "${UNAME_MACHINE}-unknown-linuxcoff" ; exit 0
+	if echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations: elf_i.86"; then
+	  echo "${UNAME_MACHINE}-pc-linux-gnu" ; exit 0
+	elif echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations: i.86linux"; then
+	  echo "${UNAME_MACHINE}-pc-linux-gnuaout" ; exit 0
+	elif echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations: i.86coff"; then
+	  echo "${UNAME_MACHINE}-pc-linux-gnucoff" ; exit 0
 	elif echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations: m68kelf"; then
-	  echo "${UNAME_MACHINE}-unknown-linux" ; exit 0
+	  echo "${UNAME_MACHINE}-unknown-linux-gnu" ; exit 0
 	elif echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations: m68klinux"; then
-	  echo "${UNAME_MACHINE}-unknown-linuxaout" ; exit 0
+	  echo "${UNAME_MACHINE}-unknown-linux-gnuaout" ; exit 0
+	elif echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations: elf32ppc"; then
+	  echo "powerpc-unknown-linux-gnu" ; exit 0
 	elif test "${UNAME_MACHINE}" = "alpha" ; then
-	  echo alpha-unknown-linux ; exit 0
+	  echo alpha-unknown-linux-gnu ; exit 0
+	elif test "${UNAME_MACHINE}" = "sparc" ; then
+	  echo sparc-unknown-linux-gnu ; exit 0
 	else
-	  # Either a pre-BFD a.out linker (linuxoldld) or one that does not give us
-	  # useful --help.  Gcc wants to distinguish between linuxoldld and linuxaout.
+	  # Either a pre-BFD a.out linker (linux-gnuoldld) or one that does not give us
+	  # useful --help.  Gcc wants to distinguish between linux-gnuoldld and linux-gnuaout.
 	  test ! -d /usr/lib/ldscripts/. \
-	    && echo "${UNAME_MACHINE}-unknown-linuxoldld" && exit 0
+	    && echo "${UNAME_MACHINE}-pc-linux-gnuoldld" && exit 0
 	  # Determine whether the default compiler is a.out or elf
 	  cat >dummy.c <<EOF
 main(argc, argv)
@@ -362,9 +434,9 @@
 char *argv[];
 {
 #ifdef __ELF__
-  printf ("%s-unknown-linux\n", argv[1]);
+  printf ("%s-pc-linux-gnu\n", argv[1]);
 #else
-  printf ("%s-unknown-linuxaout\n", argv[1]);
+  printf ("%s-pc-linux-gnuaout\n", argv[1]);
 #endif
   return 0;
 }
@@ -374,32 +446,32 @@
 	fi ;;
 # ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.  earlier versions
 # are messed up and put the nodename in both sysname and nodename.
-    i[34]86:DYNIX/ptx:4*:*)
+    i?86:DYNIX/ptx:4*:*)
 	echo i386-sequent-sysv4
 	exit 0 ;;
-    i[34]86:*:4.*:* | i[34]86:SYSTEM_V:4.*:*)
+    i?86:*:4.*:* | i?86:SYSTEM_V:4.*:*)
 	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
 		echo ${UNAME_MACHINE}-univel-sysv${UNAME_RELEASE}
 	else
-		echo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}
+		echo ${UNAME_MACHINE}-pc-sysv${UNAME_RELEASE}
 	fi
 	exit 0 ;;
-    i[34]86:*:3.2:*)
+    i?86:*:3.2:*)
 	if test -f /usr/options/cb.name; then
 		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
-		echo ${UNAME_MACHINE}-unknown-isc$UNAME_REL
+		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
 	elif /bin/uname -X 2>/dev/null >/dev/null ; then
 		UNAME_REL=`(/bin/uname -X|egrep Release|sed -e 's/.*= //')`
 		(/bin/uname -X|egrep i80486 >/dev/null) && UNAME_MACHINE=i486
 		(/bin/uname -X|egrep '^Machine.*Pentium' >/dev/null) \
 			&& UNAME_MACHINE=i586
-		echo ${UNAME_MACHINE}-unknown-sco$UNAME_REL
+		echo ${UNAME_MACHINE}-pc-sco$UNAME_REL
 	else
-		echo ${UNAME_MACHINE}-unknown-sysv32
+		echo ${UNAME_MACHINE}-pc-sysv32
 	fi
 	exit 0 ;;
     Intel:Mach:3*:*)
-	echo i386-unknown-mach3
+	echo i386-pc-mach3
 	exit 0 ;;
     paragon:*:*:*)
 	echo i860-intel-osf1
@@ -415,28 +487,36 @@
 	# "miniframe"
 	echo m68010-convergent-sysv
 	exit 0 ;;
-    M680[234]0:*:R3V[567]*:*)
+    M68*:*:R3V[567]*:*)
 	test -r /sysV68 && echo 'm68k-motorola-sysv' && exit 0 ;;
-    3[34]??:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0)
-        uname -p 2>/dev/null | grep 86 >/dev/null \
-          && echo i486-ncr-sysv4.3 && exit 0 ;;
+    3[34]??:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 4850:*:4.0:3.0)
+	OS_REL=''
+	test -r /etc/.relid \
+	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	  && echo i486-ncr-sysv4.3${OS_REL} && exit 0
+	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
+	  && echo i586-ncr-sysv4.3${OS_REL} && exit 0 ;;
     3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
-        uname -p 2>/dev/null | grep 86 >/dev/null \
+        /bin/uname -p 2>/dev/null | grep 86 >/dev/null \
           && echo i486-ncr-sysv4 && exit 0 ;;
-    m680[234]0:LynxOS:2.[23]*:*)
-	echo m68k-lynx-lynxos${UNAME_RELEASE}
+    m68*:LynxOS:2.*:*)
+	echo m68k-unknown-lynxos${UNAME_RELEASE}
 	exit 0 ;;
     mc68030:UNIX_System_V:4.*:*)
 	echo m68k-atari-sysv4
 	exit 0 ;;
-    i[34]86:LynxOS:2.[23]*:*)
-	echo i386-lynx-lynxos${UNAME_RELEASE}
+    i?86:LynxOS:2.*:*)
+	echo i386-unknown-lynxos${UNAME_RELEASE}
+	exit 0 ;;
+    TSUNAMI:LynxOS:2.*:*)
+	echo sparc-unknown-lynxos${UNAME_RELEASE}
 	exit 0 ;;
-    TSUNAMI:LynxOS:2.[23]*:*)
-	echo sparc-lynx-lynxos${UNAME_RELEASE}
+    rs6000:LynxOS:2.*:* | PowerPC:LynxOS:2.*:*)
+	echo rs6000-unknown-lynxos${UNAME_RELEASE}
 	exit 0 ;;
-    rs6000:LynxOS:2.[23]*:*)
-	echo rs6000-lynx-lynxos${UNAME_RELEASE}
+    SM[BE]S:UNIX_SV:*:*)
+	echo mips-dde-sysv${UNAME_RELEASE}
 	exit 0 ;;
     RM*:SINIX-*:*:*)
 	echo mips-sni-sysv4
@@ -449,16 +529,29 @@
 		echo ns32k-sni-sysv
 	fi
 	exit 0 ;;
+    *:UNIX_System_V:4*:FTX*)
+	# From Gerald Hewes <hewes@openmarket.com>.
+	# How about differentiating between stratus architectures? -djm
+	echo hppa1.1-stratus-sysv4
+	exit 0 ;;
+    *:*:*:FTX*)
+	# From seanf@swdc.stratus.com.
+	echo i860-stratus-sysv4
+	exit 0 ;;
     mc68*:A/UX:*:*)
 	echo m68k-apple-aux${UNAME_RELEASE}
 	exit 0 ;;
-    R3000:*System_V*:*:*)
+    R3000:*System_V*:*:* | R4000:UNIX_SYSV:*:*)
 	if [ -d /usr/nec ]; then
 	        echo mips-nec-sysv${UNAME_RELEASE}
 	else
 	        echo mips-unknown-sysv${UNAME_RELEASE}
 	fi
         exit 0 ;;
+    PENTIUM:CPunix:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
+                           # says <Richard.M.Bartel@ccMail.Census.GOV>
+        echo i586-unisys-sysv4
+        exit 0 ;;
 esac
 
 #echo '(No uname command or uname output not recognized.)' 1>&2
@@ -502,7 +595,7 @@
 #endif
   int version;
   version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null`;
-  printf ("%s-next-nextstep%s\n", __ARCHITECTURE__,  version==2 ? "2" : "3");
+  printf ("%s-next-nextstep%d\n", __ARCHITECTURE__, version);
   exit (0);
 #endif
 
@@ -519,7 +612,7 @@
 #endif
 
 #if defined (__386BSD__)
-  printf ("i386-unknown-bsd\n"); exit (0);
+  printf ("i386-pc-bsd\n"); exit (0);
 #endif
 
 #if defined (sequent)
Index: config/config.sub
diff -u krb5/config/config.sub:1.1.1.1 krb5/config/config.sub:1.2
@@ -1,9 +1,9 @@
-#!/bin/sh
+#! /bin/sh
 # Configuration validation subroutine script, version 1.1.
-#   Copyright (C) 1991, 1992, 1993, 1994 Free Software Foundation, Inc.
+#   Copyright (C) 1991, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
 # This file is (in principle) common to ALL GNU software.
 # The presence of a machine in this file suggests that SOME GNU software
-# can handle that machine.  It does not imply ALL GNU software can. 
+# can handle that machine.  It does not imply ALL GNU software can.
 #
 # This file is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -17,7 +17,8 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with this program; if not, write to the Free Software
-# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+# Foundation, Inc., 59 Temple Place - Suite 330,
+# Boston, MA 02111-1307, USA.
 
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
@@ -40,8 +41,19 @@
 # The goal of this file is to map all the various variations of a given
 # machine specification into a single specification in the form:
 #	CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
+# or in some cases, the newer four-part form:
+#	CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
 # It is wrong to echo any other type of specification.
 
+if [ x$1 = x ]
+then
+	echo Configuration name missing. 1>&2
+	echo "Usage: $0 CPU-MFR-OPSYS" 1>&2
+	echo "or     $0 ALIAS" 1>&2
+	echo where ALIAS is a recognized configuration type. 1>&2
+	exit 1
+fi
+
 # First pass through any local machine types.
 case $1 in
 	*local*)
@@ -52,11 +64,21 @@
 	;;
 esac
 
-# Separate what the user gave into CPU-COMPANY and OS (if any).
-basic_machine=`echo $1 | sed 's/-[^-]*$//'`
-if [ $basic_machine != $1 ]
-then os=`echo $1 | sed 's/.*-/-/'`
-else os=; fi
+# Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
+# Here we must recognize all the valid KERNEL-OS combinations.
+maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
+case $maybe_os in
+  linux-gnu*)
+    os=-$maybe_os
+    basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
+    ;;
+  *)
+    basic_machine=`echo $1 | sed 's/-[^-]*$//'`
+    if [ $basic_machine != $1 ]
+    then os=`echo $1 | sed 's/.*-/-/'`
+    else os=; fi
+    ;;
+esac
 
 ### Let's recognize common machines as not being operating systems so
 ### that things like config.sub decstation-3100 work.  We also
@@ -71,40 +93,45 @@
 	-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \
 	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
 	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
-	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp )
+	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
+	-apple)
 		os=
 		basic_machine=$1
 		;;
 	-hiux*)
 		os=-hiuxwe2
 		;;
+	-sco5)
+		os=sco3.2v5
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
 	-sco4)
 		os=-sco3.2v4
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-unknown/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-sco3.2.[4-9]*)
 		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-unknown/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-sco3.2v[4-9]*)
 		# Don't forget version if it is 3.2v4 or newer.
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-unknown/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-sco*)
 		os=-sco3.2v2
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-unknown/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-isc)
 		os=-isc2.2
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-unknown/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-clix*)
 		basic_machine=clipper-intergraph
 		;;
 	-isc*)
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-unknown/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
-	-lynx)
+	-lynx*)
 		os=-lynxos
 		;;
 	-ptx*)
@@ -113,33 +140,44 @@
 	-windowsnt*)
 		os=`echo $os | sed -e 's/windowsnt/winnt/'`
 		;;
+	-psos*)
+		os=-psos
+		;;
 esac
 
 # Decode aliases for certain CPU-COMPANY combinations.
 case $basic_machine in
 	# Recognize the basic CPU types without company name.
 	# Some are omitted here because they have special meanings below.
-	tahoe | i[345]86 | i860 | m68k | m68000 | m88k | ns32k | arm | pyramid \
-		| tron | a29k | 580 | i960 | h8300 | hppa1.0 | hppa1.1 \
-		| alpha | we32k | ns16k | clipper | sparclite | i370 | sh \
-		| powerpc | sparc64 | 1750a | dsp16xx | mips64 | mipsel \
-		| pdp11 | mips64el | mips64orion | mips64orionel )
+	tahoe | i860 | m68k | m68000 | m88k | ns32k | arm \
+		| arme[lb] | pyramid \
+		| tron | a29k | 580 | i960 | h8300 | hppa | hppa1.0 | hppa1.1 \
+		| alpha | we32k | ns16k | clipper | i370 | sh \
+		| powerpc | powerpcle | 1750a | dsp16xx | mips64 | mipsel \
+		| pdp11 | mips64el | mips64orion | mips64orionel \
+		| sparc | sparclet | sparclite | sparc64)
 		basic_machine=$basic_machine-unknown
 		;;
+	# We use `pc' rather than `unknown'
+	# because (1) that's what they normally are, and
+	# (2) the word "unknown" tends to confuse beginning users.
+	i[3456]86)
+	  basic_machine=$basic_machine-pc
+	  ;;
 	# Object if more than one company name word.
 	*-*-*)
 		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
 		exit 1
 		;;
 	# Recognize the basic CPU types with company name.
-	vax-* | tahoe-* | i[345]86-* | i860-* | m68k-* | m68000-* | m88k-* \
+	vax-* | tahoe-* | i[3456]86-* | i860-* | m68k-* | m68000-* | m88k-* \
 	      | sparc-* | ns32k-* | fx80-* | arm-* | c[123]* \
-	      | mips-* | pyramid-* | tron-* | a29k-* | romp-* | rs6000-* \
+	      | mips-* | pyramid-* | tron-* | a29k-* | romp-* | rs6000-* | power-* \
 	      | none-* | 580-* | cray2-* | h8300-* | i960-* | xmp-* | ymp-* \
-	      | hppa1.0-* | hppa1.1-* | alpha-* | we32k-* | cydra-* | ns16k-* \
+	      | hppa-* | hppa1.0-* | hppa1.1-* | alpha-* | we32k-* | cydra-* | ns16k-* \
 	      | pn-* | np1-* | xps100-* | clipper-* | orion-* | sparclite-* \
-	      | pdp11-* | sh-* | powerpc-* | sparc64-* | mips64-* | mipsel-* \
-	      | mips64el-* | mips64orion-* | mips64orionel-* )
+	      | pdp11-* | sh-* | powerpc-* | powerpcle-* | sparc64-* | mips64-* | mipsel-* \
+	      | mips64el-* | mips64orion-* | mips64orionel-* | f301-*)
 		;;
 	# Recognize the various machine names and aliases which stand
 	# for a CPU type and a company and sometimes even an OS.
@@ -178,6 +216,10 @@
 		basic_machine=m68k-apollo
 		os=-sysv
 		;;
+	aux)
+		basic_machine=m68k-apple
+		os=-aux
+		;;
 	balance)
 		basic_machine=ns32k-sequent
 		os=-dynix
@@ -210,6 +252,10 @@
 		basic_machine=cray2-cray
 		os=-unicos
 		;;
+	[ctj]90-cray)
+		basic_machine=c90-cray
+		os=-unicos
+		;;
 	crds | unos)
 		basic_machine=m68k-crds
 		;;
@@ -291,25 +337,28 @@
 	hp9k8[0-9][0-9] | hp8[0-9][0-9])
 		basic_machine=hppa1.0-hp
 		;;
+	hppa-next)
+		os=-nextstep3
+		;;
 	i370-ibm* | ibm*)
 		basic_machine=i370-ibm
 		os=-mvs
 		;;
 # I'm not sure what "Sysv32" means.  Should this be sysv3.2?
-	i[345]86v32)
-		basic_machine=`echo $1 | sed -e 's/86.*/86-unknown/'`
+	i[3456]86v32)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
 		os=-sysv32
 		;;
-	i[345]86v4*)
-		basic_machine=`echo $1 | sed -e 's/86.*/86-unknown/'`
+	i[3456]86v4*)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
 		os=-sysv4
 		;;
-	i[345]86v)
-		basic_machine=`echo $1 | sed -e 's/86.*/86-unknown/'`
+	i[3456]86v)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
 		os=-sysv
 		;;
-	i[345]86sol2)
-		basic_machine=`echo $1 | sed -e 's/86.*/86-unknown/'`
+	i[3456]86sol2)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
 		os=-solaris2
 		;;
 	iris | iris4d)
@@ -407,17 +456,47 @@
         pc532 | pc532-*)
 		basic_machine=ns32k-pc532
 		;;
-	pentium-*)
-		# We will change tis to say i586 once there has been
-		# time for various packages to start to recognize that.
-		basic_machine=i486-`echo $basic_machine | sed 's/^[^-]*-//'`
+	pentium | p5)
+		basic_machine=i586-intel
+		;;
+	pentiumpro | p6)
+		basic_machine=i686-intel
+		;;
+	pentium-* | p5-*)
+		basic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentiumpro-* | p6-*)
+		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	k5)
+		# We don't have specific support for AMD's K5 yet, so just call it a Pentium
+		basic_machine=i586-amd
+		;;
+	nexen)
+		# We don't have specific support for Nexgen yet, so just call it a Pentium
+		basic_machine=i586-nexgen
 		;;
 	pn)
 		basic_machine=pn-gould
 		;;
+	power)	basic_machine=rs6000-ibm
+		;;
+	ppc)	basic_machine=powerpc-unknown
+	        ;;
+	ppc-*)	basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ppcle | powerpclittle | ppc-le | powerpc-little)
+		basic_machine=powerpcle-unknown
+	        ;;
+	ppcle-* | powerpclittle-*)
+		basic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
 	ps2)
 		basic_machine=i386-ibm
 		;;
+	rm[46]00)
+		basic_machine=mips-siemens
+		;;
 	rtpc | rtpc-*)
 		basic_machine=romp-ibm
 		;;
@@ -462,6 +541,10 @@
 		basic_machine=sparc-sun
 		os=-sunos4
 		;;
+	sun4sol2)
+		basic_machine=sparc-sun
+		os=-solaris2
+		;;
 	sun3 | sun3-*)
 		basic_machine=m68k-sun
 		;;
@@ -478,6 +561,10 @@
 	tower | tower-32)
 		basic_machine=m68k-ncr
 		;;
+	udi29k)
+		basic_machine=a29k-amd
+		os=-udi
+		;;
 	ultra3)
 		basic_machine=a29k-nyu
 		os=-sym1
@@ -490,6 +577,9 @@
 		basic_machine=vax-dec
 		os=-vms
 		;;
+       vpp*|vx|vx-*)
+               basic_machine=f301-fujitsu
+               ;;
 	vxworks960)
 		basic_machine=i960-wrs
 		os=-vxworks
@@ -498,6 +588,10 @@
 		basic_machine=m68k-wrs
 		os=-vxworks
 		;;
+	vxworks29k)
+		basic_machine=a29k-wrs
+		os=-vxworks
+		;;
 	xmp)
 		basic_machine=xmp-cray
 		os=-unicos
@@ -565,6 +659,8 @@
 if [ x"$os" != x"" ]
 then
 case $os in
+        # First match some system type aliases
+        # that might get confused with valid system types.
 	# -solaris* is a basic system type, with this one exception.
 	-solaris1 | -solaris1.*)
 		os=`echo $os | sed -e 's|solaris1|sunos4|'`
@@ -572,22 +668,32 @@
 	-solaris)
 		os=-solaris2
 		;;
+	-unixware* | svr4*)
+		os=-sysv4
+		;;
 	-gnu/linux*)
-		os=`echo $os | sed -e 's|gnu/linux|linux|'`
+		os=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`
 		;;
 	# First accept the basic system types.
 	# The portable systems comes first.
-	# Each alternative must end in a *, to match a version number.
+	# Each alternative MUST END IN A *, to match a version number.
 	# -sysv* is not here because it comes later, after sysvr4.
 	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
-	      | -vms* | -sco* | -esix* | -isc* | -aix* | -sunos | -sunos[345]* \
+	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -sunos | -sunos[34]*\
 	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -solaris* | -sym* \
-	      | -amigados* | -msdos* | -newsos* | -unicos* | -aos* \
-	      | -nindy* | -vxworks* | -ebmon* | -hms* | -mvs* | -clix* \
-	      | -riscos* | -linux* | -uniplus* | -iris* | -rtu* | -xenix* \
-	      | -hiux* | -386bsd* | -netbsd* | -freebsd* | -riscix* \
+	      | -amigados* | -msdos* | -newsos* | -unicos* | -aof* | -aos* \
+	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
+	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
+	      | -hiux* | -386bsd* | -netbsd* | -openbsd* | -freebsd* | -riscix* \
 	      | -lynxos* | -bosx* | -nextstep* | -cxux* | -aout* | -elf* \
-	      | -ptx* | -coff* | -winnt*)
+	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
+	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
+	      | -cygwin32* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
+	      | -linux-gnu* | -uxpv*)
+	# Remember, each alternative MUST END IN *, to match a version number.
+		;;
+	-linux*)
+		os=`echo $os | sed -e 's|linux|linux-gnu|'`
 		;;
 	-sunos5*)
 		os=`echo $os | sed -e 's|sunos5|solaris2|'`
@@ -613,6 +719,16 @@
 	-ctix* | -uts*)
 		os=-sysv
 		;;
+	-ns2 )
+	        os=-nextstep2
+		;;
+	# Preserve the version number of sinix5.
+	-sinix5.*)
+		os=`echo $os | sed -e 's|sinix|sysv|'`
+		;;
+	-sinix*)
+		os=-sysv4
+		;;
 	-triton*)
 		os=-sysv3
 		;;
@@ -659,12 +775,18 @@
 	*-acorn)
 		os=-riscix1.2
 		;;
+	arm*-semi)
+		os=-aout
+		;;
         pdp11-*)
 		os=-none
 		;;
 	*-dec | vax-*)
 		os=-ultrix4.2
 		;;
+	m68*-apollo)
+		os=-domain
+		;;
 	i386-sun)
 		os=-sunos4.0.2
 		;;
@@ -707,6 +829,9 @@
 	m88k-omron*)
 		os=-luna
 		;;
+	*-next )
+		os=-nextstep
+		;;
 	*-sequent)
 		os=-ptx
 		;;
@@ -734,9 +859,15 @@
         *-sgi)
 		os=-irix
 		;;
+        *-siemens)
+		os=-sysv4
+		;;
 	*-masscomp)
 		os=-rtu
 		;;
+	f301-fujitsu)
+		os=-uxpv
+		;;
 	*)
 		os=-none
 		;;
@@ -755,9 +886,6 @@
 			-sunos*)
 				vendor=sun
 				;;
-			-lynxos*)
-				vendor=lynx
-				;;
 			-aix*)
 				vendor=ibm
 				;;
@@ -784,6 +912,12 @@
 				;;
 			-ptx*)
 				vendor=sequent
+				;;
+			-vxsim* | -vxworks*)
+				vendor=wrs
+				;;
+			-aux*)
+				vendor=apple
 				;;
 		esac
 		basic_machine=`echo $basic_machine | sed "s/unknown/$vendor/"`
Index: include/krb5.hin
diff -u krb5/include/krb5.hin:1.1.1.1 krb5/include/krb5.hin:1.5
@@ -518,8 +518,8 @@
  * Here's the stuff for the checksum switch:
  */
 #define krb5_checksum_size(context, ctype)  (krb5_cksumarray[ctype]->checksum_length)
-#define krb5_calculate_checksum(context, ctype, in, in_length, seed, seed_length, outcksum) krb5_x(((*krb5_cksumarray[ctype]->sum_func)),(in, in_length, seed, seed_length, outcksum))
-#define krb5_verify_checksum(context, ctype, cksum, in, in_length, seed, seed_length) krb5_x((*krb5_cksumarray[ctype]->sum_verf_func),(cksum, in, in_length, seed, seed_length))
+#define krb5_calculate_checksum(context, ctype, in, in_length, seed, seed_length, outcksum) krb5_x(((krb5_cksumarray[ctype]->sum_func)),(in, in_length, seed, seed_length, outcksum))
+#define krb5_verify_checksum(context, ctype, cksum, in, in_length, seed, seed_length) krb5_x((krb5_cksumarray[ctype]->sum_verf_func),(cksum, in, in_length, seed, seed_length))
 
 /*
  * encryption routine prototypes
@@ -720,6 +720,7 @@
 #define KRB5_LRQ_ONE_LAST_RENEWAL	(-4)
 #define KRB5_LRQ_ALL_LAST_REQ		5
 #define KRB5_LRQ_ONE_LAST_REQ		(-5)
+#define KRB5_LRQ_PW_EXPTIME		6
 
 /* PADATA types */
 #define KRB5_PADATA_NONE                0
@@ -757,6 +758,14 @@
 #define	KRB5_AUTHDATA_OSF_DCE	64
 #define KRB5_AUTHDATA_SESAME	65
 
+/* password change constants */
+
+#define KRB5_KPASSWD_SUCCESS		0
+#define KRB5_KPASSWD_MALFORMED		1
+#define KRB5_KPASSWD_HARDERROR		2
+#define KRB5_KPASSWD_AUTHERROR		3
+#define KRB5_KPASSWD_SOFTERROR		4
+
 /*
  * end "proto.h"
  */
@@ -2035,7 +2044,20 @@
 /*
  * begin stuff from libos.h
  */
-
+void krb5_appdefault_boolean
+	KRB5_PROTOTYPE((krb5_context,
+			const char *,
+			const krb5_data *,
+			const char *,
+			int,
+			int * ));
+void krb5_appdefault_string
+	KRB5_PROTOTYPE((krb5_context,
+			const char *,
+			const krb5_data *,
+			const char *,
+			const char *,
+			char ** ));
 krb5_error_code krb5_read_password
 	KRB5_PROTOTYPE((krb5_context,
 			const char *,
Index: include/krb5/Makefile.in
diff -u krb5/include/krb5/Makefile.in:1.1.1.1 krb5/include/krb5/Makefile.in:1.2
@@ -27,9 +27,13 @@
 install::
 SYSCONFDIR = @sysconfdir@
 LOCALSTATEDIR = @localstatedir@
+BINDIR = @bindir@
+SBINDIR = @sbindir@
 PROCESS_REPLACE = -e "s+@KRB5RCTMPDIR+$(KRB5RCTMPDIR)+" \
 		  -e "s+@PREFIX+$(INSTALL_PREFIX)+" \
 		  -e "s+@EXEC_PREFIX+$(INSTALL_EXEC_PREFIX)+" \
+		  -e "s+@BINDIR+$(BINDIR)+" \
+		  -e "s+@SBINDIR+$(SBINDIR)+" \
 	-e 's+@LOCALSTATEDIR+$(LOCALSTATEDIR)+' \
 	-e 's+@SYSCONFDIR+$(SYSCONFDIR)+' 
 
Index: include/krb5/configure.in
diff -u krb5/include/krb5/configure.in:1.1.1.1 krb5/include/krb5/configure.in:1.2
@@ -99,7 +99,7 @@
 AC_MSG_CHECKING([for replay cache directory])
 AC_CACHE_VAL(krb5_cv_sys_rcdir,
 [
-for t_dir in /usr/tmp /var/usr/tmp /var/tmp /tmp ; do
+for t_dir in /var/tmp /usr/tmp /var/usr/tmp /tmp ; do
 	test -d $t_dir || continue
 	krb5_cv_sys_rcdir=$t_dir
 	break
Index: include/krb5/stock/osconf.h
diff -u krb5/include/krb5/stock/osconf.h:1.1.1.1 krb5/include/krb5/stock/osconf.h:1.4
@@ -58,8 +58,8 @@
 #define	DEFAULT_KDC_ENCTYPE	ENCTYPE_DES_CBC_CRC
 #define KDCRCACHE		"dfl:krb5kdc_rcache"
 
-#define KDC_PORTNAME		"kerberos" /* for /etc/services or equiv. */
-#define KDC_SECONDARY_PORTNAME	"kerberos-sec" /* For backwards */
+#define KDC_PORTNAME		"kerberos5" /* for /etc/services or equiv. */
+#define KDC_SECONDARY_PORTNAME	"kerberos" /* For backwards */
 					    /* compatibility with */
 					    /* port 750 clients */
 
@@ -68,6 +68,8 @@
 
 #define DEFAULT_KDC_PORTLIST	"88,750"
 
+#define DEFAULT_KPASSWD_PORT	464
+
 /*
  * Defaults for the KADM5 admin system.
  */
@@ -83,8 +85,8 @@
 #define RCTMPDIR	"@KRB5RCTMPDIR"	/* directory to store replay caches */
 
 #define KRB5_PATH_TTY	"/dev/tty"
-#define KRB5_PATH_LOGIN	"@EXEC_PREFIX/sbin/login.krb5"
-#define KRB5_PATH_RLOGIN "@EXEC_PREFIX/bin/rlogin"
+#define KRB5_PATH_LOGIN	"@SBINDIR/login.krb5"
+#define KRB5_PATH_RLOGIN "@BINDIR/rlogin"
 
 #define KRB5_ENV_CCNAME	"KRB5CCNAME"
 
@@ -106,8 +108,8 @@
 
 #define KPROP_DEFAULT_FILE "@LOCALSTATEDIR/krb5kdc/slave_datatrans"
 #define KPROPD_DEFAULT_FILE "@LOCALSTATEDIR/krb5kdc/from_master"
-#define KPROPD_DEFAULT_KDB5_UTIL "@PREFIX/sbin/kdb5_util"
-#define KPROPD_DEFAULT_KDB5_EDIT "@PREFIX/sbin/kdb5_edit"
+#define KPROPD_DEFAULT_KDB5_UTIL "@SBINDIR/kdb5_util"
+#define KPROPD_DEFAULT_KDB5_EDIT "@SBINDIR/kdb5_edit"
 #define KPROPD_DEFAULT_KRB_DB DEFAULT_KDB_FILE
 #define KPROPD_ACL_FILE "@LOCALSTATEDIR/krb5kdc/kpropd.acl"
 
Index: kadmin/cli/kadmin.c
diff -u krb5/kadmin/cli/kadmin.c:1.1.1.1 krb5/kadmin/cli/kadmin.c:1.2
@@ -709,6 +709,22 @@
 	    ++*randkey;
 	    continue;
 	}
+	if (strlen(argv[i]) == 13 &&
+	    !strcmp("-lastpwchange", argv[i])) {
+	    if (++i > argc - 2)
+		return -1;
+	    else {
+		date = get_date(argv[i], NULL);
+ 		if (date == (time_t)-1) {
+		     fprintf(stderr, "Invalid date specification \"%s\".\n",
+			     argv[i]);
+		     return -1;
+ 		}
+		oprinc->last_pwd_change = date;
+		*mask |= KADM5_LAST_PWD_CHANGE;
+		continue;
+	    }
+	}
 	for (j = 0; j < sizeof (flags) / sizeof (struct pflag); j++) {
 	    if (strlen(argv[i]) == flags[j].flaglen + 1 &&
 		!strcmp(flags[j].flagname,
@@ -762,7 +778,7 @@
 {
      fprintf(stderr, "usage: %s [options] principal\n", func);
      fprintf(stderr, "\toptions are:\n");
-     fprintf(stderr, "\t\t[-expire expdate] [-pwexpire pwexpdate] [-maxlife maxtixlife]\n\t\t[-kvno kvno] [-policy policy] [-clearpolicy]\n\t\t[-maxrenewlife maxrenewlife] [{+|-}attribute]\n");
+     fprintf(stderr, "\t\t[-expire expdate] [-pwexpire pwexpdate] [-maxlife maxtixlife]\n\t\t[-kvno kvno] [-policy policy] [-clearpolicy]\n\t\t[-maxrenewlife maxrenewlife] [-lastpwchange pwchangedate]\n\t\t[{+|-}attribute]\n");
      fprintf(stderr, "\tattributes are:\n");
      fprintf(stderr, "%s%s%s",
 	     "\t\tallow_postdated allow_forwardable allow_tgs_req allow_renewable\n",
Index: kadmin/dbutil/configure.in
diff -u krb5/kadmin/dbutil/configure.in:1.1.1.1 krb5/kadmin/dbutil/configure.in:1.2
@@ -12,5 +12,5 @@
 USE_GSSAPI_LIBRARY
 KRB5_LIBRARIES
 V5_USE_SHARED_LIB
-AC_CHECK_HEADERS(krb_db.h kdc.h) dnl 
+AC_CHECK_HEADERS(krb_db.h kdc.h memory.h) dnl 
 V5_AC_OUTPUT_MAKEFILE
Index: kadmin/dbutil/dump.c
diff -u krb5/kadmin/dbutil/dump.c:1.1.1.1 krb5/kadmin/dbutil/dump.c:1.2
@@ -568,7 +568,7 @@
     char		*name;
     krb5_tl_data	*tlp;
     krb5_key_data	*kdata;
-    int			counter, skip, i, j;
+    int			counter, i, j;
 
     /* Initialize */
     arg = (struct dump_args *) ptr;
@@ -612,28 +612,15 @@
 	/*
 	 * Make sure that the tagged list is reasonably correct.
 	 */
-	counter = skip = 0;
-	for (tlp = entry->tl_data; tlp; tlp = tlp->tl_data_next) {
-	     /*
-	      * don't dump tl data types we know aren't understood by
-	      * earlier revisions [krb5-admin/89]
-	      */
-	     switch (tlp->tl_data_type) {
-	     case KRB5_TL_KADM_DATA:
-		  skip++;
-		  break;
-	     default:
-		  counter++;
-		  break;
-	     }
-	}
-	
-	if (counter + skip == entry->n_tl_data) {
+	counter = 0;
+	for (tlp = entry->tl_data; tlp; tlp = tlp->tl_data_next)
+	    counter++;
+	if (counter == entry->n_tl_data) {
 	    /* Pound out header */
 	    fprintf(arg->ofile, "%d\t%d\t%d\t%d\t%d\t%s\t",
 		    (int) entry->len,
 		    strlen(name),
-		    counter,
+		    (int) entry->n_tl_data,
 		    (int) entry->n_key_data,
 		    (int) entry->e_length,
 		    name);
@@ -648,9 +635,6 @@
 		    entry->fail_auth_count);
 	    /* Pound out tagged data. */
 	    for (tlp = entry->tl_data; tlp; tlp = tlp->tl_data_next) {
-		if (tlp->tl_data_type == KRB5_TL_KADM_DATA)
-		     continue; /* see above, [krb5-admin/89] */
-
 		fprintf(arg->ofile, "%d\t%d\t",
 			(int) tlp->tl_data_type,
 			(int) tlp->tl_data_length);
@@ -697,8 +681,7 @@
 	}
 	else {
 	    fprintf(stderr, sdump_tl_inc_err,
-		    arg->programname, name, counter+skip,
-		    (int) entry->n_tl_data); 
+		    arg->programname, name, counter, (int) entry->n_tl_data);
 	    retval = EINVAL;
 	}
     }
Index: kadmin/dbutil/ovload.c
diff -u krb5/kadmin/dbutil/ovload.c:1.1.1.1 krb5/kadmin/dbutil/ovload.c:1.2
@@ -1,7 +1,9 @@
 #include    <unistd.h>
 #include    <string.h>
 #include    <stdlib.h>
+#ifdef HAVE_MEMORY_H
 #include    <memory.h>
+#endif
 
 #include    <kadm5/adb.h>
 #include    "import_err.h"
Index: kadmin/server/Makefile.in
diff -u krb5/kadmin/server/Makefile.in:1.1.1.1 krb5/kadmin/server/Makefile.in:1.2
@@ -1,7 +1,7 @@
 CFLAGS = $(CCOPTS) $(DEFS) $(LOCALINCLUDE)
 
 PROG = kadmind
-OBJS = kadm_rpc_svc.o server_stubs.o ovsec_kadmd.o misc.o server_glue_v1.o
+OBJS = kadm_rpc_svc.o server_stubs.o ovsec_kadmd.o schpw.o misc.o server_glue_v1.o
 
 all:: $(PROG)
 
Index: kadmin/server/configure.in
diff -u krb5/kadmin/server/configure.in:1.1.1.1 krb5/kadmin/server/configure.in:1.2
@@ -7,6 +7,7 @@
 dnl CHECK_SETJMP
 dnl CHECK_WAIT_TYPE
 dnl ET_RULES
+AC_CHECK_HEADERS(memory.h)
 USE_KADMSRV_LIBRARY
 USE_GSSRPC_LIBRARY
 USE_GSSAPI_LIBRARY
Index: kadmin/server/kadm_rpc_svc.c
diff -u krb5/kadmin/server/kadm_rpc_svc.c:1.1.1.2 krb5/kadmin/server/kadm_rpc_svc.c:1.3
@@ -5,6 +5,14 @@
  * $Source$
  * 
  * $Log$
+ * Revision 1.3  1997/11/03 22:13:52  kenh
+ * Fix up conflicts from Release 1.0.2 import.
+ *
+ * Revision 1.2  1997/09/18 20:37:10  vwelch
+ * ConvexOS Port.
+ *
+ * Revision 1.1.1.1  1997/06/02 21:55:18  kenh
+ * Initial import of R1.0 from MIT.
  * Revision 1.1.1.2  1997/11/03 21:33:02  kenh
  * Import of Kerberos 5, Release 1.0.2
  *
@@ -77,7 +85,9 @@
 #include <stdio.h>
 #include <rpc/rpc.h>
 #include <syslog.h>
+#ifdef HAVE_MEMORY_H
 #include <memory.h>
+#endif
 #include <kadm5/kadm_rpc.h>
 #include <krb5.h>
 #include <kadm5/admin.h>
Index: kadmin/server/ovsec_kadmd.c
diff -u krb5/kadmin/server/ovsec_kadmd.c:1.1.1.2 krb5/kadmin/server/ovsec_kadmd.c:1.3
@@ -76,7 +76,14 @@
 void log_badauth_display_status(char *msg, OM_uint32 major, OM_uint32 minor);
 void log_badauth_display_status_1(char *m, OM_uint32 code, int type,
 				  int rec);
-	
+
+int schpw;
+void do_schpw(int s, kadm5_config_params *params);
+kadm5_config_params params;
+krb5_error_code process_chpw_request(krb5_context context, void *server_handle,
+				     char *realm, int s, krb5_keytab keytab,
+				     struct sockaddr_in *sin,
+				     krb5_data *req, krb5_data *rep);
 
 /*
  * Function: usage
@@ -115,7 +122,6 @@
      int s;
      short port = 0;
      auth_gssapi_name names[4];
-     kadm5_config_params params;
 
      names[0].name = names[1].name = names[2].name = names[3].name = NULL;
      names[0].type = names[1].type = names[2].type = names[3].type =
@@ -222,6 +228,16 @@
 	  exit(1);
      }
 
+     if ((schpw = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
+	  krb5_klog_syslog(LOG_ERR, "Cannot create simple chpw socket: %s",
+			  error_message(errno));
+	  fprintf(stderr, "Cannot create simple chpw socket: %s",
+		  error_message(errno));
+	  kadm5_destroy(global_server_handle);
+	  krb5_klog_close();	  
+	  exit(1);
+     }
+
 #ifdef SO_REUSEADDR
      /* the old admin server turned on SO_REUSEADDR for non-default
 	port numbers.  this was necessary, on solaris, for the tests
@@ -248,6 +264,19 @@
 	     krb5_klog_close();	  
 	     exit(1);
 	 }
+	 if (setsockopt(schpw,
+			SOL_SOCKET,
+			SO_REUSEADDR,
+			(char *) &allowed,
+			sizeof(allowed)) < 0) {
+	     krb5_klog_syslog(LOG_ERR, "Cannot set SO_REUSEADDR on simple "
+			      "chpw socket: %s", error_message(errno));
+	     fprintf(stderr, "Cannot set SO_REUSEADDR on simple "
+		     "chpw socket: %s", error_message(errno));
+	     kadm5_destroy(global_server_handle);
+	     krb5_klog_close();	  
+	     exit(1);
+	 }
      }
 #endif /* SO_REUSEADDR */
      if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
@@ -283,7 +312,40 @@
 	  krb5_klog_close();	  
 	  exit(1);
      }
+
+     memset(&addr, 0, sizeof(addr));
+     addr.sin_family = AF_INET;
+     addr.sin_addr.s_addr = INADDR_ANY;
+     /* XXX */
+     addr.sin_port = htons(params.kpasswd_port);
      
+     if (bind(schpw, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+	  int oerrno = errno;
+	  fprintf(stderr, "%s: Cannot bind socket.\n", whoami);
+	  fprintf(stderr, "bind: %s\n", error_message(oerrno));
+	  errno = oerrno;
+	  krb5_klog_syslog(LOG_ERR, "Cannot bind simple chpw socket: %s",
+			   error_message(errno));
+	  if(oerrno == EADDRINUSE) {
+	       char *w = strrchr(whoami, '/');
+	       if (w) {
+		    w++;
+	       }
+	       else {
+		    w = whoami;
+	       }
+	       fprintf(stderr,
+"This probably means that another %s process is already\n"
+"running, or that another program is using the server port (number %d).\n"
+"If another %s is already running, you should kill it before\n"
+"restarting the server.\n",
+		       w, ntohs(addr.sin_port), w, w, w);
+	  }
+	  kadm5_destroy(global_server_handle);
+	  krb5_klog_close();	  
+	  exit(1);
+     }
+
      transp = svctcp_create(s, 0, 0);
      if(transp == NULL) {
 	  fprintf(stderr, "%s: Cannot create RPC service.\n", whoami);
@@ -429,6 +491,7 @@
 	  timeout.tv_sec = TIMEOUT;
 	  timeout.tv_usec = 0;
 	  rfd = svc_fdset;
+	  FD_SET(schpw, &rfd);
 	  switch(select(sz, (fd_set *) &rfd, NULL, NULL, &timeout)) {
 	  case -1:
 	       if(errno == EINTR)
@@ -439,7 +502,10 @@
 	       reset_db();
 	       break;
 	  default:
-	       svc_getreqset(&rfd);
+	       if (FD_ISSET(schpw, &rfd))
+		    do_schpw(schpw, &params);
+	       else 
+	            svc_getreqset(&rfd);
 	  }
      }
 }
@@ -762,4 +828,97 @@
 	  if (!msg_ctx)
 	       break;
      }
+}
+
+void do_schpw(int s1, kadm5_config_params *params)
+{
+     krb5_error_code ret;
+     /* XXX buffer = ethernet mtu */
+     char req[1500];
+     int len;
+     struct sockaddr_in from;
+     int fromlen;
+     krb5_keytab kt;
+     krb5_data reqdata, repdata;
+     int s2;
+
+     fromlen = sizeof(from);
+     if ((len = recvfrom(s1, req, sizeof(req), 0, (struct sockaddr *)&from,
+			 &fromlen)) < 0) {
+	  krb5_klog_syslog(LOG_ERR, "chpw: Couldn't receive request from %s: "
+			   "%s", inet_ntoa(from.sin_addr),
+			   error_message(errno));
+	  return;
+     }
+
+     if (ret = krb5_kt_resolve(context, params->admin_keytab, &kt)) {
+	  krb5_klog_syslog(LOG_ERR, "chpw: Couldn't open admin keytab: %s: %s",
+			   inet_ntoa(from.sin_addr), error_message(ret));
+	  return;
+     }
+
+     reqdata.length = len;
+     reqdata.data = req;
+
+    /* this is really obscure.  s1 is used for all communications.  it
+       is left unconnected in case the server is multihomed and routes
+       are asymmetric.  s2 is connected to resolve routes and get
+       addresses.  this is the *only* way to get proper addresses for
+       multihomed hosts if routing is asymmetric.
+
+       A related problem in the server, but not the client, is that
+       many os's have no way to disconnect a connected udp socket, so
+       the s2 socket needs to be closed and recreated for each
+       request.  The s1 socket must not be closed, or else queued
+       requests will be lost.
+
+       A "naive" client implementation (one socket, no connect,
+       hostname resolution to get the local ip addr) will work and
+       interoperate if the client is single-homed. */
+
+     if ((s2 = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
+	  krb5_klog_syslog(LOG_ERR, "main: cannot create connecting socket: %s",
+			   error_message(errno));
+	  fprintf(stderr, "Cannot create connecting socket: %s",
+		  error_message(errno));
+	  kadm5_destroy(global_server_handle);
+	  krb5_klog_close();
+	  exit(1);
+     }
+
+     if (connect(s2, (struct sockaddr *) &from, sizeof(from)) < 0) {
+	  krb5_klog_syslog(LOG_ERR, "chpw: Couldn't connect to client %s: %s",
+			   inet_ntoa(from.sin_addr), error_message(errno));
+	  return;
+     }
+
+     if (ret = process_chpw_request(context, global_server_handle,
+				    params->realm, s2, kt, &from,
+				    &reqdata, &repdata)) {
+	  krb5_klog_syslog(LOG_ERR, "chpw: Error processing request from %s: "
+			   "%s", inet_ntoa(from.sin_addr),
+			   error_message(errno));
+     }
+
+     close(s2);
+
+     if (repdata.length == 0)
+	  /* just qreturn.  This means something really bad happened */
+	  return;
+
+     len = sendto(s1, repdata.data, repdata.length, 0,
+		  (struct sockaddr *) &from, sizeof(from));
+
+     if (len < repdata.length) {
+	  krb5_xfree(repdata.data);
+
+	  krb5_klog_syslog(LOG_ERR, "chpw: Error sending reply to %s: %s",
+			   inet_ntoa(from.sin_addr), error_message(errno));
+
+	  return;
+     }
+
+     krb5_xfree(repdata.data);
+
+     return;
 }
Index: kadmin/server/schpw.c
diff -u /dev/null krb5/kadmin/server/schpw.c:1.1
@@ -0,0 +1,372 @@
+#define NEED_SOCKETS
+#include "k5-int.h"
+#include <kadm5/admin.h>
+
+#include <stdio.h>
+#include <errno.h>
+
+krb5_error_code
+process_chpw_request(context, server_handle, realm, s, keytab, sin, req, rep)
+     krb5_context context;
+     void *server_handle;
+     char *realm;
+     int s;
+     krb5_keytab keytab;
+     struct sockaddr_in *sin;
+     krb5_data *req;
+     krb5_data *rep;
+{
+    krb5_error_code ret;
+    char *ptr;
+    int plen, vno;
+    krb5_address local_kaddr, remote_kaddr;
+    krb5_data ap_req, ap_rep;
+    krb5_auth_context auth_context;
+    krb5_principal changepw;
+    krb5_ticket *ticket;
+    krb5_data cipher, clear;
+    struct sockaddr local_addr, remote_addr;
+    int addrlen;
+    krb5_replay_data replay;
+    krb5_error krberror;
+    int numresult;
+    char strresult[1024];
+
+    ret = 0;
+    rep->length = 0;
+
+    auth_context = NULL;
+    changepw = NULL;
+    ap_rep.length = 0;
+    ticket = NULL;
+    clear.length = 0;
+    cipher.length = 0;
+
+    if (req->length < 4) {
+	/* either this, or the server is printing bad messages,
+	   or the caller passed in garbage */
+	ret = KRB5KRB_AP_ERR_MODIFIED;
+	numresult = KRB5_KPASSWD_MALFORMED;
+	strcpy(strresult, "Request was truncated");
+	goto chpwfail;
+    }
+
+    ptr = req->data;
+
+    /* verify length */
+
+    plen = (*ptr++ & 0xff);
+    plen = (plen<<8) | (*ptr++ & 0xff);
+
+    if (plen != req->length)
+	return(KRB5KRB_AP_ERR_MODIFIED);
+
+    /* verify version number */
+
+    vno = (*ptr++ & 0xff) ;
+    vno = (vno<<8) | (*ptr++ & 0xff);
+
+    if (vno != 1) {
+	ret = KRB5KDC_ERR_BAD_PVNO;
+	numresult = KRB5_KPASSWD_MALFORMED;
+	sprintf(strresult,
+		"Request contained unknown protocol version number %d", vno);
+	goto chpwfail;
+    }
+
+    /* read, check ap-req length */
+
+    ap_req.length = (*ptr++ & 0xff);
+    ap_req.length = (ap_req.length<<8) | (*ptr++ & 0xff);
+
+    if (ptr + ap_req.length >= req->data + req->length) {
+	ret = KRB5KRB_AP_ERR_MODIFIED;
+	numresult = KRB5_KPASSWD_MALFORMED;
+	strcpy(strresult, "Request was truncated in AP-REQ");
+	goto chpwfail;
+    }
+
+    /* verify ap_req */
+
+    ap_req.data = ptr;
+    ptr += ap_req.length;
+
+    if (ret = krb5_auth_con_init(context, &auth_context)) {
+	numresult = KRB5_KPASSWD_HARDERROR;
+	strcpy(strresult, "Failed initializing auth context");
+	goto chpwfail;
+    }
+
+    if (ret = krb5_auth_con_setflags(context, auth_context,
+				     KRB5_AUTH_CONTEXT_DO_SEQUENCE)) {
+	numresult = KRB5_KPASSWD_HARDERROR;
+	strcpy(strresult, "Failed initializing auth context");
+	goto chpwfail;
+    }
+	
+    if (ret = krb5_build_principal(context, &changepw, strlen(realm), realm,
+				   "kadmin", "changepw", NULL)) {
+	numresult = KRB5_KPASSWD_HARDERROR;
+	strcpy(strresult, "Failed building kadmin/changepw principal");
+	goto chpwfail;
+    }
+
+    ret = krb5_rd_req(context, &auth_context, &ap_req, changepw, keytab,
+		      NULL, &ticket);
+
+    if (ret) {
+	numresult = KRB5_KPASSWD_AUTHERROR;
+	strcpy(strresult, "Failed reading application request");
+	goto chpwfail;
+    }
+
+    /* set up address info */
+
+    addrlen = sizeof(local_addr);
+
+    if (getsockname(s, &local_addr, &addrlen) < 0) {
+	ret = errno;
+	numresult = KRB5_KPASSWD_HARDERROR;
+	strcpy(strresult, "Failed getting server internet address");
+	goto chpwfail;
+    }
+
+    /* some brain-dead OS's don't return useful information from
+     * the getsockname call.  Namely, windows and solaris.  */
+
+    if (((struct sockaddr_in *)&local_addr)->sin_addr.s_addr != 0) {
+	local_kaddr.addrtype = ADDRTYPE_INET;
+	local_kaddr.length =
+	    sizeof(((struct sockaddr_in *) &local_addr)->sin_addr);
+	local_kaddr.contents = 
+	    (char *) &(((struct sockaddr_in *) &local_addr)->sin_addr);
+    } else {
+	krb5_address **addrs;
+
+	krb5_os_localaddr(context, &addrs);
+	local_kaddr.magic = addrs[0]->magic;
+	local_kaddr.addrtype = addrs[0]->addrtype;
+	local_kaddr.length = addrs[0]->length;
+	local_kaddr.contents = malloc(addrs[0]->length);
+	memcpy(local_kaddr.contents, addrs[0]->contents, addrs[0]->length);
+
+	krb5_free_addresses(context, addrs);
+    }
+
+    addrlen = sizeof(remote_addr);
+
+    if (getpeername(s, &remote_addr, &addrlen) < 0) {
+	ret = errno;
+	numresult = KRB5_KPASSWD_HARDERROR;
+	strcpy(strresult, "Failed getting client internet address");
+	goto chpwfail;
+    }
+
+    remote_kaddr.addrtype = ADDRTYPE_INET;
+    remote_kaddr.length =
+	sizeof(((struct sockaddr_in *) &remote_addr)->sin_addr);
+    remote_kaddr.contents = 
+	(char *) &(((struct sockaddr_in *) &remote_addr)->sin_addr);
+    
+    remote_kaddr.addrtype = ADDRTYPE_INET;
+    remote_kaddr.length = sizeof(sin->sin_addr);
+    remote_kaddr.contents = (char *) &sin->sin_addr;
+    
+    /* mk_priv requires that the local address be set.
+       getsockname is used for this.  rd_priv requires that the
+       remote address be set.  recvfrom is used for this.  If
+       rd_priv is given a local address, and the message has the
+       recipient addr in it, this will be checked.  However, there
+       is simply no way to know ahead of time what address the
+       message will be delivered *to*.  Therefore, it is important
+       that either no recipient address is in the messages when
+       mk_priv is called, or that no local address is passed to
+       rd_priv.  Both is a better idea, and I have done that.  In
+       summary, when mk_priv is called, *only* a local address is
+       specified.  when rd_priv is called, *only* a remote address
+       is specified.  Are we having fun yet?  */
+
+    if (ret = krb5_auth_con_setaddrs(context, auth_context, NULL,
+				     &remote_kaddr)) {
+	numresult = KRB5_KPASSWD_HARDERROR;
+	strcpy(strresult, "Failed storing client internet address");
+	goto chpwfail;
+    }
+
+    /* verify that this is an AS_REQ ticket */
+
+    if (!(ticket->enc_part2->flags & TKT_FLG_INITIAL)) {
+	numresult = KRB5_KPASSWD_AUTHERROR;
+	strcpy(strresult, "Ticket must be derived from a password");
+	goto chpwfail;
+    }
+
+    /* construct the ap-rep */
+
+    if (ret = krb5_mk_rep(context, auth_context, &ap_rep)) {
+	numresult = KRB5_KPASSWD_AUTHERROR;
+	strcpy(strresult, "Failed replying to application request");
+	goto chpwfail;
+    }
+
+    /* decrypt the new password */
+
+    cipher.length = (req->data + req->length) - ptr;
+    cipher.data = ptr;
+
+    if (ret = krb5_rd_priv(context, auth_context, &cipher, &clear, &replay)) {
+	numresult = KRB5_KPASSWD_HARDERROR;
+	strcpy(strresult, "Failed decrypting request");
+	goto chpwfail;
+    }
+
+    /* change the password */
+
+    ptr = (char *) malloc(clear.length+1);
+    memcpy(ptr, clear.data, clear.length);
+    ptr[clear.length] = '\0';
+
+    ret = kadm5_chpass_principal_util(server_handle, ticket->enc_part2->client,
+				      ptr, NULL, strresult);
+
+    /* zap the password */
+    memset(clear.data, 0, clear.length);
+    memset(ptr, 0, clear.length);
+    krb5_xfree(clear.data);
+    free(ptr);
+    clear.length = 0;
+
+    if (ret) {
+	if ((ret != KADM5_PASS_Q_TOOSHORT) && 
+	    (ret != KADM5_PASS_REUSE) && (ret != KADM5_PASS_Q_CLASS) && 
+	    (ret != KADM5_PASS_Q_DICT) && (ret != KADM5_PASS_TOOSOON))
+	    numresult = KRB5_KPASSWD_HARDERROR;
+	else
+	    numresult = KRB5_KPASSWD_SOFTERROR;
+	/* strresult set by kadb5_chpass_principal_util() */
+	goto chpwfail;
+    }
+
+    /* success! */
+
+    numresult = KRB5_KPASSWD_SUCCESS;
+    strcpy(strresult, "");
+
+chpwfail:
+
+    clear.length = 2 + strlen(strresult);
+    clear.data = (char *) malloc(clear.length);
+
+    ptr = clear.data;
+
+    *ptr++ = (numresult>>8) & 0xff;
+    *ptr++ = numresult & 0xff;
+
+    memcpy(ptr, strresult, strlen(strresult));
+
+    cipher.length = 0;
+
+    if (ap_rep.length) {
+	if (ret = krb5_auth_con_setaddrs(context, auth_context, &local_kaddr,
+					 NULL)) {
+	    numresult = KRB5_KPASSWD_HARDERROR;
+	    strcpy(strresult,
+		   "Failed storing client and server internet addresses");
+	} else {
+	    if (ret = krb5_mk_priv(context, auth_context, &clear, &cipher,
+				   &replay)) {
+		numresult = KRB5_KPASSWD_HARDERROR;
+		strcpy(strresult, "Failed encrypting reply");
+	    }
+	}
+    }
+
+    /* if no KRB-PRIV was constructed, then we need a KRB-ERROR.
+       if this fails, just bail.  there's nothing else we can do. */
+
+    if (cipher.length == 0) {
+	/* clear out ap_rep now, so that it won't be inserted in the
+           reply */
+
+	if (ap_rep.length) {
+	    krb5_xfree(ap_rep.data);
+	    ap_rep.length = 0;
+	}
+
+	krberror.ctime = 0;
+	krberror.cusec = 0;
+	krberror.susec = 0;
+	if (ret = krb5_timeofday(context, &krberror.stime))
+	    goto bailout;
+
+	/* this is really icky.  but it's what all the other callers
+	   to mk_error do. */
+	krberror.error = ret;
+	krberror.error -= ERROR_TABLE_BASE_krb5;
+	if (krberror.error < 0 || krberror.error > 128)
+	    krberror.error = KRB_ERR_GENERIC;
+
+	krberror.client = NULL;
+	if (ret = krb5_build_principal(context, &krberror.server,
+				       strlen(realm), realm,
+				       "kadmin", "changepw", NULL))
+	    goto bailout;
+	krberror.text.length = 0;
+	krberror.e_data = clear;
+
+	ret = krb5_mk_error(context, &krberror, &cipher);
+
+	krb5_free_principal(context, krberror.server);
+
+	if (ret)
+	    goto bailout;
+    }
+
+    /* construct the reply */
+
+    rep->length = 6 + ap_rep.length + cipher.length;
+    rep->data = (char *) malloc(rep->length);
+    ptr = rep->data;
+
+    /* length */
+
+    *ptr++ = (rep->length>>8) & 0xff;
+    *ptr++ = rep->length & 0xff;
+
+    /* version == 0x0001 big-endian */
+
+    *ptr++ = 0;
+    *ptr++ = 1;
+
+    /* ap_rep length, big-endian */
+
+    *ptr++ = (ap_rep.length>>8) & 0xff;
+    *ptr++ = ap_rep.length & 0xff;
+
+    /* ap-rep data */
+
+    if (ap_rep.length) {
+	memcpy(ptr, ap_rep.data, ap_rep.length);
+	ptr += ap_rep.length;
+    }
+
+    /* krb-priv or krb-error */
+
+    memcpy(ptr, cipher.data, cipher.length);
+
+bailout:
+    if (auth_context)
+	krb5_auth_con_free(context, auth_context);
+    if (changepw)
+	krb5_free_principal(context, changepw);
+    if (ap_rep.length)
+	krb5_xfree(ap_rep.data);
+    if (ticket)
+	krb5_free_ticket(context, ticket);
+    if (clear.length)
+	krb5_xfree(clear.data);
+    if (cipher.length)
+	krb5_xfree(cipher.data);
+
+    return(ret);
+}
Index: kdc/Makefile.in
diff -u krb5/kdc/Makefile.in:1.1.1.1 krb5/kdc/Makefile.in:1.2
@@ -37,6 +37,9 @@
 	replay.o \
 	kerberos_v4.o
 
+EXTRA_OBJS= @EXTRA_OBJS@
+EXTRA_LIBS= @EXTRA_LIBS@
+
 all::	krb5kdc
 
 depend:: kdc5_err.c
@@ -52,8 +55,8 @@
 
 kdc5_err.o: kdc5_err.h
 
-krb5kdc: $(OBJS) $(DEPLIBS)
-	$(LD) $(LDFLAGS) $(LDARGS) -o krb5kdc $(OBJS) $(LIBS)
+krb5kdc: $(OBJS) $(EXTRA_OBJS) $(DEPLIBS)
+	$(LD) $(LDFLAGS) $(LDARGS) -o krb5kdc $(OBJS) $(EXTRA_OBJS) $(LIBS) $(EXTRA_LIBS)
 
 install::
 	$(INSTALL_PROGRAM) krb5kdc ${DESTDIR}$(SERVER_BINDIR)/krb5kdc
Index: kdc/configure.in
diff -u krb5/kdc/configure.in:1.1.1.1 krb5/kdc/configure.in:1.3
@@ -32,6 +32,38 @@
 	AC_DEFINE(KRBCONF_KDC_MODIFIES_KDB)
 fi
 dnl
+dnl --with-afs-name-change enables code that supports the case where
+dnl the name of the realm (cell) changed when going from AFS to Kerberos 5
+dnl
+AC_ARG_WITH([afs-name-change],
+[  -with-afs-name-change	Support an AFS cell with a different name],
+if test "$withval" = yes; then
+	AC_DEFINE(KRB5_KDC_AFS3_USE_CONTENTS)
+fi)
+dnl
+dnl --with-securid-preauth turns on code from ARL to allow the use of a
+dnl SecurID token to be used as a hardware preauthentication mechanism
+dnl
+AC_ARG_WITH([securid-preauth],
+[  --with-securid-preuath=DIR	Support SecurID as preauth, client libs in DIR
+  --without-securid-preauth	Do not add in SecurID support (default)],
+,
+withval=no)dnl
+if test "$withval" != "no"; then
+	if test ! -f $withval/sdiclient.a; then
+		echo "Cannot find sdclient.a in $withval, exiting"
+		exit 1
+	fi
+	if test ! -f $withval/sdconf.h; then
+		echo "Cannot find sdconf.h in $withval, exiting"
+		exit 1
+	fi
+	AC_MSG_RESULT(Enabling support for SecurID tokens)
+	AC_DEFINE(ARL_SECURID_PREAUTH)
+	CPPFLAGS="$CPPFLAGS -I$withval"
+	EXTRA_LIBS=$withval/sdiclient.a
+	EXTRA_OBJS=securid.o
+fi
 
 dnl
 dnl This is a horrible hack, based on the fact that we have to drag 
@@ -46,6 +78,10 @@
 USE_GSSRPC_LIBRARY
 USE_GSSAPI_LIBRARY
 USE_DYN_LIBRARY
+dnl
+dnl
+AC_SUBST(EXTRA_LIBS)
+AC_SUBST(EXTRA_OBJS)
 dnl
 dnl
 USE_KDB5_LIBRARY
Index: kdc/do_tgs_req.c
diff -u krb5/kdc/do_tgs_req.c:1.1.1.3 krb5/kdc/do_tgs_req.c:1.4
@@ -163,7 +163,7 @@
 	 * might be a request for a TGT for some other realm; we
 	 * should do our best to find such a TGS in this db
 	 */
-	if (firstpass && krb5_princ_size(kdc_context, request->server) == 2) {
+	if (firstpass && krb5_is_tgs_principal(request->server) == TRUE) {
 	    krb5_data *server_1 = krb5_princ_component(kdc_context, request->server, 1);
 	    krb5_data *tgs_1 = krb5_princ_component(kdc_context, tgs_server, 1);
 
Index: kdc/extern.c
diff -u krb5/kdc/extern.c:1.1.1.1 krb5/kdc/extern.c:1.2
@@ -33,5 +33,6 @@
 krb5_data empty_string = {0, 0, ""};
 krb5_timestamp kdc_infinity = KRB5_INT32_MAX; /* XXX */
 krb5_rcache	kdc_rcache = (krb5_rcache) NULL;
+krb5_deltat	kdc_warn_pwexpire = 0;
 
 volatile int signal_requests_exit = 0;	/* gets set when signal hits */
Index: kdc/extern.h
diff -u krb5/kdc/extern.h:1.1.1.1 krb5/kdc/extern.h:1.2
@@ -93,6 +93,7 @@
 extern krb5_data 	empty_string;	/* an empty string */
 extern krb5_timestamp 	kdc_infinity;	/* greater than all other timestamps */
 extern krb5_rcache	kdc_rcache;	/* replay cache */
+extern krb5_deltat	kdc_warn_pwexpire; /* Time to warn about exp pw's */
 
 extern volatile int signal_requests_exit;
 #endif /* __KRB5_KDC_EXTERN__ */
Index: kdc/kdc_preauth.c
diff -u krb5/kdc/kdc_preauth.c:1.1.1.3 krb5/kdc/kdc_preauth.c:1.7
@@ -28,6 +28,10 @@
 #include "extern.h"
 #include <stdio.h>
 
+#ifdef ARL_SECURID_PREAUTH
+#include <syslog.h>
+#endif /* ARL_SECURID_PREAUTH */
+
 typedef krb5_error_code (*verify_proc)
     KRB5_PROTOTYPE((krb5_context, krb5_db_entry *client,
 		    krb5_kdc_req *request,
@@ -81,6 +85,7 @@
     KRB5_PROTOTYPE((krb5_context, krb5_kdc_req *request,
 		    krb5_db_entry *client, krb5_db_entry *server,
 		    krb5_pa_data *data));
+
 /*
  * Preauth property flags
  */
@@ -216,6 +221,30 @@
     }
     retval = encode_krb5_padata_sequence((const krb5_pa_data **) pa_data,
 					 &edat);
+
+#ifdef ARL_SECURID_PREAUTH
+    if (hw_only && pa_data && !(*pa_data)) {
+      /* We are requiring Hardware authentication but have no way of
+       * dealing with it (no SAM methods defined or no preauth mechs
+       * available for KDC to suggest to client.
+       *
+       *
+       * Don't send back ANY error text to client since this will cause
+       * get_in_tkt() to loop.  This should only happen when the user
+       * has not been set up properly in the database (w/ SAM hwauth
+       * principal.  This gives admins a better error message.  [tadhack]
+       */
+
+      krb5_klog_syslog(LOG_INFO,
+		"HW_AUTH required for user %s, but no valid method found",
+		client->princ->data[0].data);
+      if (edat && edat->data) {
+	free(edat->data);
+	edat->length = 0;
+      }
+    }
+#endif /* ARL_SECURID_PREAUTH */
+   
     if (retval)
 	goto errout;
     *e_data = *edat;
@@ -549,6 +578,28 @@
 	   do the work. In the future, add a kdc configuration
 	   variable that specifies the old cell name. */
 	padata->pa_type = KRB5_PADATA_AFS3_SALT;
+#ifdef KRB5_KDC_AFS3_USE_CONTENTS
+	/*
+	 * Check to see if key_data_contents[1] contains information
+	 * and if it does, use that for the salt instead of our realm.
+	 * The intention is that afs2k5db will put the old AFS cell
+	 * name here and we want to use that in cases where it
+	 * differs from the Kerberos 5 realm name.
+	 */
+	if (client_key->key_data_length[1]) {
+	    	padata->length = client_key->key_data_length[1];
+		if ((padata->contents = malloc(padata->length)) == NULL) {
+		    retval = ENOMEM;
+		    goto cleanup;
+		}
+		memcpy(padata->contents, client_key->key_data_contents[1],
+		       client_key->key_data_length[1]);
+		padata->length = client_key->key_data_length[1];
+		break;
+	}
+	/* else fall through */
+#endif /* KRB5_KDC_AFS3_USE_CONTENTS */
+
 	/* it would be just like ONLYREALM, but we need to pass the 0 */
 	scratch = krb5_princ_realm(kdc_context, request->client);
 	if ((padata->contents = malloc(scratch->length+1)) == NULL) {
@@ -622,6 +673,14 @@
     char inputblock[8];
     krb5_data predict_response;
 
+
+    /*
+     * Make sure we don't segfault in cleanup if encrypting.key_length
+     * isn't initialized.
+     */
+    memset((char *) &encrypting_key, 0, sizeof(encrypting_key));
+
+
     /* Given the client name we can figure out what type of preauth
        they need. The spec is currently for querying the database for
        names that match the types of preauth used. Later we should
@@ -711,6 +770,23 @@
     sc.sam_flags = KRB5_SAM_USE_SAD_AS_KEY;
 
     switch (sc.sam_type) {
+#ifdef ARL_SECURID_PREAUTH
+    case PA_SAM_TYPE_SECURID:
+      if (pa_data->length) {
+	retval = 0;
+	break;
+      }
+      if (retval = get_securid_edata(context, &sc))
+	goto cleanup;
+      if (retval = encode_krb5_sam_challenge(&sc, &scratch))
+	goto cleanup;
+      pa_data->magic = KV5M_PA_DATA;
+      pa_data->pa_type = KRB5_PADATA_SAM_CHALLENGE;
+      pa_data->contents = scratch->data;
+      pa_data->length = scratch->length;
+      retval = 0;
+      break;
+#endif /* ARL_SECURID_PREAUTH */
     case PA_SAM_TYPE_GRAIL:
       sc.sam_type_name.data = "Experimental System";
       sc.sam_type_name.length = strlen(sc.sam_type_name.data);
@@ -915,10 +991,20 @@
       
       retval = 0;
       break;
+#ifdef ARL_SECURID_PREAUTH
+    default:
+      pa_data->magic = KV5M_PA_DATA;
+      pa_data->pa_type = KRB5_PADATA_SAM_CHALLENGE;
+      pa_data->contents = 0;
+      pa_data->length = 0;
+      return(retval);
+      break;
+#endif /* ARL_SECURID_PREAUTH */
     }
 
 cleanup:
-    memset((char *)encrypting_key.contents, 0, encrypting_key.length);
+    if (encrypting_key.contents)
+      memset((char *)encrypting_key.contents, 0, encrypting_key.length);
     krb5_xfree(encrypting_key.contents);
     return retval;
 }
@@ -945,6 +1031,68 @@
     if (retval) com_err("krb5kdc", retval, "decode_krb5_sam_response failed");
     if (retval) goto cleanup;
 
+#ifdef ARL_SECURID_PREAUTH
+    switch(sr->sam_type) {
+      case PA_SAM_TYPE_DIGI_PATH:               /* Is this DIGI_PATH ?? */
+	if (sr->sam_track_id.length) {
+           krb5_enc_data tmpdata;
+           tmpdata.ciphertext = sr->sam_track_id;
+           retval = krb5_decrypt_data(context, master_encblock.key, 0,
+                              &tmpdata, &scratch);
+           if (retval) {
+              com_err("krb5kdc", retval, "decrypt track_id failed");
+              goto cleanup;
+           }
+	   retval = decode_krb5_predicted_sam_response(&scratch, &psr);
+           if (retval) {
+              com_err("krb5kdc", retval,
+                "decode_krb5_predicted_sam_response failed");
+              goto cleanup;
+           }
+           /* now psr.sam_key is what we said to use... */
+           retval = krb5_decrypt_data(context, &psr->sam_key, 0,
+                                 &sr->sam_enc_nonce_or_ts, &scratch);
+           if (retval) {
+             com_err("krb5kdc", retval, "decrypt nonce_or_ts failed");
+             goto cleanup;
+           }
+           retval = decode_krb5_enc_sam_response_enc(&scratch, &esre);
+           if (retval) {
+             com_err("krb5kdc", retval,
+		"decode_krb5_enc_sam_response_enc failed");
+             goto cleanup;
+           }
+           if (esre->sam_timestamp != sr->sam_patimestamp) {
+             retval = KRB5KDC_ERR_PREAUTH_FAILED;
+             goto cleanup;
+           }
+           retval = krb5_timeofday(context, &timenow);
+           if (retval) goto cleanup;
+
+           if (labs(timenow - sr->sam_patimestamp) > context->clockskew) {
+             retval = KRB5KRB_AP_ERR_SKEW;
+             goto cleanup;
+           }
+	} else {        /* sr->sam_track_id.length = 0 */
+           retval = KRB5KDC_ERR_PREAUTH_FAILED;
+           com_err("krb5kdc",retval,"Digital Pathways track_id data not found");
+           goto cleanup;
+	}
+	break;
+      case PA_SAM_TYPE_SECURID:
+	/* SecurID passcode checking goes here */
+	retval = verify_securid_data(context,client,sr,enc_tkt_reply);
+	goto cleanup;
+        /*NOTREACHED*/
+      default:
+	retval = KRB5KDC_ERR_PREAUTH_FAILED;
+	goto cleanup;
+    }  /* switch(sr->sam_type) */
+    /* Successful HW Preautentication */
+    setflag(enc_tkt_reply->flags, TKT_FLG_HW_AUTH);
+    setflag(enc_tkt_reply->flags, TKT_FLG_PRE_AUTH);
+
+#else /* ARL_SECURID_PREAUTH */
     {
       krb5_enc_data tmpdata;
       tmpdata.ciphertext = sr->sam_track_id;
@@ -977,8 +1125,9 @@
 	retval = KRB5KRB_AP_ERR_SKEW;
 	goto cleanup;
     }
-
     setflag(enc_tkt_reply->flags, TKT_FLG_HW_AUTH);
+#endif /* ARL_SECURID_PREAUTH */
+
   cleanup:
     if (retval) com_err("krb5kdc", retval, "sam verify failure");
     if (sr) krb5_xfree(sr);
Index: kdc/kdc_util.c
diff -u krb5/kdc/kdc_util.c:1.1.1.3 krb5/kdc/kdc_util.c:1.6
@@ -405,12 +405,35 @@
 static krb5_last_req_entry nolrentry = { KV5M_LAST_REQ_ENTRY, KRB5_LRQ_NONE, 0 };
 static krb5_last_req_entry *nolrarray[] = { &nolrentry, 0 };
 
+static krb5_last_req_entry pwexpentry = { KV5M_LAST_REQ_ENTRY,
+					  KRB5_LRQ_PW_EXPTIME, 0 };
+static krb5_last_req_entry *pwexparray[] = { &pwexpentry, 0 };
+
 krb5_error_code
 fetch_last_req_info(dbentry, lrentry)
 krb5_db_entry *dbentry;
 krb5_last_req_entry ***lrentry;
 {
-    *lrentry = nolrarray;
+    krb5_timestamp timenow;
+    krb5_error_code retval;
+
+    if (kdc_warn_pwexpire == 0 || dbentry->pw_expiration == 0) {
+	*lrentry = nolrarray;
+	return 0;
+    }
+
+    if ((retval = krb5_timeofday(kdc_context, &timenow)) != 0)
+	return retval;
+		    
+    if (dbentry->pw_expiration > timenow + kdc_warn_pwexpire) {
+	*lrentry = nolrarray;
+	return 0;
+    }
+
+    pwexpentry.value = dbentry->pw_expiration;
+
+    *lrentry = pwexparray;
+
     return 0;
 }
 
Index: kdc/kerberos_v4.c
diff -u krb5/kdc/kerberos_v4.c:1.1.1.2 krb5/kdc/kerberos_v4.c:1.4
@@ -43,10 +43,6 @@
 #include <arpa/inet.h>
 #include <netdb.h>
 #include <signal.h>
-#ifndef POSIX_TERMIOS
-#include <sgtty.h>
-#endif
-#include <sys/ioctl.h>
 #ifdef HAVE_SYS_TIME_H
 #include <sys/time.h>
 #ifdef TIME_WITH_SYS_TIME
@@ -87,9 +83,6 @@
 /* take this out when we don't need it anymore */
 int krbONE = 1;
 
-#ifdef notdef
-static struct sockaddr_in sin = {AF_INET};
-#endif
 int     f;
 
 /* XXX several files in libkdb know about this */
@@ -156,6 +149,103 @@
 void kerb_err_reply PROTOTYPE((struct sockaddr_in *, KTEXT, long, char *));
 int set_tgtkey PROTOTYPE((char *));
  
+/* Attributes converted from V5 to V4 - internal representation */
+#define V4_KDB_REQUIRES_PREAUTH  0x1
+#define V4_KDB_DISALLOW_ALL_TIX  0x2
+#define V4_KDB_REQUIRES_PWCHANGE 0x4
+
+
+/* v4 compatibitly mode switch */
+#define KDC_V4_NONE		0	/* Don't even respond to packets */
+#define KDC_V4_DISABLE		1	/* V4 requests return an error */
+#define	KDC_V4_FULL		2	/* Preauth required go through */
+#define KDC_V4_NOPREAUTH	3	/* Preauth required disallowed */
+
+#define KDC_V4_DEFAULT_MODE KDC_V4_NOPREAUTH
+/* Flag on how to handle v4 */
+static int		kdc_v4;
+
+struct v4mode_lookup_entry {
+    int                 mode;                   /* Mode setting */
+    const char *	v4_specifier;		/* How to recognize it	*/
+};
+
+static const struct v4mode_lookup_entry  v4mode_table[] = {
+/*  mode                input specifier */
+{ KDC_V4_NONE,          "none"          },
+{ KDC_V4_DISABLE,       "disable"       }, 
+{ KDC_V4_FULL,          "full"          },
+{ KDC_V4_NOPREAUTH,     "nopreauth"     }
+};
+
+static const int v4mode_table_nents = sizeof(v4mode_table)/
+				      sizeof(v4mode_table[0]);
+
+void process_v4_mode(progname, string)
+    const char          *progname;
+    const char          *string;
+{
+    int i, found;
+
+    found = 0;
+    kdc_v4 = KDC_V4_DEFAULT_MODE;
+
+    if(!string) return;  /* Set to default mode */
+    
+    for (i=0; i<v4mode_table_nents; i++) {
+	if (!strcasecmp(string, v4mode_table[i].v4_specifier)) {
+	    found = 1;
+	    kdc_v4 = v4mode_table[i].mode;
+	    break;
+	}
+    }
+
+    if(!found) {
+      /* It is considered fatal if we request a mode that is not found */
+	com_err(progname, 0, "invalid v4_mode %s", string);
+	exit(1);
+    }
+    return;
+}
+
+#define klog v4_klog
+#ifdef HAVE_STDARG_H
+char * v4_klog( int type, const char *format, ...)
+#else
+char * v4_klog( type, format, va_alist)
+    int type;
+    char *format;
+    va_dcl
+#endif
+{
+    int logpri = LOG_INFO;
+    va_list pvar;
+#ifdef HAVE_STDARG_H
+    va_start(pvar, format);
+#else
+    va_start(pvar);
+#endif
+
+    switch (type) {
+    case L_ERR_SEXP:
+    case L_ERR_NKY:
+    case L_ERR_NUN:
+    case L_ERR_UNK:
+    case L_KRB_PERR:
+	logpri = LOG_ERR;
+    case L_INI_REQ:
+    case L_NTGT_INTK:
+    case L_TKT_REQ:
+    case L_APPL_REQ:
+	strcpy(log_text, "PROCESS_V4:");
+	vsprintf(log_text+strlen(log_text), format, pvar);
+	krb5_klog_syslog(logpri, log_text);
+    /* ignore the other types... */
+    }
+    va_end(pvar);
+    return(log_text);
+}
+
 krb5_error_code
 process_v4( pkt, client_fulladdr, is_secondary, resp)
 const krb5_data *pkt;
@@ -198,67 +288,17 @@
     v4_pkt.length = pkt->length;
     memcpy( v4_pkt.dat, pkt->data, pkt->length);
 
+    /* Check if disabled completely */
+    if (kdc_v4 == KDC_V4_NONE) {
+	(void) klog(L_KRB_PERR,
+	"Disabled KRB V4 request");
+	return KRB5KDC_ERR_BAD_PVNO;
+    }
+
     kerberos_v4( &client_sockaddr, &v4_pkt);
     *resp = response;
     return(retval);
 }
-#if 0
-/* convert k4's klog() levels into corresponding errors for v5: */
-int type_2_v5err[] = { 0,	/* 		0 No error		     */
-    KDC_ERR_NONE,		/* L_NET_ERR	1 Error in network code      */
-    KDC_ERR_NONE,		/* L_NET_INFO	2 Info on network activity   */
-    KRB_AP_ERR_BADVERSION,	/* L_KRB_PERR	3 Kerberos protocol errors   */
-    KDC_ERR_NONE,		/* L_KRB_PINFO	4 Kerberos protocol info     */
-    KDC_ERR_NONE,		/* L_INI_REQ	5 Request for initial ticket */
-    KRB_AP_ERR_BADVERSION,	/* L_NTGT_INTK	6 Initial request not for TGT*/
-    KDC_ERR_NONE,		/* L_DEATH_REQ	7 Request for server death   */
-    KDC_ERR_NONE,		/* L_TKT_REQ	8 All ticket requests w/ tgt */
-    KDC_ERR_SERVICE_EXP,	/* L_ERR_SEXP	9 Service expired	     */
-    KDC_ERR_C_OLD_MAST_KVNO,	/* L_ERR_MKV	10 Master key version old    */
-    KDC_ERR_NULL_KEY,		/* L_ERR_NKY    11 User's key is null        */
-    KDC_ERR_PRINCIPAL_NOT_UNIQUE, /* L_ERR_NUN	12 Principal not unique      */
-    KDC_ERR_C_PRINCIPAL_UNKNOWN,  /* L_ERR_UNK	13 Principal Unknown         */
-    KDC_ERR_NONE,		/* L_ALL_REQ    14 All requests	     	     */
-    KDC_ERR_NONE,		/* L_APPL_REQ   15 Application requests w/tgt*/
-    KRB_AP_ERR_BADVERSION	/* L_KRB_PWARN  16 Protocol warning messages */
-};
-#endif
-#ifdef HAVE_STDARG_H
-char * v4_klog( int type, const char *format, ...)
-#else
-char * v4_klog( type, format, va_alist)
-    int type;
-    char *format;
-    va_dcl
-#endif
-{
-    int logpri = LOG_INFO;
-    va_list pvar;
-#ifdef HAVE_STDARG_H
-    va_start(pvar, format);
-#else
-    va_start(pvar);
-#endif
-
-    switch (type) {
-    case L_ERR_SEXP:
-    case L_ERR_NKY:
-    case L_ERR_NUN:
-    case L_ERR_UNK:
-    case L_KRB_PERR:
-	logpri = LOG_ERR;
-    case L_INI_REQ:
-    case L_NTGT_INTK:
-    case L_TKT_REQ:
-    case L_APPL_REQ:
-	strcpy(log_text, "PROCESS_V4:");
-	vsprintf(log_text+strlen(log_text), format, pvar);
-	krb5_klog_syslog(logpri, log_text);
-    /* ignore the other types... */
-    }
-    va_end(pvar);
-    return(log_text);
-}
 
 static
 int krb4_sendto(s, msg, len, flags, to, to_len)
@@ -424,15 +464,36 @@
      */
     v4_time = (entries.max_life + MIN5 - 1) / MIN5;
     principal->max_life = v4_time > HR21 ? HR21 : (unsigned char) v4_time;
-    principal->exp_date = (unsigned long) entries.expiration;
+    /*
+     * This is weird, but the intent is that the expiration is the minimum
+     * of the principal expiration and key expiration
+     */
+    principal->exp_date = (unsigned long) 
+        entries.expiration && entries.pw_expiration ?
+        min(entries.expiration, entries.pw_expiration) :
+        (entries.pw_expiration ? entries.pw_expiration :
+        entries.expiration);
 /*    principal->mod_date = (unsigned long) entries.mod_date; */
 /* Set the master key version to 1. It's not really useful because all keys
  * will be encrypted in the same master key version, and digging out the 
- * actuall key version will be harder than it's worth --proven */
+ * actual key version will be harder than it's worth --proven */
 /*    principal->kdc_key_ver = entries.mkvno; */
     principal->kdc_key_ver = 1;
     principal->key_version = pkey->key_data_kvno;
+    /* We overload the attributes with the relevant v5 ones */
     principal->attributes = 0;
+    if (isflagset(entries.attributes,  KRB5_KDB_REQUIRES_HW_AUTH) ||
+	isflagset(entries.attributes,  KRB5_KDB_REQUIRES_PRE_AUTH)) {
+          principal->attributes |= V4_KDB_REQUIRES_PREAUTH;
+    }
+    if (isflagset(entries.attributes,  KRB5_KDB_DISALLOW_ALL_TIX)) {
+          principal->attributes |= V4_KDB_DISALLOW_ALL_TIX;
+    }
+    if (isflagset(entries.attributes,  KRB5_KDB_REQUIRES_PWCHANGE)) {
+          principal->attributes |= V4_KDB_REQUIRES_PWCHANGE;
+    }
+
+
 
     /* set up v4 format of each date's text: */
     for ( date = &principal->exp_date, text = principal->exp_date_txt;
@@ -507,6 +568,17 @@
 
     req_act_vno = req_version;
 
+    /* check if disabled, but we tell client */
+    if (kdc_v4 == KDC_V4_DISABLE) {
+	lt = klog(L_KRB_PERR,
+	"KRB will not handle v4 request from %s",
+		  inet_ntoa(client_host));
+	/* send an error reply */
+	req_name_ptr = req_inst_ptr = req_realm_ptr = "";
+	kerb_err_reply(client, pkt, KERB_ERR_PKT_VER, lt);
+	return;
+    }
+
     /* check packet version */
     if (req_version != KRB_PROT_VERSION) {
 	lt = klog(L_KRB_PERR,
@@ -793,38 +865,6 @@
 }
 
 
-#ifndef BACKWARD_COMPAT
-/*
- * setup_disc 
- *
- * disconnect all descriptors, remove ourself from the process
- * group that spawned us. 
- */
-
-setup_disc()
-{
-
-    int     s;
-
-    for (s = 0; s < 3; s++) {
-	(void) close(s);
-    }
-
-    (void) open("/dev/null", 0);
-    (void) dup2(0, 1);
-    (void) dup2(0, 2);
-
-    s = open("/dev/tty", 2);
-
-    if (s >= 0) {
-	ioctl(s, TIOCNOTTY, (struct sgttyb *) 0);
-	(void) close(s);
-    }
-    (void) chdir("/tmp");
-    return;
-}
-#endif /* BACKWARD_COMPAT */
-
 
 /*
  * kerb_er_reply creates an error reply packet and sends it to the
@@ -852,34 +892,6 @@
 
 }
 
-#ifndef BACKWARD_COMPAT
-/*
- * Make sure that database isn't stale.
- *
- * Exit if it is; we don't want to tell lies.
- */
-
-static void check_db_age()
-{
-    long age;
-    
-    if (max_age != -1) {
-	/* Requires existance of kerb_get_db_age() */
-	gettimeofday(&kerb_time, 0);
-	age = kerb_get_db_age();
-	if (age == 0) {
-	    klog(L_KRB_PERR, "Database currently being updated!");
-	    hang();
-	}
-	if ((age + max_age) < kerb_time.tv_sec) {
-	    klog(L_KRB_PERR, "Database out of date!");
-	    hang();
-	    /* NOTREACHED */
-	}
-    }
-}
-#endif /* BACKWARD_COMPAT */
-
 /*
  * Given a pointer to a long containing the number of seconds
  * since the beginning of time (midnight 1 Jan 1970 GMT), return
@@ -943,6 +955,42 @@
 		  p_name, instance, 0);
 	return KERB_ERR_PRINCIPAL_NOT_UNIQUE;
     }
+
+    /*
+     * Check our V5 stuff first.
+     */
+
+    /*
+     * Does the principal have REQUIRES_PWCHANGE set?
+     */
+    if (isflagset(p->attributes, V4_KDB_REQUIRES_PWCHANGE)) {
+	lt = klog(L_ERR_SEXP, "V5 REQUIRES_PWCHANGE set "
+		  "\"%s\" \"%s\"", p_name, instance);
+	return KERB_ERR_NAME_EXP;
+    }
+
+    /*
+     * Does the principal have DISALLOW_ALL_TIX set?
+     */
+    if (isflagset(p->attributes, V4_KDB_DISALLOW_ALL_TIX)) {
+	lt = klog(L_ERR_SEXP, "V5 DISALLOW_ALL_TIX set: "
+		  "\"%s\" \"%s\"", p_name, instance);
+	/* Not sure of a better error to return */
+	return KERB_ERR_NAME_EXP;
+    }
+
+    /*
+     * Does the principal require preauthentication?
+     */
+    if ((kdc_v4 == KDC_V4_NOPREAUTH) &&
+	isflagset(p->attributes, V4_KDB_REQUIRES_PREAUTH)) {
+        lt = klog(L_ERR_SEXP, "V5 REQUIRES_PREAUTH set: "
+		  "\"%s\" \"%s\"", p_name, instance);
+	/* Not sure of a better error to return */
+	return KERB_ERR_AUTH_EXP;
+/*	return KERB_ERR_NAME_EXP;*/
+    }
+
     /* If the user's key is null, we want to return an error */
     if ((p->key_low == 0) && (p->key_high == 0)) {
 	/* User has a null key */
@@ -993,24 +1041,6 @@
     return (KSUCCESS);
 }
 
-#ifndef BACKWARD_COMPAT
-static void
-hang()
-{
-    if (pause_int == -1) {
-	klog(L_KRB_PERR, "Kerberos will pause so as not to loop init");
-	for (;;)
-	    pause();
-    } else {
-	char buf[256];
-	sprintf(buf,  "Kerberos will wait %d seconds before dying so as not to loop init", pause_int);
-	klog(L_KRB_PERR, buf);
-	sleep(pause_int);
-	klog(L_KRB_PERR, "Do svedania....\n");
-	exit(1);
-    }
-}
-#endif /* BACKWARD_COMPAT */
 #else	/* KRB5_KRB4_COMPAT */
 #include "k5-int.h"
 #endif /* KRB5_KRB4_COMPAT */
Index: kdc/main.c
diff -u krb5/kdc/main.c:1.1.1.1 krb5/kdc/main.c:1.3
@@ -691,7 +691,7 @@
 usage(name)
 char *name;
 {
-    fprintf(stderr, "usage: %s [-d dbpathname] [-r dbrealmname] [-R replaycachename ]\n\t[-m] [-k masterenctype] [-M masterkeyname] [-p port] [-n]\n", name);
+    fprintf(stderr, "usage: %s [-d dbpathname] [-r dbrealmname] [-R replaycachename ]\n\t[-m] [-k masterenctype] [-M masterkeyname] [-p port] [-4 v4mode] [-n]\n", name);
     return;
 }
 
@@ -713,6 +713,10 @@
     char		*default_ports = 0;
     krb5_pointer	aprof;
     const char		*hierarchy[3];
+#ifdef KRB5_KRB4_COMPAT
+    char		*v4mode = 0;
+#endif
+    krb5_int32		pw_warn_expire;
     extern char *optarg;
 
     if (!krb5_aprof_init(DEFAULT_KDC_PROFILE, KDC_PROFILE_ENV, &aprof)) {
@@ -721,6 +725,14 @@
 	hierarchy[2] = (char *) NULL;
 	if (krb5_aprof_get_string(aprof, hierarchy, TRUE, &default_ports))
 	    default_ports = 0;
+	hierarchy[1] = "kdc_warn_pwexpire";
+	if (krb5_aprof_get_deltat(aprof, hierarchy, TRUE, &kdc_warn_pwexpire))
+		kdc_warn_pwexpire = 0;
+#ifdef KRB5_KRB4_COMPAT
+	hierarchy[1] = "v4_mode";
+	if (krb5_aprof_get_string(aprof, hierarchy, TRUE, &v4mode))
+	    v4mode = 0;
+#endif
 	/* aprof_init can return 0 with aprof == NULL */
 	if (aprof)
 	     krb5_aprof_finish(aprof);
@@ -732,7 +744,7 @@
      * Loop through the option list.  Each time we encounter a realm name,
      * use the previously scanned options to fill in for defaults.
      */
-    while ((c = getopt(argc, argv, "r:d:mM:k:R:e:p:s:n")) != EOF) {
+    while ((c = getopt(argc, argv, "r:d:mM:k:R:e:p:s:n4:")) != EOF) {
 	switch(c) {
 	case 'r':			/* realm name for db */
 	    if (!find_realm_data(optarg, (krb5_ui_4) strlen(optarg))) {
@@ -775,12 +787,26 @@
 		free(default_ports);
 	    default_ports = strdup(optarg);
 	    break;
+	case '4':
+#ifdef KRB5_KRB4_COMPAT
+	    if (v4mode)
+		free(v4mode);
+	    v4mode = strdup(optarg);
+#endif
+	    break;
 	case '?':
 	default:
 	    usage(argv[0]);
 	    exit(1);
 	}
     }
+
+#ifdef KRB5_KRB4_COMPAT
+    /*
+     * Setup the v4 mode 
+     */
+    process_v4_mode(argv[0], v4mode);
+#endif
 
     /*
      * Check to see if we processed any realms.
Index: kdc/network.c
diff -u krb5/kdc/network.c:1.1.1.1 krb5/kdc/network.c:1.4
@@ -44,6 +44,7 @@
 
 static int *udp_port_fds = (int *) NULL;
 static u_short *udp_port_nums = (u_short *) NULL;
+static struct in_addr *udp_port_addrs = (struct in_addr *) NULL;
 static int n_udp_ports = 0;
 static int max_udp_ports = 0;
 static fd_set select_fds;
@@ -51,16 +52,19 @@
 
 #define safe_realloc(p,n) ((p)?(realloc(p,n)):(malloc(n)))
 
-static krb5_error_code add_port(port)
+static krb5_error_code add_port(port, interface)
      u_short port;
+     struct in_addr *interface;
 {
     int	i;
     int *new_fds;
     u_short *new_ports;
+    struct in_addr *new_addrs;
     int new_max;
 
     for (i=0; i < n_udp_ports; i++) {
-	if (udp_port_nums[i] == port)
+	if (udp_port_nums[i] == port &&
+	    memcmp(&udp_port_addrs[i], interface, sizeof(struct in_addr)) == 0)
 	    return 0;
     }
     
@@ -76,9 +80,16 @@
 	    return ENOMEM;
 	udp_port_nums = new_ports;
 
+	new_addrs = safe_realloc(udp_port_addrs, new_max *
+				 sizeof(struct in_addr));
+	if (new_addrs == 0)
+	    return ENOMEM;
+	udp_port_addrs = new_addrs;
+
 	max_udp_ports = new_max;
     }
-	
+
+    memcpy(&udp_port_addrs[n_udp_ports], interface, sizeof(struct in_addr));
     udp_port_nums[n_udp_ports++] = port;
     return 0;
 }
@@ -89,14 +100,34 @@
 const char *prog;
 {
     struct sockaddr_in sin;
+    struct in_addr saddr;
     krb5_error_code retval;
     u_short port;
     char *cp;
-    int i;
+    int i, j, numaddrs;
+    krb5_address **localaddrs;
+    const int on = 1; 
 
     FD_ZERO(&select_fds);
     select_nfds = 0;
     memset((char *)&sin, 0, sizeof(sin));
+    sin.sin_family = AF_INET;
+    saddr.s_addr = INADDR_ANY;
+
+    /*
+     * Sigh.  We need to bind to all of the interfaces individually
+     * in addition to the wildcard address, since that's the only
+     * way to deal with multihomed hosts and asymmetric routing.
+     * So first, get a list of all local interfaces.
+     */
+
+    retval = krb5_os_localaddr(kdc_context, &localaddrs);
+    if (retval) {
+	com_err(prog, 0, "Cannot find local addresses");
+	return(retval);
+    }
+
+    for (numaddrs = 0; localaddrs[numaddrs] != NULL; numaddrs++) ;
 
     /* Handle each realm's ports */
     for (i=0; i<kdc_numrealms; i++) {
@@ -109,9 +140,25 @@
 	    port = strtol(cp, &cp, 10);
 	    if (cp == 0)
 		break;
-	    retval = add_port(port);
+	    /*
+	     * We first add an interface for the wildcard address.
+	     */
+	    retval = add_port(port, &saddr);
 	    if (retval)
 		return retval;
+	    /*
+	     * Next, add ports for all of the network interfaces
+	     */
+	    for (j = 0; j < numaddrs; j++) {
+		struct in_addr tsaddr;
+		if (localaddrs[j]->addrtype == ADDRTYPE_INET) {
+		    memcpy((char *)&tsaddr, (char *) localaddrs[j]->contents,
+			   localaddrs[j]->length);
+		    retval = add_port(port, &tsaddr);
+		    if (retval)
+			return retval;
+		}
+	    }
 	}
     }
 
@@ -122,6 +169,24 @@
 		    udp_port_nums[i]);
 	    return(retval);
 	}
+
+	/*
+	 * Turn on SO_REUSEADDR on this socket (since we're now creating
+	 * more than one socket per port).
+	 */
+
+	if (setsockopt(udp_port_fds[i], SOL_SOCKET, SO_REUSEADDR, (char *)&on,
+		       sizeof(on)) != 0) {
+	    com_err(prog, errno, "setsockopt(udp, reuseaddr)");
+	    /* This isn't _that_ serious ... */
+	}
+
+	/*
+	 * Copy over the appropriate local address to bind to
+	 */
+	memcpy((char *)&sin.sin_addr, (char *) &udp_port_addrs[i],
+	       sizeof(struct in_addr));
+
 	sin.sin_port = htons(udp_port_nums[i]);
 	if (bind(udp_port_fds[i], (struct sockaddr *) &sin,
 		 sizeof(sin)) == -1) {
@@ -134,6 +199,8 @@
 	if (udp_port_fds[i]+1 > select_nfds)
 	    select_nfds = udp_port_fds[i]+1;
     }
+
+    krb5_free_addresses(kdc_context, localaddrs);
 
     return 0;
 }
Index: kdc/rtest.c
diff -u krb5/kdc/rtest.c:1.1.1.1 krb5/kdc/rtest.c:1.2
@@ -26,6 +26,34 @@
 #include "k5-int.h"
 #include <stdio.h>
 #include "kdc_util.h"
+#include "extern.h"
+
+krb5_principal 
+make_princ(ctx, str, prog)
+    krb5_context ctx;
+    const char *str;
+    const char *prog;
+{
+    krb5_principal ret;
+    char *dat;
+
+    if(!(ret = (krb5_principal) malloc(sizeof(krb5_principal_data)))) {
+	  com_err(prog, ENOMEM, "while allocating principal data");
+	  exit(3);
+    }
+    memset(ret, 0, sizeof(krb5_principal_data));
+
+    /* We do not include the null... */
+    if(!(dat = (char *) malloc(strlen(str)))) {
+	  com_err(prog, ENOMEM, "while allocating principal realm data");
+	  exit(3);
+    }
+    memcpy(dat, str, strlen(str));
+    krb5_princ_set_realm_data(ctx, ret, dat);
+    krb5_princ_set_realm_length(ctx, ret, strlen(str));
+    
+    return ret;
+}
 
 void
 main(argc,argv)
@@ -34,47 +62,50 @@
     {
 	krb5_data otrans;
 	krb5_data ntrans;
-
-	krb5_data *tgnames[10];
-	krb5_principal tgs = tgnames;
-	krb5_data tgsrlm;
-
-	krb5_data *cnames[10];
-	krb5_principal cl = cnames;
-	krb5_data crlm;
-
-	krb5_data *snames[10];
-	krb5_principal sv = snames;
-	krb5_data srlm;
+	krb5_principal tgs, cl, sv;
+	krb5_error_code kret;
+	kdc_realm_t	kdc_realm;
 
 	if (argc < 4) {
 	    fprintf(stderr, "not enough args\n");
 	    exit(1);
 	}
+
+
+	/* Get a context */
+	kret = krb5_init_context(&kdc_realm.realm_context);
+	if (kret) {
+	  com_err(argv[0], kret, "while getting krb5 context");
+	  exit(2);
+	}
+	/* Needed so kdc_context will work */
+	kdc_active_realm = &kdc_realm;
+
 	ntrans.length = 0;
-	otrans.length = strlen(argv[1]) + 1;
+	ntrans.data = 0;
+
+	otrans.length = strlen(argv[1]);
 	otrans.data = (char *) malloc(otrans.length);
-	strcpy(otrans.data,argv[1]);
+	memcpy(otrans.data,argv[1], otrans.length);
 
-	tgsrlm.length = strlen(argv[2]) + 1;
-	tgsrlm.data = (char *) malloc(tgsrlm.length);
-	strcpy(tgsrlm.data,argv[2]);
-	tgs[0] = &tgsrlm;
-
-	crlm.length = strlen(argv[3]) + 1;
-	crlm.data = (char *) malloc(crlm.length);
-	strcpy(crlm.data,argv[3]);
-	cl[0] = &crlm;
-
-	srlm.length = strlen(argv[4]) + 1;
-	srlm.data = (char *) malloc(srlm.length);
-	strcpy(srlm.data,argv[4]);
-	sv[0] = &srlm;
+	tgs = make_princ(kdc_context, argv[2], argv[0]);
+	cl  = make_princ(kdc_context, argv[3], argv[0]);
+	sv  = make_princ(kdc_context, argv[4], argv[0]);
 	
 	add_to_transited(&otrans,&ntrans,tgs,cl,sv);
 
 	printf("%s\n",ntrans.data);
 
+	/* Free up all memory so we can profile for leaks */
+	free(otrans.data);
+	free(ntrans.data);
+
+	krb5_free_principal(kdc_realm.realm_context, tgs);
+	krb5_free_principal(kdc_realm.realm_context, cl);
+	krb5_free_principal(kdc_realm.realm_context, sv);
+	krb5_free_context(kdc_realm.realm_context);
+
+	exit(0);
     }
 
-krb5_encrypt_block master_encblock;
+void krb5_klog_syslog() {}
Index: kdc/securid.c
diff -u /dev/null krb5/kdc/securid.c:1.2
@@ -0,0 +1,562 @@
+/*	S E C U R I D . C   - -
+ *
+ *		SecurID helper routines for SAM preauthentication.
+ *
+ *	Author: Kenneth D. Renard
+ *		Army Research Lab
+ *	Date:	9 Oct 96
+ *	Version: 1.0
+ */
+
+#include "k5-int.h"
+#include "kdc_util.h"
+#include "extern.h"
+#include <stdio.h>
+
+#ifdef SLAVE
+#include <unistd.h>
+#endif
+
+#include <sdi_athd.h>
+#include <sdi_defs.h>
+#include <sdconf.h>
+#include <sdacmvls.h>
+
+union config_record configure;
+int need_to_creadcfg = 1;
+int need_to_sd_init = 1;
+static krb5_sam_challenge sam_challenge;
+
+/*
+ * Structure to hold SecurID track data.  This keeps state data in place
+ * between requests.
+ */
+
+struct securid_track_data {
+	char 	state;				/* What state we're in */
+#define SECURID_STATE_NEW_PIN		1	/* Ask for a new pin */
+#define SECURID_STATE_NEW_PIN_AGAIN	2	/* Ask for new pin again */
+#define SECURID_STATE_NEXT_CODE		3	/* Ask for the next pin code */
+	char	passcode[LENPRNST+1];		/* Previous passcode for _AGAIN */
+	struct SD_CLIENT sd_info;		/* SecurID state information */
+};
+
+
+/*	krb5_error_code get_securid_key():
+ *		inputs:  context:  from KDC process
+ *			 client:   database entry of client executing
+ *				   SecurID SAM preauthentication
+ *		outputs: client_securid_key: pointer to krb5_keyblock
+ *				   which is key for the client's SecurID
+ *				   database entry.
+ *		returns: 0 on success
+ *			 KRB5 error codes otherwise
+ *
+ *		builds pricipal name with final instance of "SECURID" and
+ *		finds the database entry, decrypts the key out of the database
+ *		and passes the key back to the calling process
+ */
+
+krb5_error_code get_securid_key(context, client, client_securid_key)
+    krb5_context context;
+    krb5_db_entry *client;
+    krb5_keyblock *client_securid_key;
+{
+    krb5_db_entry client_securid_entry;
+    krb5_key_data *client_securid_key_data = 0;
+    krb5_error_code retval = 0;
+    krb5_principal newp;
+    krb5_int32 slot = 0;
+    int nprinc, more;
+
+    retval = krb5_copy_principal(context, client->princ, &newp);
+    if (retval) {
+	com_err("krb5kdc", retval,
+		"copying client name for SecurID preauth probe");
+	return(KRB5_PREAUTH_NO_KEY);
+    }
+    slot = krb5_princ_size(context, newp)++;
+    krb5_princ_name(kdc_context, newp) =
+		realloc(krb5_princ_name(kdc_context, newp),
+		krb5_princ_size(context, newp) * sizeof(krb5_data));
+    krb5_princ_component(context,newp,slot)->data = "SECURID";
+    krb5_princ_component(context,newp,slot)->length =
+		strlen("SECURID");
+    nprinc = 1;
+    retval = krb5_db_get_principal(context, newp,
+		&client_securid_entry, &nprinc, &more);
+
+    /* Memory Management */
+    krb5_princ_component(context,newp,slot)->length = 0;
+    krb5_princ_component(context,newp,slot)->data = 0;
+    krb5_princ_size(context, newp)--;
+    krb5_free_principal(context,newp);
+
+    if (retval || (nprinc != 1)) {
+	com_err("krb5kdc", retval,
+		"Cannot find client's SecurID entry in database");
+	return(KRB5_PREAUTH_NO_KEY);
+    }
+    retval = krb5_dbe_find_enctype(context, &client_securid_entry,
+		ENCTYPE_DES_CBC_RAW, KRB5_KDB_SALTTYPE_NORMAL, 0,
+		&client_securid_key_data);
+    if (retval) {
+	com_err("krb5kdc", retval,
+		"Cannot find enc-type for client's SecurID entry");
+	return(KRB5_PREAUTH_NO_KEY);
+    }
+    retval = krb5_dbekd_decrypt_key_data(context, &master_encblock,
+		client_securid_key_data, client_securid_key, NULL);
+    if (retval) {
+	com_err("krb5kdc", retval,
+		"Cannot decrypt key for client's SecurID entry");
+	return(KRB5_PREAUTH_NO_KEY);
+    }
+    return(0);
+}
+
+/*  krb5_error_code get_securid_edata()
+ *		inputs:  context from KDC
+ *			 static sd_dat structure
+ *		outputs: sam_challenge structure contents to be encoded
+ *			 and sent as a AS_ERR message by calling routine
+ *		returns: 0 on success
+ *			 KRB5 error codes otherwise
+ *
+ *		This routine is called when insufficient preauth data is
+ *		sent to the KDC.  The edata returned is either a generic
+ *		SecurID prompt or a "Next Card Code" prompt with associated
+ *		(encrypted) sam_track_id data.  If SecurID card is in NEXT
+ *		PRN mode, the static sam_challenge struct will be non-null,
+ *		having been filled in by the call to verify_securid_data().
+ */
+
+krb5_error_code get_securid_edata(context, sc)
+    krb5_context context;
+    krb5_sam_challenge *sc;
+{
+    krb5_error_code retval = 0;
+
+    if (sam_challenge.sam_type != 0) {
+	sc->magic = KV5M_SAM_CHALLENGE;
+	sc->sam_type = sam_challenge.sam_type;
+	sc->sam_flags = sam_challenge.sam_flags;
+	sc->sam_type_name.length = sam_challenge.sam_type_name.length;
+	sc->sam_type_name.data = sam_challenge.sam_type_name.data;
+	sc->sam_track_id.length = sam_challenge.sam_track_id.length;
+	sc->sam_track_id.data = sam_challenge.sam_track_id.data;
+	sc->sam_challenge_label.length =
+		 sam_challenge.sam_challenge_label.length;
+	sc->sam_challenge_label.data = sam_challenge.sam_challenge_label.data;
+	sc->sam_challenge.length = sam_challenge.sam_challenge.length;
+	sc->sam_challenge.data = sam_challenge.sam_challenge.data;
+	sc->sam_response_prompt.length =
+		sam_challenge.sam_response_prompt.length;
+	sc->sam_response_prompt.data = sam_challenge.sam_response_prompt.data;
+	sc->sam_pk_for_sad.length = sam_challenge.sam_pk_for_sad.length;
+	sc->sam_pk_for_sad.data = sam_challenge.sam_pk_for_sad.data;
+	sc->sam_nonce = sam_challenge.sam_nonce;
+	sc->sam_cksum.checksum_type = sam_challenge.sam_cksum.checksum_type;
+	sc->sam_cksum.length = sam_challenge.sam_cksum.length;
+	sc->sam_cksum.contents = sam_challenge.sam_cksum.contents;
+    } else {
+	sc->sam_type_name.length = 0;
+	sc->sam_challenge_label.length = 0;
+	sc->sam_challenge.length = 0;
+	sc->sam_response_prompt.data = "SecurID Passcode";
+	sc->sam_response_prompt.length = strlen("SecurID Passcode");
+	sc->sam_pk_for_sad.length = 0;
+	sc->sam_nonce = 0;
+	sc->sam_cksum.contents = (char *)0;
+	sc->sam_cksum.length = 0;
+	sc->sam_flags = KRB5_SAM_SEND_ENCRYPTED_SAD;
+	sc->sam_track_id.length = 0;
+	sc->sam_track_id.data = (char *)0;
+	sc->sam_track_id.magic = 0;
+    }
+    return (retval);
+}
+
+/*	krb5_error_code verify_securid_data()
+ *		inputs:   context: context from KDC
+ *			  client: db entry of client executing SecurID preauth
+ *			  sr: sam_response from client
+ *			  enc_tkt_reply: encrypted part of TGT reply for
+ *					 setting flags
+ *		outputs:  static sam_challenge structure
+ *		returns:  0 if passcode check was successful (even if
+ *				card is in NEXT_PRN mode)
+ *			  KRB5_PREAUTH_FAILED for invalid SecurID code
+ *			  other KRB5 error codes
+ *
+ *		Zeroes out static sam_challenge structure, decrypts and
+ *		decodes enc_sam_response_enc (using client's "password")
+ *		to get passcode data.  If sam_track_id.data is present,
+ *		decrypt this data with client's SecurID key and use it as
+ *		sd_dat structure to pass to sd_next().  If sd_next is
+ *		successful, set enc_tkt_reply flags and return.  If no
+ *		sam_track_id.data is present, initialize SecurID communications
+ *		and check passcode.  If passcode is correct, set enc_tkt_reply
+ *		flags and return success, if card in NEXT_PRN mode, set
+ *		PREAUTH flag, but not HW_AUTH flag, build sam_challnge in
+ *		static space, and set sam_track_id to encrypted sd_dat struct.
+ *		get_securid_edata will pick this data up and pass it back in
+ *		AS_ERR message.
+ */
+
+krb5_error_code verify_securid_data(context, client, sr, enc_tkt_reply)
+    krb5_context context;
+    krb5_db_entry *client;
+    krb5_sam_response *sr;
+    krb5_enc_tkt_part *enc_tkt_reply;
+{
+    struct SD_CLIENT sd_dat, *sd;
+    struct securid_track_data s_track, *securid_track;
+    krb5_error_code retval = -1;
+    krb5_principal newp;
+    krb5_keyblock client_key;
+    krb5_keyblock client_securid_key;
+    krb5_data scratch, *tmp_data;
+    krb5_enc_data tmp_enc_data;
+    krb5_enc_sam_response_enc *esre = 0;
+    char passcode[LENPRNST+1];
+    char *user = (char *)0;
+    char *cp;
+
+    memset(&sam_challenge, 0, sizeof(sam_challenge));
+
+    retval = krb5_dbekd_decrypt_key_data(kdc_context, &master_encblock,
+              client->key_data, &client_key, NULL);
+    if (retval) {
+      com_err("krb5kdc",retval,"Cannot get client's key from database");
+      goto securid_cleanup;
+    }
+
+    client_key.enctype = sr->sam_enc_nonce_or_ts.enctype;
+    if (!(sr->sam_enc_nonce_or_ts.ciphertext.data)) {
+      com_err("krb5kdc",KRB5KDC_ERR_PREAUTH_FAILED,
+              "SecurID Preauth data not found");
+      goto securid_cleanup;
+    }
+
+    retval = krb5_decrypt_data(context, &client_key, 0,
+              &sr->sam_enc_nonce_or_ts, &scratch);
+
+    /* Memory Management */
+    krb5_free_keyblock_contents(context, &client_key);
+
+    if (retval) {
+        com_err("krb5kdc",retval,"cannot decrypt SecurID preauth data");
+        goto securid_cleanup;
+    }
+    retval = decode_krb5_enc_sam_response_enc(&scratch, &esre);
+    if (retval) {
+        com_err("krb5kdc",retval,"cannot decode SecurID preauth data");
+        goto securid_cleanup;
+    }
+
+    /* Check nonce */
+    if (esre->sam_nonce != sr->sam_nonce) {
+        com_err("krb5kdc",KRB5KDC_ERR_PREAUTH_FAILED,
+              "decryption of SecurID preauth data failed (nonce)");
+        goto securid_cleanup;
+    }
+    /* Check passcode */
+    if (!(esre->sam_passcode.length) || !(esre->sam_passcode.data) ) {
+        com_err("krb5kdc", KRB5KDC_ERR_PREAUTH_REQUIRED,
+              "No SecurID passcode");
+        retval = KRB5KDC_ERR_PREAUTH_FAILED;
+        goto securid_cleanup;
+    }
+    if (need_to_creadcfg) {
+      creadcfg();
+      need_to_creadcfg = 0;
+    }
+    memset(&sd_dat, 0, sizeof(sd_dat));
+
+    if (retval = krb5_unparse_name(context, client->princ, &user)) {
+        com_err("krb5kdc", retval, "Cannot unparse name for SecurID check");
+        return(retval);
+    }
+    if (cp = strchr(user, '@'))
+        *cp = (char )0;
+
+    if (sr->sam_track_id.length) {
+	krb5_data scratch1;
+
+        /* This is second time around to this routine, either NEXT_PRN
+         * or NEW_PIN
+         */
+	retval = get_securid_key(context, client, &client_securid_key);
+	if (retval) goto securid_cleanup;
+
+	tmp_enc_data.ciphertext.data = sr->sam_track_id.data;
+	tmp_enc_data.ciphertext.length = sr->sam_track_id.length;
+	tmp_enc_data.enctype = client_securid_key.enctype;
+	tmp_enc_data.kvno = 0;
+
+	retval = krb5_decrypt_data(context, &client_securid_key, 0,
+		&tmp_enc_data, &scratch1);
+
+	/* Memory Management */
+	krb5_free_keyblock_contents(context, &client_securid_key);
+
+	if (retval) {
+	  com_err("krb5kdc", retval, "cannot decrypt track_id data");
+	  return(retval);
+	}
+
+	securid_track = (struct securid_track_data *) scratch1.data;
+	sd = &(securid_track->sd_info);
+
+	if (esre->sam_passcode.length > LENPRNST) /* Avoid overrunning buffer */
+	  esre->sam_passcode.length = LENPRNST;
+	memcpy(&passcode, esre->sam_passcode.data, esre->sam_passcode.length);
+        passcode[esre->sam_passcode.length] = (char)0;
+
+	switch(securid_track->state) {
+	  case SECURID_STATE_NEW_PIN_AGAIN:
+		if (strcmp(passcode, securid_track->passcode) != 0) {
+		  retval = KRB5KDC_ERR_PREAUTH_FAILED;
+		  com_err("krb5kdc", retval, "PIN codes did not match");
+		  break;
+		}
+		retval = sd_pin(passcode, (char)0, sd);
+		if (retval == ACM_NEW_PIN_ACCEPTED) {
+		  com_err("krb5kdc",KRB5KDC_ERR_NONE, "New PIN Accepted");
+		  retval = 0;
+		} else
+		  com_err("krb5kdc",KRB5KDC_ERR_PREAUTH_FAILED,
+			  "New PIN Rejected");
+		break;
+	  case SECURID_STATE_NEXT_CODE:
+		retval = sd_next(passcode, sd);
+		if (retval == ACM_OK) {
+		  com_err("krb5kdc",KRB5KDC_ERR_NONE,"Next Code Accepted");
+		  retval = 0;
+		} else
+			com_err("krb5kdc",KRB5KDC_ERR_PREAUTH_FAILED,
+				"Next Code Rejected");
+		break;
+	  case SECURID_STATE_NEW_PIN:
+		retval = get_securid_key(context, client, &client_securid_key);
+		if (retval) goto securid_cleanup;
+
+		securid_track->state = SECURID_STATE_NEW_PIN_AGAIN;
+		strcpy(securid_track->passcode, passcode);
+		scratch.data = (char *)securid_track;
+                scratch.length = sizeof(sd_dat);
+
+                retval = krb5_encrypt_data(context, &client_securid_key, 0,
+                        &scratch, &tmp_enc_data);
+
+		/* Memory Management */
+                krb5_free_keyblock_contents(context, &client_securid_key);
+
+		if (retval) {
+                  com_err("krb5kdc",retval,"Cannot encrypt NEW PIN data");
+                  goto securid_cleanup;
+                }
+
+		sam_challenge.sam_type = sr->sam_type;
+                sam_challenge.sam_type_name.data = "SecurID";
+                sam_challenge.sam_type_name.length = strlen("SecurID");
+                sam_challenge.sam_flags = sr->sam_flags;
+                sam_challenge.sam_nonce = sr->sam_nonce;
+                sam_challenge.sam_track_id.length =
+                        tmp_enc_data.ciphertext.length;
+                sam_challenge.sam_track_id.data = tmp_enc_data.ciphertext.data;
+                sam_challenge.sam_challenge_label.data = "Enter New PIN again";
+		sam_challenge.sam_challenge_label.length =
+			strlen("Enter New PIN again");
+		sam_challenge.sam_response_prompt.data = "New PIN";
+		sam_challenge.sam_response_prompt.length =
+			strlen("New PIN");
+		sam_challenge.sam_challenge.length = 0;
+                sam_challenge.sam_cksum.contents = "1";
+                sam_challenge.sam_cksum.length = 1;
+		/* Do Checksum */
+                if (retval) goto securid_cleanup;
+
+                retval = 0;
+		goto nosetflag;
+                break;
+	  default:
+		com_err("krb5kdc",KRB5KDC_ERR_PREAUTH_FAILED,
+			"Can't figure out what to do with sam_track_id! (%d)",
+			securid_track->state);
+		retval = KRB5KDC_ERR_PREAUTH_FAILED;
+	}
+	if (retval) {
+	  krb5_xfree(scratch1.data);
+	  return(KRB5KDC_ERR_PREAUTH_FAILED);
+	}
+	setflag(enc_tkt_reply->flags, TKT_FLG_HW_AUTH);
+        setflag(enc_tkt_reply->flags, TKT_FLG_PRE_AUTH);
+nosetflag:
+	krb5_xfree(scratch1.data);
+        retval = 0;
+	return(retval);
+    } else {
+        /* Treat this as a first attempt at SecurID checking */
+	if (esre->sam_passcode.length > LENPRNST) /* Avoid overrunning buffer */
+	  esre->sam_passcode.length = LENPRNST;
+        memcpy(&passcode, esre->sam_passcode.data, esre->sam_passcode.length);
+        passcode[esre->sam_passcode.length] = (char)0;
+	if (need_to_sd_init) {
+	  need_to_sd_init = 0;
+          if (sd_init(&sd_dat)) {
+            retval = KRB5KDC_ERR_PREAUTH_FAILED;
+            com_err("krb5kdc", retval,
+			"Cannot initialize SecurID communications");
+            goto securid_cleanup;
+          }
+	}
+        retval = sd_check(passcode, user, &sd_dat);
+        switch(retval) {
+          case ACM_OK:
+                setflag(enc_tkt_reply->flags, TKT_FLG_HW_AUTH);
+                setflag(enc_tkt_reply->flags, TKT_FLG_PRE_AUTH);
+                retval = 0;
+                break;
+          case ACM_ACCESS_DENIED:
+#ifdef SLAVE
+		(void) sleep( (unsigned int)2);
+#endif
+                retval = KRB5_PREAUTH_FAILED;
+		com_err("krb5kdc", retval,
+			"ACE Server returned Access Denied");
+                break;
+          case ACM_NEXT_CODE_REQUIRED:
+                /* Build track_id, encrypt in user/SECURID@REALM,
+                 *  set challange labels, run checksum, and send as
+                 * KRB_ERROR to user
+                 */
+                retval = get_securid_key(context, client, &client_securid_key);
+		if (retval) goto securid_cleanup;
+
+		/* 
+		 * Our track_id now has the state built into it, so
+		 * let's use that.
+		 */
+
+		s_track.state = SECURID_STATE_NEXT_CODE;
+		memcpy(&s_track.sd_info, &sd_dat, sizeof(sd_dat));
+
+                scratch.data = (char *)&s_track;
+                scratch.length = sizeof(s_track);
+
+                retval = krb5_encrypt_data(context, &client_securid_key, 0,
+                        &scratch, &tmp_enc_data);
+
+		/* Memory Management */
+		krb5_free_keyblock_contents(context, &client_securid_key);
+
+                if (retval) {
+                  com_err("krb5kdc",retval,"Cannot encrypt NEXT PRN data");
+                  goto securid_cleanup;
+                }
+                /* Do we really want to copy these or regenerate them ?? */
+                sam_challenge.sam_type = sr->sam_type;
+		sam_challenge.sam_type_name.data = "SecurID";
+		sam_challenge.sam_type_name.length = strlen("SecurID");
+                sam_challenge.sam_flags = sr->sam_flags;
+                sam_challenge.sam_nonce = sr->sam_nonce;
+                sam_challenge.sam_track_id.length =
+                        tmp_enc_data.ciphertext.length;
+                sam_challenge.sam_track_id.data = tmp_enc_data.ciphertext.data;
+                sam_challenge.sam_challenge_label.data = "Enter Next Cardcode";
+                sam_challenge.sam_challenge_label.length =
+                        strlen("Enter Next Cardcode");
+                sam_challenge.sam_response_prompt.data = "Next Cardcode";
+                sam_challenge.sam_response_prompt.length =
+                        strlen("Next Cardcode");
+                sam_challenge.sam_challenge.length = 0;
+                sam_challenge.sam_cksum.contents = "1";
+                sam_challenge.sam_cksum.length = 1;
+                /* sam_challenge.sam_cksum.contents = (krb5_octet *)
+                 *   malloc(krb5_checksum_size(context, CKSUMTYPE_RSA_MD5_DES));
+                 * if (sam_challenge.sam_cksum.contents == NULL) return(ENOMEM);
+                 * retval = krb5_calculate_checksum(context, CKSUMTYPE_RSA_MD5_DES,
+                 *      sam_challenge.sam_challenge.data,
+                 *      sam_challenge.sam_challenge.length,
+                 *      client_key->contents, client_key->length,
+                 *      &sam_challenge.sam_cksum);
+                 */
+                if (retval) {
+                        free(sam_challenge.sam_cksum.contents);
+                        return(retval);
+                }
+                if (retval) goto securid_cleanup;
+
+                retval = 0;
+                break;
+          case ACM_NEW_PIN_REQUIRED:
+                /* Build track_id, encrypt in user/SECURID@REALM,
+                 *  set challange labels, run checksum, and send as
+                 * KRB_ERROR to user
+                 */
+		if (sd_dat.user_selectable == CANNOT_CHOOSE_PIN)
+		  return(KRB5KDC_ERR_PREAUTH_FAILED);
+
+		retval = get_securid_key(context, client, &client_securid_key);
+		if (retval) goto securid_cleanup;
+
+		s_track.state = SECURID_STATE_NEW_PIN;
+		memcpy(&s_track.sd_info, &sd_dat, sizeof(sd_dat));
+
+                scratch.data = (char *)&s_track;
+                scratch.length = sizeof(s_track);
+
+                retval = krb5_encrypt_data(context, &client_securid_key, 0,
+                        &scratch, &tmp_enc_data);
+
+		/* Memory Management */
+                krb5_free_keyblock_contents(context, &client_securid_key);
+
+		if (retval) {
+                  com_err("krb5kdc",retval,"Cannot encrypt NEW PIN data");
+                  goto securid_cleanup;
+                }
+
+		sam_challenge.sam_type = sr->sam_type;
+                sam_challenge.sam_type_name.data = "SecurID";
+                sam_challenge.sam_type_name.length = strlen("SecurID");
+                sam_challenge.sam_flags = sr->sam_flags;
+                sam_challenge.sam_nonce = sr->sam_nonce;
+                sam_challenge.sam_track_id.length =
+                        tmp_enc_data.ciphertext.length;
+                sam_challenge.sam_track_id.data = tmp_enc_data.ciphertext.data;
+                sam_challenge.sam_challenge_label.data = "Select New PIN";
+		sam_challenge.sam_challenge_label.length =
+			strlen("Select New PIN");
+		sam_challenge.sam_response_prompt.data = "New PIN";
+		sam_challenge.sam_response_prompt.length =
+			strlen("New PIN");
+		sam_challenge.sam_challenge.length = 0;
+                sam_challenge.sam_cksum.contents = "1";
+                sam_challenge.sam_cksum.length = 1;
+		/* Do Checksum */
+                if (retval) goto securid_cleanup;
+
+                retval = 0;
+                break;
+	  default:
+		/* For any errors other than above, reset these and hopefully
+		 *   problems will clear up
+		 */
+		com_err("krb5kdc", KRB5_PREAUTH_FAILED,
+			"SecurID returned (%d)", retval);
+		need_to_creadcfg = 1;
+		need_to_sd_init = 1;
+        } /* switch(retval) */
+    }
+securid_cleanup:
+    if (esre) {
+      if (esre->sam_passcode.data)
+	krb5_xfree(esre->sam_passcode.data);
+      krb5_xfree(esre);
+    }
+    return(retval);
+}
+
Index: krb524/configure.in
diff -u krb5/krb524/configure.in:1.1.1.1 krb5/krb524/configure.in:1.2
@@ -6,6 +6,17 @@
 AC_PROG_INSTALL
 AC_PROG_AWK
 AC_TYPE_SIGNAL
+dnl
+dnl --with-afs-name-change enables code that supports the case where
+dnl the name of the realm (cell) changed when going from AFS to Kerberos 5
+dnl
+AC_ARG_WITH([afs-name-change],
+[  -with-afs-name-change	Support an AFS cell with a different name],
+if test "$withval" = yes; then
+	AC_DEFINE(KRB524_DO_AFS_CONV)
+fi)
+dnl
+dnl
 USE_KADMSRV_LIBRARY
 USE_GSSRPC_LIBRARY
 USE_GSSAPI_LIBRARY
Index: krb524/conv_princ.c
diff -u krb5/krb524/conv_princ.c:1.1.1.1 krb5/krb524/conv_princ.c:1.2
@@ -28,6 +28,10 @@
 #include <sys/signal.h>
 #include <netinet/in.h>
 
+#ifdef KRB524_DO_AFS_CONV
+#include <ctype.h>
+#endif
+
 #include <krb.h>
 
 #include "krb524.h"
@@ -45,5 +49,37 @@
 					prealm)))
 	  return ret;
      
-     return krb5_524_conv_principal(context, server, sname, sinst, dummy);
+     if ((ret = krb5_524_conv_principal(context, server, sname, sinst,
+					dummy)))
+	  return ret;
+
+#ifdef KRB524_DO_AFS_CONV
+
+#ifndef KRB524_AFS_SERVICE_NAME
+#define KRB524_AFS_SERVICE_NAME		"afs"
+#endif
+
+    /*
+     * If this request is for an afs ticket (service == KRB524_AFS_CONV)
+     * and had a non-null instance (which is assumed to be
+     * the afs cell name), and the REALMs on the user and service
+     * match, then we want to change the user's realm to be the
+     * afs cell name.
+     */
+
+    if ((strcmp(sname, KRB524_AFS_SERVICE_NAME) == 0) &&
+	(sinst && sinst[0]) &&
+	(strcmp(dummy, prealm) == 0)) {
+	
+	char *c;
+
+	strncpy(prealm, sinst, REALM_SZ);
+	prealm[REALM_SZ - 1] = NULL;	/* Just to be sure... */
+
+	for (c = prealm; *c != NULL; c++)
+	    *c = (char) toupper((int) *c);
+    }
+#endif /* KRB524_DO_AFS_CONV */
+
+    return ret;
 }
Index: krb524/krb524d.c
diff -u krb5/krb524/krb524d.c:1.1.1.1 krb5/krb524/krb524d.c:1.2
@@ -88,10 +88,13 @@
      struct servent *serv;
      struct sockaddr_in saddr;
      struct timeval timeout;
-     int ret, s;
-     fd_set rfds;
+     int ret, s, i, numfds, maxfd;
+     fd_set rfds, select_fds;
      krb5_context context;
      krb5_error_code retval;
+     int *addr_fds = NULL;
+     krb5_address **localaddrs;
+     const int on = 1;
 
      retval = krb5_init_context(&context);
      if (retval) {
@@ -128,6 +131,12 @@
 	  /* someday maybe there will be some config param options */
 	  init_master(context, NULL);
 
+     /*
+      * We need to bind to all of interface addresses, in addition to
+      * wildcard address, so we can reply to messages using the correct
+      * source address
+      */
+
      memset((char *) &saddr, 0, sizeof(struct sockaddr_in));
      saddr.sin_family = AF_INET;
      saddr.sin_addr.s_addr = INADDR_ANY;
@@ -142,19 +151,77 @@
 	  com_err(whoami, errno, "creating main socket");
 	  cleanup_and_exit(1, context);
      }
+
+     /*
+      * Set SO_REUSEADDR so that we can bind to the non-wildcard addresses
+      * later
+      */
+
+     if ((ret = setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char *) &on,
+			   sizeof(on))) < 0) {
+	  com_err(whoami, errno, "setting SO_REUSEADDR on main socket");
+     }
+
      if ((ret = bind(s, (struct sockaddr *) &saddr,
 		     sizeof(struct sockaddr_in))) < 0) {
 	  com_err(whoami, errno, "binding main socket");
 	  cleanup_and_exit(1, context);
      }
-     
+
+     numfds = 1;
+     addr_fds = (int *) malloc(sizeof(int));
+     addr_fds[0] = s;
+     maxfd = s + 1;
+     FD_ZERO(&select_fds);
+     FD_SET(s, &select_fds);
+
+     /*
+      * Now lets go through and bind a socket to each interface
+      */
+
+     if ((ret = krb5_os_localaddr(context, &localaddrs)) != 0) {
+	  com_err(whoami, ret, "getting local addresses");
+	  cleanup_and_exit(1, context);
+     }
+
+     for (i = 0; localaddrs[i] != NULL; i++) {
+	  if (localaddrs[i]->addrtype == ADDRTYPE_INET) {
+	       memcpy((char *) &saddr.sin_addr, localaddrs[i]->contents,
+		      localaddrs[i]->length);
+	       if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
+		    com_err(whoami, errno, "creating interface socket");
+		    cleanup_and_exit(1, context);
+	       }
+	       if ((ret = setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char *) &on,
+				     sizeof(on))) < 0) {
+		    com_err(whoami, errno, "setting SO_REUSEADDR on interface socket");
+	       }
+	       if ((ret = bind(s, (struct sockaddr *) &saddr,
+			       sizeof(struct sockaddr))) < 0) {
+		    com_err(whoami, errno, "binding on interface socket");
+		    cleanup_and_exit(1, context);
+	       }
+	       numfds++;
+	       addr_fds = (int *) realloc(addr_fds, numfds * sizeof(int));
+	       if (addr_fds == NULL) {
+		    com_err(whoami, ENOMEM, "allocating descriptor memory");
+		    cleanup_and_exit(1, context);
+	       }
+	       addr_fds[numfds - 1] = s;
+	       FD_SET(s, &select_fds);
+	       if (s + 1 > maxfd)
+		    maxfd = s + 1;
+	  }
+     }
+
+     krb5_free_addresses(context, localaddrs);
+
      while (1) {
-	  FD_ZERO(&rfds);
-	  FD_SET(s, &rfds);
+	  rfds = select_fds;
 	  timeout.tv_sec = TIMEOUT;
 	  timeout.tv_usec = 0;
 
-	  ret = select(s+1, &rfds, NULL, NULL, &timeout);
+	  ret = select(maxfd, &rfds, NULL, NULL, &timeout);
 	  if (signalled)
 	       cleanup_and_exit(0, context);
 	  else if (ret == 0) {
@@ -168,14 +235,17 @@
 	  } else if (ret < 0 && errno != EINTR) {
 	       com_err(whoami, errno, "in select");
 	       cleanup_and_exit(1, context);
-	  } else if (FD_ISSET(s, &rfds)) {
-	       if (debug)
-		    printf("received packet\n");
-	       if ((ret = do_connection(s, context))) {
-		    com_err(whoami, ret, "handling packet");
+	  } else if (ret > 0) {
+	       for (i = 0; i < numfds; i++) {
+		    if (FD_ISSET(addr_fds[i], &rfds)) {
+			 if (debug)
+			      printf("received packet\n");
+			 if ((ret = do_connection(addr_fds[i], context))) {
+			      com_err(whoami, ret, "handling packet");
+			 }
+		    }
 	       }
-	  } else
-	       com_err(whoami, 0, "impossible situation occurred!");
+	  }
      }
 
      cleanup_and_exit(0, context);
Index: lib/gssapi/generic/configure.in
diff -u krb5/lib/gssapi/generic/configure.in:1.1.1.1 krb5/lib/gssapi/generic/configure.in:1.2
@@ -4,7 +4,7 @@
 AC_PROG_AWK
 V5_SHARED_LIB_OBJS
 SubdirLibraryRule([${OBJS}])
-AC_CHECK_HEADERS(stdlib.h sys/types.h limits.h)
+AC_CHECK_HEADERS(stdlib.h sys/types.h limits.h memory.h)
 AC_SIZE_T
 AC_CHECK_SIZEOF(short)
 AC_CHECK_SIZEOF(int)
Index: lib/gssapi/generic/util_token.c
diff -u krb5/lib/gssapi/generic/util_token.c:1.1.1.1 krb5/lib/gssapi/generic/util_token.c:1.2
@@ -21,7 +21,9 @@
  */
 
 #include "gssapiP_generic.h"
+#ifdef HAVE_MEMORY_H
 #include <memory.h>
+#endif
 
 /*
  * $Id$
Index: lib/gssapi/krb5/accept_sec_context.c
diff -u krb5/lib/gssapi/krb5/accept_sec_context.c:1.1.1.2 krb5/lib/gssapi/krb5/accept_sec_context.c:1.3
@@ -21,7 +21,9 @@
  */
 
 #include "gssapiP_krb5.h"
+#ifdef HAVE_MEMORY_H
 #include <memory.h>
+#endif
 
 /*
  * $Id$
Index: lib/gssapi/krb5/configure.in
diff -u krb5/lib/gssapi/krb5/configure.in:1.1.1.1 krb5/lib/gssapi/krb5/configure.in:1.2
@@ -2,7 +2,7 @@
 CONFIG_RULES
 AC_PROG_AWK
 AC_PROG_INSTALL
-AC_CHECK_HEADERS(stdlib.h)
+AC_CHECK_HEADERS(stdlib.h memory.h)
 V5_SHARED_LIB_OBJS
 SubdirLibraryRule([${OBJS}])
 CopySrcHeader(gssapi_krb5.h,[$](BUILDTOP)/include/gssapi)
Index: lib/gssapi/krb5/gssapiP_krb5.h
diff -u krb5/lib/gssapi/krb5/gssapiP_krb5.h:1.1.1.2 krb5/lib/gssapi/krb5/gssapiP_krb5.h:1.3
@@ -32,7 +32,9 @@
 #else
 #include <krb5.h>
 #endif
+#ifdef HAVE_MEMORY_H
 #include <memory.h>
+#endif
 
 /* work around sunos braindamage */
 #ifdef major
Index: lib/gssapi/krb5/init_sec_context.c
diff -u krb5/lib/gssapi/krb5/init_sec_context.c:1.1.1.2 krb5/lib/gssapi/krb5/init_sec_context.c:1.2
@@ -21,7 +21,9 @@
  */
 
 #include "gssapiP_krb5.h"
+#ifdef HAVE_MEMORY_H
 #include <memory.h>
+#endif
 #include <stdlib.h>
 
 /*
Index: lib/gssapi/krb5/k5unseal.c
diff -u krb5/lib/gssapi/krb5/k5unseal.c:1.1.1.1 krb5/lib/gssapi/krb5/k5unseal.c:1.2
@@ -21,7 +21,9 @@
  */
 
 #include "gssapiP_krb5.h"
+#ifdef HAVE_MEMORY_H
 #include <memory.h>
+#endif
 
 /*
  * $Id$
Index: lib/gssapi/krb5/util_cksum.c
diff -u krb5/lib/gssapi/krb5/util_cksum.c:1.1.1.1 krb5/lib/gssapi/krb5/util_cksum.c:1.2
@@ -25,7 +25,9 @@
  */
 
 #include "gssapiP_krb5.h"
+#ifdef HAVE_MEMORY_H
 #include <memory.h>
+#endif
 
 krb5_error_code
 kg_checksum_channel_bindings(context, cb, cksum, bigend)
Index: lib/gssapi/krb5/util_crypt.c
diff -u krb5/lib/gssapi/krb5/util_crypt.c:1.1.1.1 krb5/lib/gssapi/krb5/util_crypt.c:1.2
@@ -21,7 +21,9 @@
  */
 
 #include "gssapiP_krb5.h"
+#ifdef HAVE_MEMORY_H
 #include <memory.h>
+#endif
 
 /*
  * $Id$
Index: lib/gssapi/krb5/util_seed.c
diff -u krb5/lib/gssapi/krb5/util_seed.c:1.1.1.1 krb5/lib/gssapi/krb5/util_seed.c:1.2
@@ -21,7 +21,9 @@
  */
 
 #include "gssapiP_krb5.h"
+#ifdef HAVE_MEMORY_H
 #include <memory.h>
+#endif
 
 /*
  * $Id$
Index: lib/kadm5/admin.h
diff -u krb5/lib/kadm5/admin.h:1.1.1.2 krb5/lib/kadm5/admin.h:1.3
@@ -94,6 +94,7 @@
 #define KADM5_CONFIG_ADMIN_SERVER	0x010000
 #define KADM5_CONFIG_DICT_FILE		0x020000
 #define KADM5_CONFIG_MKEY_FROM_KBD	0x040000
+#define KADM5_CONFIG_KPASSWD_PORT	0x080000
    
 /*
  * permission bits
@@ -187,6 +188,7 @@
      char *		realm;
      char *		profile;
      int		kadmind_port;
+     int		kpasswd_port;
 
      char *		admin_server;
 
Index: lib/kadm5/alt_prof.c
diff -u krb5/lib/kadm5/alt_prof.c:1.1.1.1 krb5/lib/kadm5/alt_prof.c:1.2
@@ -455,6 +455,23 @@
 	 }
     }
     
+    /* Get the value for the kpasswd port */
+    if (! (params.mask & KADM5_CONFIG_KPASSWD_PORT)) {
+	 hierarchy[2] = "kpasswd_port";
+	 if (params_in->mask & KADM5_CONFIG_KPASSWD_PORT) {
+	      params.mask |= KADM5_CONFIG_KPASSWD_PORT;
+	      params.kpasswd_port = params_in->kpasswd_port;
+	 } else if (aprofile &&
+		    !krb5_aprof_get_int32(aprofile, hierarchy, TRUE,
+					  &ivalue)) { 
+	      params.kpasswd_port = ivalue;
+	      params.mask |= KADM5_CONFIG_KPASSWD_PORT;
+	 } else {
+	      params.kpasswd_port = DEFAULT_KPASSWD_PORT;
+	      params.mask |= KADM5_CONFIG_KPASSWD_PORT;
+	 }
+    }
+
     /* Get the value for the master key name */
 	 hierarchy[2] = "master_key_name";
     if (params_in->mask & KADM5_CONFIG_MKEY_NAME) {
Index: lib/kadm5/chpass_util.c
diff -u krb5/lib/kadm5/chpass_util.c:1.1.1.2 krb5/lib/kadm5/chpass_util.c:1.3
@@ -8,7 +8,9 @@
 
 
 #include <stdio.h>
+#ifdef HAVE_MEMORY_H
 #include <memory.h>
+#endif
 #include <time.h>
 
 #include <kadm5/admin.h>
Index: lib/kadm5/configure.in
diff -u krb5/lib/kadm5/configure.in:1.1.1.1 krb5/lib/kadm5/configure.in:1.2
@@ -8,7 +8,7 @@
 AC_PROG_INSTALL
 AC_PROG_LEX
 AC_PROG_AWK
-AC_CHECK_HEADERS(syslog.h)
+AC_CHECK_HEADERS(syslog.h memory.h)
 AC_CHECK_FUNCS(openlog syslog closelog strftime vsprintf)
 V5_SHARED_LIB_OBJS
 
Index: lib/kadm5/server_internal.h
diff -u krb5/lib/kadm5/server_internal.h:1.1.1.2 krb5/lib/kadm5/server_internal.h:1.3
@@ -13,7 +13,9 @@
 #ifndef __KADM5_SERVER_INTERNAL_H__
 #define __KADM5_SERVER_INTERNAL_H__
 
+#ifdef HAVE_MEMORY_H
 #include    <memory.h>
+#endif
 #include    <stdlib.h>
 #include    "k5-int.h"
 #include    <krb5/kdb.h>
Index: lib/kadm5/clnt/client_init.c
diff -u krb5/lib/kadm5/clnt/client_init.c:1.1.1.2 krb5/lib/kadm5/clnt/client_init.c:1.3
@@ -10,7 +10,9 @@
 
 #include <stdio.h>
 #include <netdb.h>
+#ifdef HAVE_MEMORY_H
 #include <memory.h>
+#endif
 #include <string.h>
 #include <com_err.h>
 #include <sys/types.h>
Index: lib/kadm5/clnt/client_principal.c
diff -u krb5/lib/kadm5/clnt/client_principal.c:1.1.1.2 krb5/lib/kadm5/clnt/client_principal.c:1.3
@@ -11,7 +11,9 @@
 #include    <rpc/rpc.h>
 #include    <kadm5/admin.h>
 #include    <kadm5/kadm_rpc.h>
+#ifdef HAVE_MEMORY_H
 #include    <memory.h>
+#endif
 #include    "client_internal.h"
 
 kadm5_ret_t
Index: lib/kadm5/clnt/client_rpc.c
diff -u krb5/lib/kadm5/clnt/client_rpc.c:1.1.1.1 krb5/lib/kadm5/clnt/client_rpc.c:1.2
@@ -2,7 +2,9 @@
 #include <kadm5/kadm_rpc.h>
 #include <krb5.h>
 #include <kadm5/admin.h>
+#ifdef HAVE_MEMORY_H
 #include <memory.h>
+#endif
 
 /* Default timeout can be changed using clnt_control() */
 static struct timeval TIMEOUT = { 25, 0 };
Index: lib/kadm5/clnt/configure.in
diff -u krb5/lib/kadm5/clnt/configure.in:1.1.1.1 krb5/lib/kadm5/clnt/configure.in:1.2
@@ -5,6 +5,7 @@
 AC_PROG_RANLIB
 AC_PROG_INSTALL
 V5_SHARED_LIB_OBJS
+AC_CHECK_HEADERS(memory.h)
 V5_MAKE_SHARED_LIB(libkadm5clnt, 1.0, ../.., ./kadm5/clnt)
 
 GSSRPC_SH_VERS=$krb5_cv_shlib_version_libgssrpc
Index: lib/kadm5/srv/Makefile.in
diff -u krb5/lib/kadm5/srv/Makefile.in:1.1.1.1 krb5/lib/kadm5/srv/Makefile.in:1.2
@@ -64,8 +64,8 @@
 all-mac:: $(OBJS)
 all-windows:: $(OBJS)
 
-LIBDONE=../DONE DONE
-LIB_SUBDIRS=.. .
+LIBDONE=../DONE DONE @CRACKLIB_DONE@
+LIB_SUBDIRS=.. . @CRACKLIB_SUBDIR@
 
 shared:
 	mkdir shared
Index: lib/kadm5/srv/adb_free.c
diff -u krb5/lib/kadm5/srv/adb_free.c:1.1.1.2 krb5/lib/kadm5/srv/adb_free.c:1.3
@@ -4,6 +4,15 @@
  * $Header$
  * 
  * $Log$
+ * Revision 1.3  1997/11/03 22:14:38  kenh
+ * Fix up conflicts from Release 1.0.2 import.
+ *
+ * Revision 1.2  1997/09/18 20:38:30  vwelch
+ * ConvexOS Port.
+ *
+ * Revision 1.1.1.1  1997/06/02 21:56:07  kenh
+ * Initial import of R1.0 from MIT.
+ *
  * Revision 1.1.1.2  1997/11/03 21:35:31  kenh
  * Import of Kerberos 5, Release 1.0.2
  *
@@ -55,7 +64,9 @@
 #endif
 
 #include	"adb.h"
+#ifdef HAVE_MEMORY_H
 #include	<memory.h>
+#endif
 #include	<stdlib.h>
 
 void
Index: lib/kadm5/srv/adb_xdr.c
diff -u krb5/lib/kadm5/srv/adb_xdr.c:1.1.1.2 krb5/lib/kadm5/srv/adb_xdr.c:1.3
@@ -13,7 +13,9 @@
 #include <rpc/rpc.h>
 #include "adb.h"
 #include "admin_xdr.h"
+#ifdef HAVE_MEMORY_H
 #include <memory.h>
+#endif
 
 bool_t
 xdr_krb5_key_data(XDR *xdrs, krb5_key_data *objp)
Index: lib/kadm5/srv/configure.in
diff -u krb5/lib/kadm5/srv/configure.in:1.1.1.1 krb5/lib/kadm5/srv/configure.in:1.4
@@ -7,6 +7,26 @@
 AC_PROG_LEX
 AC_PROG_AWK
 
+dnl Use cracklib?
+AC_ARG_WITH([cracklib],
+	[  --with-cracklib               Use cracklib for password checking],
+	use_cracklib=$withval,
+	use_cracklib="false")
+
+if test "$use_cracklib" != false ; then
+	cracklib_dir="cracklib"
+	AC_DEFINE(KADM5_USE_CRACKLIB)
+	CRACKLIB_SUBDIR=$cracklib_dir
+	CRACKLIB_DONE=$cracklib_dir/DONE
+	CONFIG_DIRS($cracklib_dir)
+	DO_SUBDIRS
+else
+	CRACKLIB_SUBDIR=""
+	CRACKLIB_DONE=""
+fi
+AC_SUBST(CRACKLIB_SUBDIR)
+AC_SUBST(CRACKLIB_DONE)
+
 save_LIBS="$LIBS"
 LIBS=-lgen
 AC_CHECK_FUNCS(compile step)
@@ -26,6 +46,7 @@
 	;;
 esac
 
+AC_CHECK_HEADERS(memory.h)
 V5_SHARED_LIB_OBJS
 V5_MAKE_SHARED_LIB(libkadm5srv, 1.0, ../.., ./kadm5/srv)
 
@@ -43,6 +64,8 @@
 AC_SUBST(COMERR_SH_VERS)
 DYN_SH_VERS=$krb5_cv_shlib_version_libdyn
 AC_SUBST(DYN_SH_VERS)
+
+
 
 SubdirLibraryRule([$(OBJS)])
 
Index: lib/kadm5/srv/server_dict.c
diff -u krb5/lib/kadm5/srv/server_dict.c:1.1.1.2 krb5/lib/kadm5/srv/server_dict.c:1.5
@@ -17,13 +17,23 @@
 #include    <stdlib.h>
 #include    <stdio.h>
 #include    <string.h>
+#ifdef HAVE_MEMORY_H
 #include    <memory.h>
+#endif
 #include    <syslog.h>
 #include    "server_internal.h"
 
+#ifndef KADM5_USE_CRACKLIB
 static char	    **word_list = NULL;	    /* list of word pointers */
 static char	    *word_block = NULL;	    /* actual word data */
 static int	    word_count = 0;	    /* number of words */
+
+#else /* KADM5_USE_CRACKLIB */
+static char		*dict_path = NULL;
+extern char 		*FascistCheck();
+
+#endif /* KADM5_USE_CRACKLIB */
+
 extern int	    errno;
 
 /*
@@ -47,6 +57,7 @@
     return (strcasecmp(*(char **)s1, *(char **)s2));
 }
 
+#ifndef KADM5_USE_CRACKLIB
 /*
  * Function: init-dict
  * 
@@ -196,3 +207,81 @@
 	word_count = 0;
     return;
 }
+
+#else /* KADM5_USE_CRACKLIB */
+
+/*
+ * Get dictionary file path from params, check it and store for later
+ * use by find_word().
+ */
+int init_dict(kadm5_config_params *params)
+{
+    struct stat st;
+    char *dict_file;
+
+
+    if (dict_path)	/* Already been initialized */
+	return KADM5_OK;
+
+    if (! (params->mask & KADM5_CONFIG_DICT_FILE)) {
+	syslog(LOG_INFO, "No dictionary file specified, continuing "
+	       "without one.");
+	return KADM5_OK;
+    }
+
+    /*
+     * Check for one of the cracklib dictionary files. We'll
+     * assume that if it's there, then the other two are.
+     *
+     * Note that for cracklib the path specified is just the
+     * prefix filename. The actual files will be the path
+     * plus an appened ".hwm", ".pwd", and ".pwi".
+     */
+     
+    dict_file = malloc(strlen(params->dict_file) + 5);
+    
+    if (dict_file == NULL) {
+	syslog(LOG_ERR, "malloc() failed.");
+	return errno;
+    }
+
+    strcpy(dict_file, params->dict_file);
+    strcat(dict_file, ".hwm");
+
+    if (stat(dict_file, &st) == 0) {
+	dict_path = params->dict_file;
+	syslog(LOG_INFO, "Using cracklib dictionary with prefix %s", dict_path);
+    } else {
+	syslog(LOG_ERR, "WARNING!  Cannot find cracklib dictionary file %s, "
+	       "continuing without one.", dict_file);
+    }
+
+    free(dict_file);
+    return KADM5_OK;
+}
+  
+int
+find_word(const char *word)
+{
+    char *msg;
+
+
+    if (dict_path == NULL)
+	return WORD_NOT_FOUND;
+
+    if (msg = FascistCheck(word, dict_path)) {
+	syslog(LOG_INFO, "cracklib rejected new change: %s", msg);
+	return KADM5_OK;
+    } else {
+	return WORD_NOT_FOUND;
+    }
+}
+
+void
+destroy_dict(void)
+{
+    dict_path = NULL;
+    return;
+}
+
+#endif /* KADM5_USE_CRACKLIB */
Index: lib/kadm5/srv/svr_principal.c
diff -u krb5/lib/kadm5/srv/svr_principal.c:1.1.1.3 krb5/lib/kadm5/srv/svr_principal.c:1.5
@@ -212,13 +212,6 @@
 	return(ret);
     }
 
-    if (ret = krb5_dbe_update_last_pwd_change(handle->context, &kdb, now)) {
-	krb5_dbe_free_contents(handle->context, &kdb);
-	if (mask & KADM5_POLICY)
-	     (void) kadm5_free_policy_ent(handle->lhandle, &polent);
-	return(ret);
-    }
-
     /* initialize the keys */
 
     if (ret = krb5_dbe_cpw(handle->context, &master_encblock,
@@ -365,7 +358,7 @@
 
     CHECK_HANDLE(server_handle);
 
-    if((mask & KADM5_PRINCIPAL) || (mask & KADM5_LAST_PWD_CHANGE) ||
+    if((mask & KADM5_PRINCIPAL) ||
        (mask & KADM5_MOD_TIME) || (mask & KADM5_MOD_NAME) ||
        (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||
        (mask & KADM5_KEY_DATA) || (mask & KADM5_LAST_SUCCESS) ||
@@ -534,6 +527,19 @@
 	      kdb.tl_data = tl;
 	      tl2 = tl2->tl_data_next;
 	 }
+    }
+
+    /*
+     * I'm not sure if client programs should be forced to modify the
+     * TL_DATA directly, or use the obvious mechanism of modifying
+     * KADM5_LAST_PW_CHANGE.  To me, the latter seems to make more
+     * sense.
+     */
+
+    if (mask & KADM5_LAST_PWD_CHANGE) {
+	if ((ret = krb5_dbe_update_last_pwd_change(handle->context, &kdb,
+						  entry->last_pwd_change)))
+	    goto done;
     }
 
     ret = kdb_put_entry(handle, &kdb, &adb);
Index: lib/kdb/configure.in
diff -u krb5/lib/kdb/configure.in:1.1.1.1 krb5/lib/kdb/configure.in:1.2
@@ -16,6 +16,16 @@
 	LIBS="$LIBS -ldb"
 	;;
 esac
+dnl
+dnl --with-afs-name-change enables code that supports the case where
+dnl the name of the realm (cell) changed when going from AFS to Kerberos 5
+dnl
+AC_ARG_WITH([afs-name-change],
+[  -with-afs-name-change	Support an AFS cell with a different name],
+if test "$withval" = yes; then
+	AC_DEFINE(CPW_PRESERVE_AFS_SALT)
+fi)
+dnl
 KRB5_RUN_FLAGS
 V5_USE_SHARED_LIB
 KRB5_LIBRARIES
Index: lib/kdb/kdb_cpw.c
diff -u krb5/lib/kdb/kdb_cpw.c:1.1.1.1 krb5/lib/kdb/kdb_cpw.c:1.3
@@ -27,6 +27,11 @@
 #include <stdio.h>
 #include <errno.h>
 
+#ifdef CPW_PRESERVE_AFS_SALT
+static char *default_afs_key_salt = NULL;
+static char *afs_key_salt;
+#endif
+
 static int
 get_key_data_kvno(context, count, data)
     krb5_context	  context;
@@ -391,7 +396,22 @@
             key_salt.data.length = 0;
             key_salt.data.data = 0;
             break;
-    	case KRB5_KDB_SALTTYPE_AFS3: {
+    	case KRB5_KDB_SALTTYPE_AFS3:
+#ifdef CPW_PRESERVE_AFS_SALT
+	    /*
+	     * If a salt string for AFS was specified then use it instead
+	     * of calling krb5_princ_realm()
+	     */
+	if (afs_key_salt) {
+	    key_salt.data.data = strdup(afs_key_salt);
+	    if (!key_salt.data.data)
+		return ENOMEM; 
+
+	    key_salt.data.length = -1;
+		
+	} else
+#endif /* CPW_PRESERVE_AFS_SALT */
+	{
             krb5_data * saltdata;
             if (retval = krb5_copy_data(context, krb5_princ_realm(context,
 					db_entry->princ), &saltdata))
@@ -416,8 +436,17 @@
 	}
 
 	if (key_salt.data.length == -1)
-	    key_salt.data.length = 
-	      krb5_princ_realm(context, db_entry->princ)->length;
+#ifdef CPW_PRESERVE_AFS_SALT
+	    /*
+	     * Again, use specified salt string, if specified, instead
+	     * of krb5_princ_realm().
+	     */
+	    if (afs_key_salt)
+		key_salt.data.length = strlen(afs_key_salt);
+	    else	
+#endif /* CPW_PRESERVE_AFS_SALT */
+		key_salt.data.length = 
+		    krb5_princ_realm(context, db_entry->princ)->length;
 
 	if (retval = krb5_dbekd_encrypt_key_data(context, master_eblock, &key,
 		     (const krb5_keysalt *)&key_salt,
@@ -464,6 +493,68 @@
     db_entry->key_data = NULL;
     db_entry->n_key_data = 0;
 
+#ifdef CPW_PRESERVE_AFS_SALT
+    /*
+     * See if the user has an old AFS key and if so then we'll use it's
+     * salt to salt their new AFS key.
+     *
+     * If the user doesn't have an old AFS key then check the krb5.conf
+     * file for a default string to use. If it's there then use it.
+     *
+     * Otherwise then just leave afs_key_salt NULL and the default will
+     * be used.
+     *
+     */
+    {
+	int i;
+
+	afs_key_salt = NULL;
+
+	/* Check for an old AFS key */
+	for (i = 0; i < key_data_count; i++) {
+	    if ((key_data[i].key_data_type[1] == KRB5_KDB_SALTTYPE_AFS3) &&
+		key_data[i].key_data_length[1]) {
+
+		int len = key_data[i].key_data_length[1];
+		
+		/*
+		 * We need to copy out the contents and terminate it with
+		 * a null, since it's not guarenteed to be null
+		 * terminated as it is.
+		 */
+		afs_key_salt = malloc(len + 1);
+
+		if (!afs_key_salt)
+		    return ENOMEM;	
+
+		memcpy(afs_key_salt, key_data[i].key_data_contents[1], len);
+		afs_key_salt[len] = '\0';
+	    }
+	}
+
+	if (!afs_key_salt) {
+	    /* Check for default in krb5.conf */
+	    const char *names[3];
+	    char **values = NULL;
+
+	    names[0] = "kdc";
+	    names[1] = "afs_salt";
+	    names[2] = NULL;
+
+	    retval = profile_get_values(context->profile, names, &values);
+	    if (retval == 0 && values && values[0])
+		afs_key_salt = strdup(values[0]);
+
+	    if (values) {
+		char **cpp;
+		for (cpp = values; *cpp; cpp++)
+			free(*cpp);
+		free(values);
+	    }
+	}
+    }
+#endif /* CPW_PRESERVE_AFS_SALT */
+
     /* increment the kvno.  if the requested kvno is too small, 
        increment the old kvno */
     if (new_kvno < old_kvno+1)
@@ -477,6 +568,12 @@
     } else {
 	cleanup_key_data(context, key_data_count, key_data);
     }
+#ifdef CPW_PRESERVE_AFS_SALT
+    if (afs_key_salt) {
+	free(afs_key_salt);
+	afs_key_salt = NULL;
+    }
+#endif
     return(retval);
 }
 
Index: lib/krb4/decomp_tkt.c
diff -u krb5/lib/krb4/decomp_tkt.c:1.1.1.1 krb5/lib/krb4/decomp_tkt.c:1.2
@@ -80,7 +80,7 @@
 	setbuf(fp, keybuf);
 	fwrite(tkt->dat, 1, tkt->length, fp);
 	fclose(fp);
-	memset(keybuf, sizeof(keybuf), 0);	/* Clear the buffer */
+	memset(keybuf, 0, sizeof(keybuf));	/* Clear the buffer */
     }
 #endif
     pcbc_encrypt((C_Block *)tkt->dat,(C_Block *)tkt->dat,
@@ -95,7 +95,7 @@
 	setbuf(fp, keybuf);
 	fwrite(tkt->dat, 1, tkt->length, fp);
 	fclose(fp);
-	memset(keybuf, sizeof(keybuf), 0);	/* Clear the buffer */
+	memset(keybuf, 0, sizeof(keybuf));	/* Clear the buffer */
     }
 #endif
 
Index: lib/krb4/g_krbrlm.c
diff -u krb5/lib/krb4/g_krbrlm.c:1.1.1.2 krb5/lib/krb4/g_krbrlm.c:1.3
@@ -12,6 +12,7 @@
 #include <stdio.h>
 #include "krb.h"
 #include <string.h>
+#include "k5-int.h"
 
 /*
  * krb_get_lrealm takes a pointer to a string, and a number, n.  It fills
@@ -44,7 +45,23 @@
     cnffile = krb__get_cnffile();
     if (!cnffile) {
 	if (n == 1) {
-	    (void) strcpy(r, KRB_REALM);
+	    krb5_context context;
+	    krb5_error_code retcode;
+	    char *realm = NULL;
+
+	    retcode = krb5_init_context(&context);
+
+	    if (retcode || krb5_get_default_realm(context, &realm)) {
+	        (void) strcpy(r, KRB_REALM);
+	    } else {
+		(void) strcpy(r, realm);
+	    }
+
+	    if (realm)
+		free(realm);
+
+	    if (! retcode)
+	        krb5_free_context(context);
 	    return(KSUCCESS);
 	}
 	else
Index: lib/krb5/krb/configure.in
diff -u krb5/lib/krb5/krb/configure.in:1.1.1.1 krb5/lib/krb5/krb/configure.in:1.3
@@ -5,7 +5,15 @@
 AC_PROG_RANLIB
 AC_HEADER_STDARG
 V5_SHARED_LIB_OBJS
-AC_HAVE_FUNCS(strftime strptime geteuid)
+AC_ARG_WITH([strptime],
+[  --with-strptime         Use native strptime(), if present (default)
+  --without-strptime      Always use included strptime()], ,with_strptime=yes)
+if test $with_strptime != no; then
+	AC_HAVE_FUNCS(strftime strptime geteuid)
+else
+	AC_HAVE_FUNCS(strftime geteuid)
+fi
+AC_CHECK_HEADERS(memory.h)
 KRB5_RUN_FLAGS
 SubdirLibraryRule([$(OBJS)])
 USE_ANAME
Index: lib/krb5/krb/conv_princ.c
diff -u krb5/lib/krb5/krb/conv_princ.c:1.1.1.1 krb5/lib/krb5/krb/conv_princ.c:1.2
@@ -67,6 +67,7 @@
     {"imap",	"imap",		DO_REALM_CONVERSION},
     {"ftp",	"ftp",		DO_REALM_CONVERSION},
     {"ecat",	"ecat",		DO_REALM_CONVERSION},
+    {"sunhpc",	"sunhpc",	DO_REALM_CONVERSION},
     {0,		0,		0},
 };
 
Index: lib/krb5/krb/fwd_tgt.c
diff -u krb5/lib/krb5/krb/fwd_tgt.c:1.1.1.2 krb5/lib/krb5/krb/fwd_tgt.c:1.4
@@ -23,7 +23,9 @@
 
 #define NEED_SOCKETS
 #include "k5-int.h"
+#ifdef HAVE_MEMORY_H
 #include <memory.h>
+#endif
 
 /* helper function: convert flags to necessary KDC options */
 #define flags2options(flags) (flags & KDC_TKT_COMMON_MASK)
Index: lib/krb5/krb/rd_cred.c
diff -u krb5/lib/krb5/krb/rd_cred.c:1.1.1.1 krb5/lib/krb5/krb/rd_cred.c:1.2
@@ -95,7 +95,7 @@
     if ((retval = decode_krb5_cred(pcreddata, &pcred)))
     	return retval;
 
-    memset(&encpart, sizeof(encpart), 0);
+    memset(&encpart, 0, sizeof(encpart));
 
     if ((retval = decrypt_credencdata(context, pcred, pkeyblock, &encpart)))
 	goto cleanup_cred;
Index: lib/krb5/krb/recvauth.c
diff -u krb5/lib/krb5/krb/recvauth.c:1.1.1.1 krb5/lib/krb5/krb/recvauth.c:1.2
@@ -87,7 +87,7 @@
 	 */
 	if ((retval = krb5_read_message(context, fd, &inbuf)))
 		return(retval);
-	if (strcmp(inbuf.data, appl_version)) {
+	if (appl_version && strcmp(inbuf.data, appl_version)) {
 		krb5_xfree(inbuf.data);
 		if (!problem)
 			problem = KRB5_SENDAUTH_BADAPPLVERS;
Index: lib/krb5/krb/str_conv.c
diff -u krb5/lib/krb5/krb/str_conv.c:1.1.1.1 krb5/lib/krb5/krb/str_conv.c:1.2
@@ -271,7 +271,7 @@
  * Rudimentary version of strptime for systems which don't have it.
  */
 static char *
-strptime(buf, format, tm)
+lstrptime(buf, format, tm)
     char *buf;
     const char *format;
     struct tm *tm;
@@ -360,6 +360,7 @@
     }
     return(bp);
 }
+#define strptime lstrptime
 #endif	/* HAVE_STRPTIME */
 
 /*
Index: lib/krb5/os/Makefile.in
diff -u krb5/lib/krb5/os/Makefile.in:1.1.1.1 krb5/lib/krb5/os/Makefile.in:1.2
@@ -10,6 +10,7 @@
 @SHARED_RULE@
 
 OBJS= \
+	appdefault.$(OBJEXT)	\
 	an_to_ln.$(OBJEXT)	\
 	def_realm.$(OBJEXT)	\
 	DNR.$(OBJEXT)	\
Index: lib/krb5/os/appdefault.c
diff -u /dev/null krb5/lib/krb5/os/appdefault.c:1.1
@@ -0,0 +1,181 @@
+/*
+ * appdefault - routines designed to be called from applications to
+ *		 handle the [appdefaults] profile section
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <k5-int.h>
+
+
+
+ /*xxx Duplicating this is annoying; try to work on a better way.*/
+static char *conf_yes[] = {
+	"y", "yes", "true", "t", "1", "on",
+	0,
+};
+
+static char *conf_no[] = {
+	"n", "no", "false", "nil", "0", "off",
+	0,
+};
+
+static int conf_boolean(s)
+	char *s;
+{
+	char **p;
+	for(p=conf_yes; *p; p++) {
+		if (!strcasecmp(*p,s))
+			return 1;
+	}
+	for(p=conf_no; *p; p++) {
+		if (!strcasecmp(*p,s))
+		return 0;
+	}
+	/* Default to "no" */
+	return 0;
+}
+
+static krb5_error_code appdefault_get(context, appname, realm, option,
+				ret_value)
+krb5_context context;
+	const char *appname, *option;
+const krb5_data *realm;
+	char **ret_value;
+{
+profile_t profile;
+const char *names[5];
+	char **nameval = NULL;
+	krb5_error_code retval;
+	const char * realmstr =  realm?realm->data:NULL;
+
+	    if (!context || (context->magic != KV5M_CONTEXT)) 
+	    return KV5M_CONTEXT;
+
+	    profile = context->profile;
+	    
+	/*
+	 * Try number one:
+	 *
+	 * [appdefaults]
+	 *	app = {
+	 *		SOME.REALM = {
+	 *			option = <boolean>
+	 *		}
+	 *	}
+	 */
+
+	names[0] = "appdefaults";
+	names[1] = appname;
+
+	if (realmstr) {
+		names[2] = realmstr;
+		names[3] = option;
+		names[4] = 0;
+		retval = profile_get_values(profile, names, &nameval);
+		if (retval == 0 && nameval && nameval[0]) {
+			*ret_value = strdup(nameval[0]);
+			goto goodbye;
+		}
+	}
+
+	/*
+	 * Try number two:
+	 *
+	 * [appdefaults]
+	 *	app = {
+	 *		option = <boolean>
+	 *      }
+	 */
+
+	names[2] = option;
+	names[3] = 0;
+	retval = profile_get_values(profile, names, &nameval);
+	if (retval == 0 && nameval && nameval[0]) {
+		*ret_value = strdup(nameval[0]);
+		goto goodbye;
+	}
+
+	/*
+	 * Try number three:
+	 *
+	 * [appdefaults]
+	 *	realm = {
+	 *		option = <boolean>
+	 */
+	
+	if (realmstr) {
+		names[1] = realmstr;
+		names[2] = option;
+		names[3] = 0;
+		retval = profile_get_values(profile, names, &nameval);
+		if (retval == 0 && nameval && nameval[0]) {
+			*ret_value = strdup(nameval[0]);
+			goto goodbye;
+		}
+	}
+
+	/*
+	 * Try number four:
+	 *
+	 * [appdefaults]
+	 *	option = <boolean>
+	 */
+
+	names[1] = option;
+	names[2] = 0;
+	retval = profile_get_values(profile, names, &nameval);
+	if (retval == 0 && nameval && nameval[0]) {
+		*ret_value = strdup(nameval[0]);
+	} else {
+		return retval;
+	}
+
+goodbye:
+	if (nameval) {
+		char **cpp;
+		for (cpp = nameval; *cpp; cpp++)
+			free(*cpp);
+		free(nameval);
+	}
+	return 0;
+}
+
+	 void krb5_appdefault_boolean(context, appname, realm, option,
+				     default_value, ret_value)
+	   krb5_context context;
+	const char *appname,  *option;
+	   const krb5_data *realm;
+	int default_value;
+	int *ret_value;
+{
+	char *string = NULL;
+	krb5_error_code retval;
+
+	retval = appdefault_get(context, appname, realm, option, &string);
+
+	if (! retval && string) {
+		*ret_value = conf_boolean(string);
+		free(string);
+	} else
+		*ret_value = default_value;
+}
+
+void krb5_appdefault_string(context, appname, realm, option, default_value,
+				ret_value)
+     krb5_context context;
+	const char *appname, *option, *default_value;
+	char **ret_value;
+     const krb5_data *realm;
+	{
+	krb5_error_code retval;
+	char *string;
+
+	retval = appdefault_get(context, appname, realm, option, &string);
+
+	if (! retval && string) {
+		*ret_value = string;
+	} else {
+		*ret_value = strdup(default_value);
+	}
+}
Index: lib/krb5/os/configure.in
diff -u krb5/lib/krb5/os/configure.in:1.1.1.1 krb5/lib/krb5/os/configure.in:1.2
@@ -26,6 +26,14 @@
 AC_HAVE_FUNCS(re_comp)
 AC_HEADER_EGREP(time_t, sys/types.h, AC_DEFINE(POSIX_TYPES))
 HAS_ANSI_VOLATILE
+dnl
+dnl --enable-app-proxy turns on support for application proxy gateways
+dnl
+AC_ARG_ENABLE([app-proxy],
+[  --enable-app-proxy      Support application proxy gateways],[
+echo "Enabling support for application proxy gateways"
+AC_DEFINE(PROXY_ALTERNATE_ADDRS)],[
+echo "No support for application proxy gateways"])
 AC_DEFINE(AN_TO_LN_RULES)
 USE_ANAME
 V5_SHARED_LIB_OBJS
Index: lib/krb5/os/localaddr.c
diff -u krb5/lib/krb5/os/localaddr.c:1.1.1.1 krb5/lib/krb5/os/localaddr.c:1.2
@@ -31,5 +31,139 @@
     krb5_context context;
     krb5_address ***addr;
 {
+#ifndef PROXY_ALTERNATE_ADDRS
     return krb5_crypto_os_localaddr(addr);
+#else /* PROXY_ALTERNATE_ADDRS */
+    int naddrs = 0, nproxies = 0, i, j, n;
+    krb5_address **local_addrs, ***proxy_addrs;
+    const char *proxy_names[3];
+    char **proxylist;
+    krb5_error_code code;
+
+    /*
+     * We need to add the IP addresses of any proxies given in the
+     * Kerberos configuration file to the "local" IP address.  First,
+     * let's see if we have any in the configuration file.
+     */
+
+    proxy_names[0] = "libdefaults";
+    proxy_names[1] = "proxy_gateway";
+    proxy_names[2] = NULL;
+
+    if (profile_get_values(context->profile, proxy_names, &proxylist)) {
+	return krb5_crypto_os_localaddr(addr);
+    }
+
+    /*
+     * We've got some proxy hosts in the config file.  First, let's figure
+     * out how many we're talking about and total them all up.
+     */
+
+    if ((code = krb5_crypto_os_localaddr(&local_addrs))) {
+	for (i = 0; proxylist[i]; i++) {
+	    free(proxylist[i]);
+	}
+	free(proxylist);
+	return code;
+    }
+
+    /*
+     * Total number of addreses for the local host
+     */
+
+    while (local_addrs[naddrs]) naddrs++;
+
+    /*
+     * Total number of _hosts_ that we're using as possible proxies
+     */
+
+    while (proxylist[nproxies]) nproxies++;
+
+    proxy_addrs = (krb5_address ***) malloc(sizeof(proxy_addrs) * nproxies);
+
+    if (! proxy_addrs) {
+	krb5_free_addresses(context, local_addrs);
+	for (i = 0; proxylist[i]; i++) {
+	    free(proxylist[i]);
+	}
+	free((char *) proxylist);
+	return ENOMEM;
+    }
+
+    /*
+     * Get all of the addresses for all of the proxy hosts.  Just total
+     * them all up for now; we need the total number to construct the
+     * address array.
+     */
+
+    for (i = 0; i < nproxies; i++) {
+
+	if (krb5_os_hostaddr(context, proxylist[i], &proxy_addrs[i])) {
+		proxy_addrs[i] = NULL;
+		continue;
+	}
+
+	for (j = 0; proxy_addrs[i][j]; j++)
+		naddrs++;
+
+	free(proxylist[i]);
+
+    }
+
+    free((char *) proxylist);
+
+    /*
+     * Build the final addresses array, using all of the addresses that
+     * we have.
+     */
+
+    *addr = (krb5_address **) malloc(sizeof(krb5_address *) * (naddrs + 1));
+
+    if (! *addr) {
+	krb5_free_addresses(context, local_addrs);
+
+	for (i = 0; i < nproxies; i++) {
+		if (proxy_addrs[i])
+			krb5_free_addresses(context, proxy_addrs[i]);
+	}
+	free((char *) proxy_addrs);
+
+	return ENOMEM;
+    }
+
+    n = 0;
+
+    /*
+     * First, the "real" local addresses.  Note that we only free the
+     * array memory, not the element memory (since we're just assinging
+     * pointers.
+     */
+
+    for (i = 0; local_addrs[i]; i++)
+	(*addr)[n++] = local_addrs[i];
+
+    free((char *) local_addrs);
+
+    /*
+     * Next, proxy addresses
+     */
+
+    for (i = 0; i < nproxies; i++) {
+	if (proxy_addrs[i]) {
+	    for (j = 0; proxy_addrs[i][j]; j++)
+		(*addr)[n++] = proxy_addrs[i][j];
+	    free((char *) proxy_addrs[i]);
+	}
+    }
+
+    free((char *) proxy_addrs);
+
+    /*
+     * Don't forget to NULL-terminate the array
+     */
+
+    (*addr)[n] = NULL;
+
+    return 0;
+#endif /* PROXY_ALTERNATE_ADDRS */
 }
Index: lib/krb5/posix/configure.in
diff -u krb5/lib/krb5/posix/configure.in:1.1.1.1 krb5/lib/krb5/posix/configure.in:1.2
@@ -5,6 +5,6 @@
 AC_CONST
 AC_HEADER_CHECK(paths.h,AC_DEFINE(HAS_PATHS_H))
 AC_HAVE_FUNCS(setenv unsetenv getenv)
-AC_REPLACE_FUNCS(vfprintf vsprintf strdup strcasecmp strerror memmove daemon getuid sscanf syslog)
+AC_REPLACE_FUNCS(vfprintf vsprintf strdup strcasecmp strerror memmove daemon getuid sscanf syslog writev)
 AC_FUNC_CHECK(setsid,AC_DEFINE(HAS_SETSID))
 V5_AC_OUTPUT_MAKEFILE
Index: lib/krb5/posix/writev.c
diff -u /dev/null krb5/lib/krb5/posix/writev.c:1.2
@@ -0,0 +1,24 @@
+/*
+ * I can't believe there are systems that _don't_ have writev, but I
+ * guess they do exist ...
+ */
+
+#include <stdio.h>
+
+int
+writev(fd, iov, iovcnt)
+	int fd;
+	struct iovec *iov;
+	int iovcnt;
+{
+	int i, count = 0, ret;
+
+	for (i = 0; i < iovcnt; i++) {
+		ret = write(fd, iov[i].iov_base, iov[i].iov_len);
+		if (ret == -1)
+			return -1;
+		count += ret;
+	}
+
+	return count;
+}
Index: lib/rpc/configure.in
diff -u krb5/lib/rpc/configure.in:1.1.1.1 krb5/lib/rpc/configure.in:1.2
@@ -48,6 +48,9 @@
 AC_CHECK_SIZEOF(long)
 SIZEOF_LONG=$ac_cv_sizeof_long
 AC_SUBST(SIZEOF_LONG)
+AC_CHECK_SIZEOF(short)
+SIZEOF_SHORT=$ac_cv_sizeof_short
+AC_SUBST(SIZEOF_SHORT)
 
 AC_MSG_CHECKING([return type of setrpcent])
 AC_CACHE_VAL(k5_cv_type_setrpcent,
Index: lib/rpc/getrpcent.c
diff -u krb5/lib/rpc/getrpcent.c:1.1.1.1 krb5/lib/rpc/getrpcent.c:1.2
@@ -116,7 +116,12 @@
 
 struct rpcent *
 getrpcbyname(name)
+#ifdef __convex__
+	char *name;
+#else
 	const char *name;
+
+#endif
 {
 	struct rpcent *rpc;
 	char **rp;
Index: lib/rpc/netdb.h
diff -u krb5/lib/rpc/netdb.h:1.1.1.1 krb5/lib/rpc/netdb.h:1.2
@@ -46,6 +46,9 @@
 };
 #endif /*STRUCT_RPCENT_IN_RPC_NETDB_H*/
 
+#ifndef __convex__
+/* Convex defines these slightly differently and makes gcc barf	*/
 struct rpcent *getrpcbyname(), *getrpcbynumber(), *getrpcent();
+#endif
 
 #endif
Index: lib/rpc/svc_auth_gssapi.c
diff -u krb5/lib/rpc/svc_auth_gssapi.c:1.1.1.2 krb5/lib/rpc/svc_auth_gssapi.c:1.3
@@ -5,6 +5,9 @@
  * $Source$
  * 
  * $Log$
+ * Revision 1.3  1997/11/03 22:14:53  kenh
+ * Fix up conflicts from Release 1.0.2 import.
+ *
  * Revision 1.1.1.2  1997/11/03 21:40:28  kenh
  * Import of Kerberos 5, Release 1.0.2
  *
Index: util/makeshlib.sh
diff -u krb5/util/makeshlib.sh:1.1.1.1 krb5/util/makeshlib.sh:1.2
@@ -156,7 +156,16 @@
 	ld -shared -expect_unresolved \* $ldflags -o $library -all $FILES $libdirfl $liblist -none -lc -update_registry ../../so_locations
 	stat=$?
 	;;
+mips-*-irix*)
+	FILES=`for i 
+	do
+		sed -e "s;^;$i/;" -e "s; ; $i/;g" $i/DONE
+	done`
 
+	echo ld -shared -rdata_shared $ldflags -o $library $optflags $FILES $libdirfl $liblist
+	ld -shared -rdata_shared $ldflags -o $library $optflags $FILES $libdirfl $liblist
+	stat=$?
+	;;
 *)
 	echo "Host type $host not supported!"
 	exit 1
Index: util/db2/acconfig.h
diff -u krb5/util/db2/acconfig.h:1.1.1.1 krb5/util/db2/acconfig.h:1.2
@@ -15,3 +15,6 @@
 #undef u_int16_t
 #undef int32_t
 #undef u_int32_t
+
+/* Define if we're using a btree database for the KDC */
+#undef USE_BTREE
Index: util/db2/configure.in
diff -u krb5/util/db2/configure.in:1.1.1.1 krb5/util/db2/configure.in:1.3
@@ -1,6 +1,7 @@
 dnl Process this file with autoconf to produce a configure script.
 AC_INIT(db/db.c)
 AC_CONFIG_HEADER(obj/db-config.h)
+CONFIG_RULES
 dnl checks for programs
 AC_PROG_CC
 AC_PROG_RANLIB
@@ -9,6 +10,11 @@
 AC_PATH_PROG(SH,sh,$FALSE)
 AC_PATH_PROG(SH5,sh5,$FALSE)
 AC_PATH_PROG(BASH,bash,$FALSE)
+
+AC_ARG_ENABLE([btree-db],
+[  --enable-btree-db       Use btree-format database for KDC],[
+echo "Using btree-style database for KDC"
+AC_DEFINE(USE_BTREE)])
 
 AC_CACHE_CHECK([checking for shell with functions],local_cv_program_fctsh,
 [if $SH -c 'foo() { true; }; foo' > /dev/null 2>&1; then
Index: util/db2/hash/dbm.c
diff -u krb5/util/db2/hash/dbm.c:1.1.1.2 krb5/util/db2/hash/dbm.c:1.3
@@ -47,7 +47,11 @@
 #include <string.h>
 
 #include "db-ndbm.h"
+#ifdef USE_BTREE
+#include "btree.h"
+#else
 #include "hash.h"
+#endif /* USE_BTREE */
 
 /* If the two size fields of datum and DBMT are not equal, then
  * casting between structures will result in stack garbage being
@@ -159,18 +163,29 @@
 	const char *file;
 	int flags, mode;
 {
+#ifdef USE_BTREE
+	BTREEINFO info;
+#else
 	HASHINFO info;
+#endif /* USE_BTREE */
 	char path[MAXPATHLEN];
 
-	info.bsize = 4096;
+#ifndef USE_BTREE
+	/* initial values for hash */
+	info.bsize = 8192;
 	info.ffactor = 40;
 	info.nelem = 1;
 	info.cachesize = 0;
 	info.hash = NULL;
 	info.lorder = 0;
+#endif
 	(void)strcpy(path, file);
 	(void)strcat(path, DBM_SUFFIX);
+#ifdef USE_BTREE
+	return ((DBM *)__bt_open(path, flags, mode, 0/*&info*/, 0));
+#else
 	return ((DBM *)__hash_open(path, flags, mode, &info, 0));
+#endif
 }
 
 /*
@@ -269,6 +284,107 @@
 
 /*
  * Returns:
+ *	DATUM on success
+ *	NULL on failure
+ * 
+ * This is only sensical for an ordered DB2 access method (like Btree).
+ */
+datum
+dbm_lastkey(db)
+	DBM *db;
+{
+	int status;
+	datum retdata, retkey;
+
+#ifdef USE_BTREE
+#ifdef NEED_COPY
+	DBT k, r;
+
+	status = (db->seq)(db, &k, &r, R_LAST);
+	retkey.dptr = k.data;
+	retkey.dsize = k.size;
+#else
+	status = (db->seq)(db, (DBT *)&retkey, (DBT *)&retdata, R_:AST);
+#endif /* NEED_COPY */
+	if (status)
+		retkey.dptr = NULL;
+#else /* USE_BTREE */
+	retkey.dptr = NULL;
+#endif /* USE_BTREE */
+	return (retkey);
+}
+
+/*
+ * Returns:
+ *	DATUM on success
+ *	NULL on failure
+ *
+ * This is only sensical for an ordered DB2 access method (like Btree).
+ */
+datum
+dbm_prevkey(db)
+	DBM *db;
+{
+	int status;
+	datum retdata, retkey;
+
+#ifdef USE_BTREE
+#ifdef NEED_COPY
+	DBT k, r;
+
+	status = (db->seq)(db, &k, &r, R_PREV);
+	retkey.dptr = k.data;
+	retkey.dsize = k.size;
+#else
+	status = (db->seq)(db, (DBT *)&retkey, (DBT *)&retdata, R_PREV);
+#endif /* NEED_COPY */
+	if (status)
+		retkey.dptr = NULL;
+#else
+	retkey.dptr = NULL;
+#endif /* USE_BTREE */
+	return (retkey);
+}
+
+/*
+ * Returns:
+ *	DATUM on success
+ *	NULL on failure
+ *
+ * This is only sensical for an ordered DB2 access method (like Btree).
+ */
+datum
+dbm_startkey(db, key)
+	DBM *db;
+	datum key;
+{
+	datum retval;
+	int status;
+
+#ifdef USE_BTREE
+#ifdef NEED_COPY
+	DBT k, r;
+
+	k.data = key.dptr;
+	k.size = key.dsize;
+	status = (db->seq)(db, &k, &r, R_CURSOR);
+	retval.dptr = r.data;
+	retval.dsize = r.size;
+#else
+	status = (db->seq)(db, (DBT *)&key, (DBT *)&retval, R_CURSOR);
+#endif
+	if (status) {
+		retval.dptr = NULL;
+		retval.dsize = 0;
+	}
+#else
+	retval.dptr = NULL;
+#endif /* USE_BTREE */
+	return (retval);
+}
+
+/*
+ * Returns:
  *	 0 on success
  *	<0 failure
  */
@@ -325,20 +441,28 @@
 dbm_error(db)
 	DBM *db;
 {
+#ifndef USE_BTREE
 	HTAB *hp;
 
 	hp = (HTAB *)db->internal;
 	return (hp->local_errno);
+#else
+	return errno;
+#endif
 }
 
 int
 dbm_clearerr(db)
 	DBM *db;
 {
+#ifndef USE_BTREE
 	HTAB *hp;
 
 	hp = (HTAB *)db->internal;
 	hp->local_errno = 0;
+#else
+	errno = 0;
+#endif
 	return (0);
 }
 
@@ -346,5 +470,9 @@
 dbm_dirfno(db)
 	DBM *db;
 {
+#ifndef USE_BTREE
 	return(((HTAB *)db->internal)->fp);
+#else
+	return(((BTREE *)db->internal)->bt_fd);
+#endif
 }
Index: util/db2/hash/hash.c
diff -u krb5/util/db2/hash/hash.c:1.1.1.2 krb5/util/db2/hash/hash.c:1.3
@@ -96,7 +96,7 @@
 extern DB *
 __hash_open(file, flags, mode, info, dflags)
 	const char *file;
-	int32_t flags, mode, dflags;
+	int flags, mode, dflags;
 	const HASHINFO *info;	/* Special directives for create */
 {
 	struct stat statbuf;
Index: util/db2/hash/hash_bigkey.c
diff -u krb5/util/db2/hash/hash_bigkey.c:1.1.1.1 krb5/util/db2/hash/hash_bigkey.c:1.2
@@ -386,7 +386,7 @@
 		totlen = len + BIGKEYLEN(pagep);
 		if (hashp->bigkey_buf)
 			free(hashp->bigkey_buf);
-		hashp->bigkey_buf = (char *)malloc(totlen);
+		hashp->bigkey_buf = (u_int8_t *)malloc(totlen);
 		if (!hashp->bigkey_buf)
 			return (-1);
 		memcpy(hashp->bigkey_buf + len,
@@ -400,7 +400,7 @@
 	if (BIGKEYLEN(pagep) == 0) {
 		if (hashp->bigkey_buf)
 			free(hashp->bigkey_buf);
-		hashp->bigkey_buf = (char *)malloc(len);
+		hashp->bigkey_buf = (u_int8_t *)malloc(len);
 		return (hashp->bigkey_buf ? len : -1);
 	}
 	totlen = len + BIGKEYLEN(pagep);
@@ -453,7 +453,7 @@
 		if (hashp->bigdata_buf)
 			free(hashp->bigdata_buf);
 		totlen = len + BIGDATALEN(pagep);
-		hashp->bigdata_buf = (char *)malloc(totlen);
+		hashp->bigdata_buf = (u_int8_t *)malloc(totlen);
 		if (!hashp->bigdata_buf)
 			return (-1);
 		memcpy(hashp->bigdata_buf + totlen - BIGDATALEN(pagep),
Index: util/db2/include/db-ndbm.h
diff -u krb5/util/db2/include/db-ndbm.h:1.1.1.1 krb5/util/db2/include/db-ndbm.h:1.2
@@ -74,6 +74,11 @@
 int	 dbm_dirfno __P((DBM *));
 int	 dbm_error __P((DBM *db));
 int	 dbm_clearerr __P((DBM *db));
+/* The following functions are only valid for Btree-accessed DB2
+   impementations. */
+datum	 dbm_startkey __P((DBM *, datum));
+datum	 dbm_lastkey __P((DBM *));
+datum	 dbm_prevkey __P((DBM *));
 __END_DECLS
 
 #endif /* !_NDBM_H_ */
Index: util/pty/update_utmp.c
diff -u krb5/util/pty/update_utmp.c:1.1.1.1 krb5/util/pty/update_utmp.c:1.2
@@ -81,7 +81,11 @@
 
 #ifndef NO_UT_PID
     if (!strcmp (line, "/dev/console"))
+#if defined(__sun) && defined(__SVR4)
+      strncpy (ent.ut_id, "co", 2);
+#else
       strncpy (ent.ut_id, "cons", 4);
+#endif
     else {
       tmpx = line + strlen(line)-1;
       if (*(tmpx-1) != '/') tmpx--; /* last two characters, unless it's a / */
